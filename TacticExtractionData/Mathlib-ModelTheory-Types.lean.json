[{"tailPos":2783,"headPos":2776,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np q : CompleteType T α\nh : (fun p => ↑p) p = (fun p => ↑p) q\n⊢ p = q"],"goalsAfter":["case mk\nL : Language\nT : Theory L\nα : Type w\nq : CompleteType T α\ntoTheory✝ : Theory (L[[α]])\nsubset'✝ : LHom.onTheory (lhomWithConstants L α) T ⊆ toTheory✝\nisMaximal'✝ : IsMaximal toTheory✝\nh : (fun p => ↑p) { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ } = (fun p => ↑p) q\n⊢ { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ } = q"],"content":"cases p"},{"tailPos":2795,"headPos":2788,"goalsBefore":["case mk\nL : Language\nT : Theory L\nα : Type w\nq : CompleteType T α\ntoTheory✝ : Theory (L[[α]])\nsubset'✝ : LHom.onTheory (lhomWithConstants L α) T ⊆ toTheory✝\nisMaximal'✝ : IsMaximal toTheory✝\nh : (fun p => ↑p) { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ } = (fun p => ↑p) q\n⊢ { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ } = q"],"goalsAfter":["case mk.mk\nL : Language\nT : Theory L\nα : Type w\ntoTheory✝¹ : Theory (L[[α]])\nsubset'✝¹ : LHom.onTheory (lhomWithConstants L α) T ⊆ toTheory✝¹\nisMaximal'✝¹ : IsMaximal toTheory✝¹\ntoTheory✝ : Theory (L[[α]])\nsubset'✝ : LHom.onTheory (lhomWithConstants L α) T ⊆ toTheory✝\nisMaximal'✝ : IsMaximal toTheory✝\nh :\n  (fun p => ↑p) { toTheory := toTheory✝¹, subset' := subset'✝¹, isMaximal' := isMaximal'✝¹ } =\n    (fun p => ↑p) { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ }\n⊢ { toTheory := toTheory✝¹, subset' := subset'✝¹, isMaximal' := isMaximal'✝¹ } =\n    { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ }"],"content":"cases q"},{"tailPos":2805,"headPos":2800,"goalsBefore":["case mk.mk\nL : Language\nT : Theory L\nα : Type w\ntoTheory✝¹ : Theory (L[[α]])\nsubset'✝¹ : LHom.onTheory (lhomWithConstants L α) T ⊆ toTheory✝¹\nisMaximal'✝¹ : IsMaximal toTheory✝¹\ntoTheory✝ : Theory (L[[α]])\nsubset'✝ : LHom.onTheory (lhomWithConstants L α) T ⊆ toTheory✝\nisMaximal'✝ : IsMaximal toTheory✝\nh :\n  (fun p => ↑p) { toTheory := toTheory✝¹, subset' := subset'✝¹, isMaximal' := isMaximal'✝¹ } =\n    (fun p => ↑p) { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ }\n⊢ { toTheory := toTheory✝¹, subset' := subset'✝¹, isMaximal' := isMaximal'✝¹ } =\n    { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ }"],"goalsAfter":[],"content":"congr"},{"tailPos":2805,"headPos":2776,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np q : CompleteType T α\nh : (fun p => ↑p) p = (fun p => ↑p) q\n⊢ p = q"],"goalsAfter":[],"content":"cases p\n    cases q\n    congr"},{"tailPos":2771,"headPos":2769,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np q : CompleteType T α\nh : (fun p => ↑p) p = (fun p => ↑p) q\n⊢ p = q"],"goalsAfter":[],"content":"by"},{"tailPos":2805,"headPos":2769,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np q : CompleteType T α\nh : (fun p => ↑p) p = (fun p => ↑p) q\n⊢ p = q"],"goalsAfter":[],"content":"by\n    cases p\n    cases q\n    congr"},{"tailPos":4271,"headPos":4241,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ ¬IsSatisfiable {φ, Formula.not φ}"],"goalsAfter":["case intro.mk\nL : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nCarrier✝ : Type (max (max u w) v)\nstruc✝ : Structure (L[[α]]) Carrier✝\nh : Carrier✝ ⊨ {φ, Formula.not φ}\nnonempty'✝ : Nonempty Carrier✝\n⊢ False"],"content":"rintro ⟨@⟨_, _, h, _⟩⟩"},{"tailPos":4368,"headPos":4278,"goalsBefore":["case intro.mk\nL : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nCarrier✝ : Type (max (max u w) v)\nstruc✝ : Structure (L[[α]]) Carrier✝\nh : Carrier✝ ⊨ {φ, Formula.not φ}\nnonempty'✝ : Nonempty Carrier✝\n⊢ False"],"goalsAfter":["case intro.mk\nL : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nCarrier✝ : Type (max (max u w) v)\nstruc✝ : Structure (L[[α]]) Carrier✝\nnonempty'✝ : Nonempty Carrier✝\nh : Carrier✝ ⊨ φ ∧ Carrier✝ ⊨ Formula.not φ\n⊢ False"],"content":"simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h"},{"tailPos":4388,"headPos":4375,"goalsBefore":["case intro.mk\nL : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nCarrier✝ : Type (max (max u w) v)\nstruc✝ : Structure (L[[α]]) Carrier✝\nnonempty'✝ : Nonempty Carrier✝\nh : Carrier✝ ⊨ φ ∧ Carrier✝ ⊨ Formula.not φ\n⊢ False"],"goalsAfter":[],"content":"exact h.2 h.1"},{"tailPos":4388,"headPos":4241,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ ¬IsSatisfiable {φ, Formula.not φ}"],"goalsAfter":[],"content":"rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1"},{"tailPos":4234,"headPos":4232,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ ¬IsSatisfiable {φ, Formula.not φ}"],"goalsAfter":[],"content":"by"},{"tailPos":4388,"headPos":4232,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ ¬IsSatisfiable {φ, Formula.not φ}"],"goalsAfter":[],"content":"by\n      rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1"},{"tailPos":4388,"headPos":4172,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ False"],"content":"have h : ¬IsSatisfiable ({φ, φ.not} : L[[α]].Theory) := by\n      rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1"},{"tailPos":4425,"headPos":4393,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ {φ, Formula.not φ} ⊆ ↑p"],"content":"refine' h (p.isMaximal.1.mono _)"},{"tailPos":4448,"headPos":4434,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ {φ, Formula.not φ} ⊆ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ {Formula.not φ} ⊆ ↑p"],"content":"insert_subset,"},{"tailPos":4469,"headPos":4449,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ {Formula.not φ} ⊆ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ Formula.not φ ∈ ↑p"],"content":"singleton_subset_iff"},{"tailPos":4470,"headPos":4469,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ Formula.not φ ∈ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ Formula.not φ ∈ ↑p"],"content":"]"},{"tailPos":4470,"headPos":4430,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ {φ, Formula.not φ} ⊆ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ Formula.not φ ∈ ↑p"],"content":"rw [insert_subset, singleton_subset_iff]"},{"tailPos":4493,"headPos":4475,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\nh : ¬IsSatisfiable {φ, Formula.not φ}\n⊢ φ ∈ ↑p ∧ Formula.not φ ∈ ↑p"],"goalsAfter":[],"content":"exact ⟨ht, hf⟩"},{"tailPos":4493,"headPos":4172,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ False"],"goalsAfter":[],"content":"have h : ¬IsSatisfiable ({φ, φ.not} : L[[α]].Theory) := by\n      rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1\n    refine' h (p.isMaximal.1.mono _)\n    rw [insert_subset, singleton_subset_iff]\n    exact ⟨ht, hf⟩"},{"tailPos":4167,"headPos":4165,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ False"],"goalsAfter":[],"content":"by"},{"tailPos":4493,"headPos":4165,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nφ : Sentence (L[[α]])\nhf : Formula.not φ ∈ p\nht : φ ∈ p\n⊢ False"],"goalsAfter":[],"content":"by\n    have h : ¬IsSatisfiable ({φ, φ.not} : L[[α]].Theory) := by\n      rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1\n    refine' h (p.isMaximal.1.mono _)\n    rw [insert_subset, singleton_subset_iff]\n    exact ⟨ht, hf⟩"},{"tailPos":5157,"headPos":5144,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ¬{p | S ⊆ ↑p} = ∅"],"content":"iff_not_comm,"},{"tailPos":5188,"headPos":5158,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ¬{p | S ⊆ ↑p} = ∅"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ¬¬Set.Nonempty {p | S ⊆ ↑p}"],"content":"← not_nonempty_iff_eq_empty,"},{"tailPos":5207,"headPos":5189,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ¬¬Set.Nonempty {p | S ⊆ ↑p}"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ Set.Nonempty {p | S ⊆ ↑p}"],"content":"Classical.not_not,"},{"tailPos":5220,"headPos":5208,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ Set.Nonempty {p | S ⊆ ↑p}"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ∃ x, x ∈ {p | S ⊆ ↑p}"],"content":"Set.Nonempty"},{"tailPos":5221,"headPos":5220,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ∃ x, x ∈ {p | S ⊆ ↑p}"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ∃ x, x ∈ {p | S ⊆ ↑p}"],"content":"]"},{"tailPos":5221,"headPos":5140,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ∃ x, x ∈ {p | S ⊆ ↑p}"],"content":"rw [iff_not_comm, ← not_nonempty_iff_eq_empty, Classical.not_not, Set.Nonempty]"},{"tailPos":5511,"headPos":5224,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S) ↔ ∃ x, x ∈ {p | S ⊆ ↑p}"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ (∃ x, x ∈ {p | S ⊆ ↑p}) → IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"content":"refine'\n    ⟨fun h =>\n      ⟨⟨L[[α]].completeTheory h.some, (subset_union_left _ S).trans completeTheory.subset,\n          completeTheory.isMaximal (L[[α]]) h.some⟩,\n        (subset_union_right ((L.lhomWithConstants α).onTheory T) _).trans completeTheory.subset⟩,\n      _⟩"},{"tailPos":5532,"headPos":5514,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ (∃ x, x ∈ {p | S ⊆ ↑p}) → IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\np : CompleteType T α\nhp : p ∈ {p | S ⊆ ↑p}\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"content":"rintro ⟨p, hp⟩"},{"tailPos":5586,"headPos":5535,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\np : CompleteType T α\nhp : p ∈ {p | S ⊆ ↑p}\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":[],"content":"exact p.isMaximal.1.mono (union_subset p.subset hp)"},{"tailPos":5586,"headPos":5140,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":[],"content":"rw [iff_not_comm, ← not_nonempty_iff_eq_empty, Classical.not_not, Set.Nonempty]\n  refine'\n    ⟨fun h =>\n      ⟨⟨L[[α]].completeTheory h.some, (subset_union_left _ S).trans completeTheory.subset,\n          completeTheory.isMaximal (L[[α]]) h.some⟩,\n        (subset_union_right ((L.lhomWithConstants α).onTheory T) _).trans completeTheory.subset⟩,\n      _⟩\n  rintro ⟨p, hp⟩\n  exact p.isMaximal.1.mono (union_subset p.subset hp)"},{"tailPos":5137,"headPos":5135,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":[],"content":"by"},{"tailPos":5586,"headPos":5135,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ S)"],"goalsAfter":[],"content":"by\n  rw [iff_not_comm, ← not_nonempty_iff_eq_empty, Classical.not_not, Set.Nonempty]\n  refine'\n    ⟨fun h =>\n      ⟨⟨L[[α]].completeTheory h.some, (subset_union_left _ S).trans completeTheory.subset,\n          completeTheory.isMaximal (L[[α]]) h.some⟩,\n        (subset_union_right ((L.lhomWithConstants α).onTheory T) _).trans completeTheory.subset⟩,\n      _⟩\n  rintro ⟨p, hp⟩\n  exact p.isMaximal.1.mono (union_subset p.subset hp)"},{"tailPos":5927,"headPos":5900,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ {Formula.not φ})"],"content":"models_iff_not_satisfiable,"},{"tailPos":5948,"headPos":5928,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p}ᶜ = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ {Formula.not φ})"],"content":"← compl_empty_iff,"},{"tailPos":5965,"headPos":5949,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p}ᶜ = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ {Formula.not φ})"],"content":"compl_setOf_mem,"},{"tailPos":5995,"headPos":5966,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ {p | {Formula.not φ} ⊆ ↑p} = ∅"],"content":"← setOf_subset_eq_empty_iff"},{"tailPos":5996,"headPos":5995,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ {p | {Formula.not φ} ⊆ ↑p} = ∅"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ {p | {Formula.not φ} ⊆ ↑p} = ∅"],"content":"]"},{"tailPos":5996,"headPos":5896,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ {p | {Formula.not φ} ⊆ ↑p} = ∅"],"content":"rw [models_iff_not_satisfiable, ← compl_empty_iff, compl_setOf_mem, ← setOf_subset_eq_empty_iff]"},{"tailPos":6003,"headPos":5999,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | Formula.not φ ∈ p} = ∅ ↔ {p | {Formula.not φ} ⊆ ↑p} = ∅"],"goalsAfter":[],"content":"simp only [singleton_subset_iff, SetLike.mem_coe]"},{"tailPos":6003,"headPos":5896,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":[],"content":"rw [models_iff_not_satisfiable, ← compl_empty_iff, compl_setOf_mem, ← setOf_subset_eq_empty_iff]\n  simp"},{"tailPos":5893,"headPos":5891,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":[],"content":"by"},{"tailPos":6003,"headPos":5891,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nφ : Sentence (L[[α]])\n⊢ {p | φ ∈ p} = Set.univ ↔ LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":[],"content":"by\n  rw [models_iff_not_satisfiable, ← compl_empty_iff, compl_setOf_mem, ← setOf_subset_eq_empty_iff]\n  simp"},{"tailPos":6440,"headPos":6437,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)"],"goalsAfter":["case h\nL : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nx✝ : CompleteType T α\n⊢ x✝ ∈ {p | S ⊆ ↑p} ↔ x✝ ∈ ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)"],"content":"ext"},{"tailPos":6462,"headPos":6445,"goalsBefore":["case h\nL : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nx✝ : CompleteType T α\n⊢ x✝ ∈ {p | S ⊆ ↑p} ↔ x✝ ∈ ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)"],"goalsAfter":[],"content":"simp [subset_def]"},{"tailPos":6462,"headPos":6437,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)"],"goalsAfter":[],"content":"ext\n    simp [subset_def]"},{"tailPos":6432,"headPos":6430,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)"],"goalsAfter":[],"content":"by"},{"tailPos":6462,"headPos":6430,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)"],"goalsAfter":[],"content":"by\n    ext\n    simp [subset_def]"},{"tailPos":6462,"headPos":6334,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"content":"have h : { p : T.CompleteType α | S ⊆ ↑p } = ⋂₀ ((fun φ => { p | φ ∈ p }) '' S) := by\n    ext\n    simp [subset_def]"},{"tailPos":6474,"headPos":6465,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"content":"simp_rw ["},{"tailPos":6476,"headPos":6474,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ ⋂₀ ((fun φ => {p | φ ∈ p}) '' S) = Set.univ ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"content":"h,"},{"tailPos":6492,"headPos":6477,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ ⋂₀ ((fun φ => {p | φ ∈ p}) '' S) = Set.univ ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ) ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"content":"sInter_eq_univ,"},{"tailPos":6518,"headPos":6493,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ) ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ) ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ"],"content":"← setOf_mem_eq_univ_iff"},{"tailPos":6519,"headPos":6465,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ) ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ"],"content":"simp_rw [h, sInter_eq_univ, ← setOf_mem_eq_univ_iff]"},{"tailPos":6576,"headPos":6522,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ) ↔\n    ∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ) →\n    ∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ"],"content":"refine' ⟨fun h φ φS => h _ ⟨_, φS, rfl⟩, _⟩"},{"tailPos":6607,"headPos":6579,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\n⊢ (∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ) →\n    ∀ (s : Set (CompleteType T α)), s ∈ (fun φ => {p | φ ∈ p}) '' S → s = Set.univ"],"goalsAfter":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh✝ : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\nh : ∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ\nφ : Sentence (L[[α]])\nh1 : φ ∈ S\n⊢ (fun φ => {p | φ ∈ p}) φ = Set.univ"],"content":"rintro h _ ⟨φ, h1, rfl⟩"},{"tailPos":6622,"headPos":6610,"goalsBefore":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\nh✝ : {p | S ⊆ ↑p} = ⋂₀ ((fun φ => {p | φ ∈ p}) '' S)\nh : ∀ (φ : Sentence (L[[α]])), φ ∈ S → {p | φ ∈ p} = Set.univ\nφ : Sentence (L[[α]])\nh1 : φ ∈ S\n⊢ (fun φ => {p | φ ∈ p}) φ = Set.univ"],"goalsAfter":[],"content":"exact h _ h1"},{"tailPos":6622,"headPos":6334,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":[],"content":"have h : { p : T.CompleteType α | S ⊆ ↑p } = ⋂₀ ((fun φ => { p | φ ∈ p }) '' S) := by\n    ext\n    simp [subset_def]\n  simp_rw [h, sInter_eq_univ, ← setOf_mem_eq_univ_iff]\n  refine' ⟨fun h φ φS => h _ ⟨_, φS, rfl⟩, _⟩\n  rintro h _ ⟨φ, h1, rfl⟩\n  exact h _ h1"},{"tailPos":6331,"headPos":6329,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":[],"content":"by"},{"tailPos":6622,"headPos":6329,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nS : Theory (L[[α]])\n⊢ {p | S ⊆ ↑p} = Set.univ ↔ ∀ (φ : Sentence (L[[α]])), φ ∈ S → LHom.onTheory (lhomWithConstants L α) T ⊨ᵇ φ"],"goalsAfter":[],"content":"by\n  have h : { p : T.CompleteType α | S ⊆ ↑p } = ⋂₀ ((fun φ => { p | φ ∈ p }) '' S) := by\n    ext\n    simp [subset_def]\n  simp_rw [h, sInter_eq_univ, ← setOf_mem_eq_univ_iff]\n  refine' ⟨fun h φ φS => h _ ⟨_, φS, rfl⟩, _⟩\n  rintro h _ ⟨φ, h1, rfl⟩\n  exact h _ h1"},{"tailPos":6913,"headPos":6848,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable T"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"content":"← isSatisfiable_onTheory_iff (lhomWithConstants_injective L α)"},{"tailPos":6914,"headPos":6913,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"content":"]"},{"tailPos":6914,"headPos":6844,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable T"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"content":"rw [← isSatisfiable_onTheory_iff (lhomWithConstants_injective L α)]"},{"tailPos":6948,"headPos":6921,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ Set.Nonempty Set.univ ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"content":"nonempty_iff_univ_nonempty,"},{"tailPos":6971,"headPos":6949,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Set.Nonempty Set.univ ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ Set.univ ≠ ∅ ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"content":"nonempty_iff_ne_empty,"},{"tailPos":6979,"headPos":6972,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Set.univ ≠ ∅ ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ ¬Set.univ = ∅ ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"content":"Ne.def,"},{"tailPos":6993,"headPos":6980,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ ¬Set.univ = ∅ ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T) ↔ Set.univ = ∅"],"content":"not_iff_comm,"},{"tailPos":7052,"headPos":6998,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T) ↔ Set.univ = ∅"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ ∅) ↔ Set.univ = ∅"],"content":"← union_empty ((L.lhomWithConstants α).onTheory T),"},{"tailPos":7082,"headPos":7053,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ ¬IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ ∅) ↔ Set.univ = ∅"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ {p | ∅ ⊆ ↑p} = ∅ ↔ Set.univ = ∅"],"content":"← setOf_subset_eq_empty_iff"},{"tailPos":7083,"headPos":7082,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ {p | ∅ ⊆ ↑p} = ∅ ↔ Set.univ = ∅"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ {p | ∅ ⊆ ↑p} = ∅ ↔ Set.univ = ∅"],"content":"]"},{"tailPos":7083,"headPos":6917,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\n⊢ {p | ∅ ⊆ ↑p} = ∅ ↔ Set.univ = ∅"],"content":"rw [nonempty_iff_univ_nonempty, nonempty_iff_ne_empty, Ne.def, not_iff_comm,\n    ← union_empty ((L.lhomWithConstants α).onTheory T), ← setOf_subset_eq_empty_iff]"},{"tailPos":7090,"headPos":7086,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ {p | ∅ ⊆ ↑p} = ∅ ↔ Set.univ = ∅"],"goalsAfter":[],"content":"simp only [empty_subset, setOf_true, univ_eq_empty_iff]"},{"tailPos":7090,"headPos":6844,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"rw [← isSatisfiable_onTheory_iff (lhomWithConstants_injective L α)]\n  rw [nonempty_iff_univ_nonempty, nonempty_iff_ne_empty, Ne.def, not_iff_comm,\n    ← union_empty ((L.lhomWithConstants α).onTheory T), ← setOf_subset_eq_empty_iff]\n  simp"},{"tailPos":6841,"headPos":6839,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"by"},{"tailPos":7090,"headPos":6839,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\n⊢ Nonempty (CompleteType T α) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"by\n  rw [← isSatisfiable_onTheory_iff (lhomWithConstants_injective L α)]\n  rw [nonempty_iff_univ_nonempty, nonempty_iff_ne_empty, Ne.def, not_iff_comm,\n    ← union_empty ((L.lhomWithConstants α).onTheory T), ← setOf_subset_eq_empty_iff]\n  simp"},{"tailPos":7630,"headPos":7627,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nι : Type u_1\nS : ι → Theory (L[[α]])\n⊢ (⋂ (i : ι), {p | S i ⊆ ↑p}) = {p | (⋃ (i : ι), S i) ⊆ ↑p}"],"goalsAfter":["case h\nL : Language\nT : Theory L\nα : Type w\nι : Type u_1\nS : ι → Theory (L[[α]])\nx✝ : CompleteType T α\n⊢ (x✝ ∈ ⋂ (i : ι), {p | S i ⊆ ↑p}) ↔ x✝ ∈ {p | (⋃ (i : ι), S i) ⊆ ↑p}"],"content":"ext"},{"tailPos":7688,"headPos":7633,"goalsBefore":["case h\nL : Language\nT : Theory L\nα : Type w\nι : Type u_1\nS : ι → Theory (L[[α]])\nx✝ : CompleteType T α\n⊢ (x✝ ∈ ⋂ (i : ι), {p | S i ⊆ ↑p}) ↔ x✝ ∈ {p | (⋃ (i : ι), S i) ⊆ ↑p}"],"goalsAfter":[],"content":"simp only [mem_iInter, mem_setOf_eq, iUnion_subset_iff]"},{"tailPos":7688,"headPos":7627,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nι : Type u_1\nS : ι → Theory (L[[α]])\n⊢ (⋂ (i : ι), {p | S i ⊆ ↑p}) = {p | (⋃ (i : ι), S i) ⊆ ↑p}"],"goalsAfter":[],"content":"ext\n  simp only [mem_iInter, mem_setOf_eq, iUnion_subset_iff]"},{"tailPos":7624,"headPos":7622,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nι : Type u_1\nS : ι → Theory (L[[α]])\n⊢ (⋂ (i : ι), {p | S i ⊆ ↑p}) = {p | (⋃ (i : ι), S i) ⊆ ↑p}"],"goalsAfter":[],"content":"by"},{"tailPos":7688,"headPos":7622,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nι : Type u_1\nS : ι → Theory (L[[α]])\n⊢ (⋂ (i : ι), {p | S i ⊆ ↑p}) = {p | (⋃ (i : ι), S i) ⊆ ↑p}"],"goalsAfter":[],"content":"by\n  ext\n  simp only [mem_iInter, mem_setOf_eq, iUnion_subset_iff]"},{"tailPos":7998,"headPos":7989,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"content":"simp_rw ["},{"tailPos":8009,"headPos":7998,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ∀ (x : Sentence (L[[α]])), x ∈ ↑t → x ∈ ↑p"],"content":"subset_def,"},{"tailPos":8030,"headPos":8010,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ∀ (x : Sentence (L[[α]])), x ∈ ↑t → x ∈ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ ↑p ↔ ∀ (x : Sentence (L[[α]])), x ∈ ↑t → x ∈ ↑p"],"content":"← SetLike.mem_coe,"},{"tailPos":8058,"headPos":8031,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ ↑p ↔ ∀ (x : Sentence (L[[α]])), x ∈ ↑t → x ∈ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ ↑p ⊨ᵇ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ↔ ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ↑p ⊨ᵇ x"],"content":"p.isMaximal.mem_iff_models,"},{"tailPos":8079,"headPos":8059,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ ↑p ⊨ᵇ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ↔ ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ↑p ⊨ᵇ x"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p), ↑M ⊨ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t)) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), ↑M ⊨ x"],"content":"models_sentence_iff,"},{"tailPos":8101,"headPos":8084,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p), ↑M ⊨ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t)) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), ↑M ⊨ x"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p), Formula.Realize (List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t)) default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), Formula.Realize x default"],"content":"Sentence.Realize,"},{"tailPos":8118,"headPos":8102,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p), Formula.Realize (List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t)) default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), Formula.Realize x default"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p),\n      BoundedFormula.Realize (List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t)) default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"content":"Formula.Realize,"},{"tailPos":8152,"headPos":8119,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p),\n      BoundedFormula.Realize (List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t)) default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p) (φ : BoundedFormula (L[[α]]) Empty 0),\n      φ ∈ Finset.toList t → BoundedFormula.Realize φ default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"content":"BoundedFormula.realize_foldr_inf,"},{"tailPos":8170,"headPos":8153,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p) (φ : BoundedFormula (L[[α]]) Empty 0),\n      φ ∈ Finset.toList t → BoundedFormula.Realize φ default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p) (φ : BoundedFormula (L[[α]]) Empty 0), φ ∈ t → BoundedFormula.Realize φ default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"content":"simp only [Finset.mem_toList]"},{"tailPos":8171,"headPos":7989,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p) (φ : BoundedFormula (L[[α]]) Empty 0), φ ∈ t → BoundedFormula.Realize φ default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"content":"simp_rw [subset_def, ← SetLike.mem_coe, p.isMaximal.mem_iff_models, models_sentence_iff,\n    Sentence.Realize, Formula.Realize, BoundedFormula.realize_foldr_inf, Finset.mem_toList]"},{"tailPos":8242,"headPos":8174,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ (∀ (M : ModelType ↑p) (φ : BoundedFormula (L[[α]]) Empty 0), φ ∈ t → BoundedFormula.Realize φ default default) ↔\n    ∀ (x : Sentence (L[[α]])), x ∈ ↑t → ∀ (M : ModelType ↑p), BoundedFormula.Realize x default default"],"goalsAfter":[],"content":"exact ⟨fun h φ hφ M => h _ _ hφ, fun h M φ hφ => h _ hφ _⟩"},{"tailPos":8242,"headPos":7989,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"goalsAfter":[],"content":"simp_rw [subset_def, ← SetLike.mem_coe, p.isMaximal.mem_iff_models, models_sentence_iff,\n    Sentence.Realize, Formula.Realize, BoundedFormula.realize_foldr_inf, Finset.mem_toList]\n  exact ⟨fun h φ hφ M => h _ _ hφ, fun h M φ hφ => h _ hφ _⟩"},{"tailPos":7986,"headPos":7984,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"goalsAfter":[],"content":"by"},{"tailPos":8242,"headPos":7984,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\np : CompleteType T α\nt : Finset (Sentence (L[[α]]))\n⊢ List.foldr (fun x x_1 => x ⊓ x_1) ⊤ (Finset.toList t) ∈ p ↔ ↑t ⊆ ↑p"],"goalsAfter":[],"content":"by\n  simp_rw [subset_def, ← SetLike.mem_coe, p.isMaximal.mem_iff_models, models_sentence_iff,\n    Sentence.Realize, Formula.Realize, BoundedFormula.realize_foldr_inf, Finset.mem_toList]\n  exact ⟨fun h φ hφ M => h _ _ hφ, fun h M φ hφ => h _ hφ _⟩"},{"tailPos":9470,"headPos":9466,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\nv : α → M\nφ : Formula L α\n⊢ ↑Formula.equivSentence φ ∈ typeOf T v ↔ Formula.Realize φ v"],"goalsAfter":[],"content":"simp only [mem_typeOf, _root_.Equiv.symm_apply_apply]"},{"tailPos":9465,"headPos":9463,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\nv : α → M\nφ : Formula L α\n⊢ ↑Formula.equivSentence φ ∈ typeOf T v ↔ Formula.Realize φ v"],"goalsAfter":[],"content":"by"},{"tailPos":9470,"headPos":9463,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\nv : α → M\nφ : Formula L α\n⊢ ↑Formula.equivSentence φ ∈ typeOf T v ↔ Formula.Realize φ v"],"goalsAfter":[],"content":"by simp"},{"tailPos":10289,"headPos":10258,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\np : CompleteType T α\n⊢ ∃ M, p ∈ realizedTypes T (↑M) α"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\n⊢ ∃ M, p ∈ realizedTypes T (↑M) α"],"content":"obtain ⟨M⟩ := p.isMaximal.1"},{"tailPos":10392,"headPos":10292,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\n⊢ ∃ M, p ∈ realizedTypes T (↑M) α"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\n⊢ (typeOf T fun a => ↑(Language.con L a)) = p"],"content":"refine' ⟨(M.subtheoryModel p.subset).reduct (L.lhomWithConstants α), fun a => (L.con a : M), _⟩"},{"tailPos":10426,"headPos":10395,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\n⊢ (typeOf T fun a => ↑(Language.con L a)) = p"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\nφ : Sentence (L[[α]])\n⊢ (φ ∈ typeOf T fun a => ↑(Language.con L a)) ↔ φ ∈ p"],"content":"refine' SetLike.ext fun φ => _"},{"tailPos":10464,"headPos":10429,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\nφ : Sentence (L[[α]])\n⊢ (φ ∈ typeOf T fun a => ↑(Language.con L a)) ↔ φ ∈ p"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\nφ : Sentence (L[[α]])\n⊢ (Formula.Realize (↑Formula.equivSentence.symm φ) fun a => ↑(Language.con L a)) ↔ φ ∈ p"],"content":"simp only [CompleteType.mem_typeOf]"},{"tailPos":10747,"headPos":10467,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\nφ : Sentence (L[[α]])\n⊢ (Formula.Realize (↑Formula.equivSentence.symm φ) fun a => ↑(Language.con L a)) ↔ φ ∈ p"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\nφ : Sentence (L[[α]])\n⊢ ↑(ModelType.reduct (lhomWithConstants L α)\n          (ModelType.subtheoryModel M (_ : LHom.onTheory (lhomWithConstants L α) T ⊆ ↑p))) ⊨\n      φ ↔\n    ↑M ⊨ φ"],"content":"refine'\n    (@Formula.realize_equivSentence_symm_con _\n      ((M.subtheoryModel p.subset).reduct (L.lhomWithConstants α)) _ _ M.struc _ φ).trans\n      (_root_.trans (_root_.trans _ (p.isMaximal.isComplete.realize_sentence_iff φ M))\n        (p.isMaximal.mem_iff_models φ).symm)"},{"tailPos":10753,"headPos":10750,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nM✝ : Type w'\ninst✝² : Structure L M✝\ninst✝¹ : Nonempty M✝\ninst✝ : M✝ ⊨ T\np : CompleteType T α\nM : ModelType ↑p\nφ : Sentence (L[[α]])\n⊢ ↑(ModelType.reduct (lhomWithConstants L α)\n          (ModelType.subtheoryModel M (_ : LHom.onTheory (lhomWithConstants L α) T ⊆ ↑p))) ⊨\n      φ ↔\n    ↑M ⊨ φ"],"goalsAfter":[],"content":"rfl"},{"tailPos":10753,"headPos":10258,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\np : CompleteType T α\n⊢ ∃ M, p ∈ realizedTypes T (↑M) α"],"goalsAfter":[],"content":"obtain ⟨M⟩ := p.isMaximal.1\n  refine' ⟨(M.subtheoryModel p.subset).reduct (L.lhomWithConstants α), fun a => (L.con a : M), _⟩\n  refine' SetLike.ext fun φ => _\n  simp only [CompleteType.mem_typeOf]\n  refine'\n    (@Formula.realize_equivSentence_symm_con _\n      ((M.subtheoryModel p.subset).reduct (L.lhomWithConstants α)) _ _ M.struc _ φ).trans\n      (_root_.trans (_root_.trans _ (p.isMaximal.isComplete.realize_sentence_iff φ M))\n        (p.isMaximal.mem_iff_models φ).symm)\n  rfl"},{"tailPos":10255,"headPos":10253,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\np : CompleteType T α\n⊢ ∃ M, p ∈ realizedTypes T (↑M) α"],"goalsAfter":[],"content":"by"},{"tailPos":10753,"headPos":10253,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : Nonempty M\ninst✝ : M ⊨ T\np : CompleteType T α\n⊢ ∃ M, p ∈ realizedTypes T (↑M) α"],"goalsAfter":[],"content":"by\n  obtain ⟨M⟩ := p.isMaximal.1\n  refine' ⟨(M.subtheoryModel p.subset).reduct (L.lhomWithConstants α), fun a => (L.con a : M), _⟩\n  refine' SetLike.ext fun φ => _\n  simp only [CompleteType.mem_typeOf]\n  refine'\n    (@Formula.realize_equivSentence_symm_con _\n      ((M.subtheoryModel p.subset).reduct (L.lhomWithConstants α)) _ _ M.struc _ φ).trans\n      (_root_.trans (_root_.trans _ (p.isMaximal.isComplete.realize_sentence_iff φ M))\n        (p.isMaximal.mem_iff_models φ).symm)\n  rfl"}]
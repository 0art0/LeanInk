[{"tailPos":6755,"headPos":6686,"goalsBefore":["α : Type ?u.3223\nι : Type ?u.3229\nκ : Type ?u.3228\nC : (ι → Option α) → κ\n⊢ Inhabited (ColorFocused C)"],"goalsAfter":["α : Type ?u.3223\nι : Type ?u.3229\nκ : Type ?u.3228\nC : (ι → Option α) → κ\nh : AlmostMono C\n⊢ h ∈ 0 → (fun x i => Option.getD (idxFun h.line i) x) none = fun x => none"],"content":"refine' ⟨⟨0, fun _ => none, fun h => _, Multiset.nodup_zero⟩⟩"},{"tailPos":6811,"headPos":6758,"goalsBefore":["α : Type ?u.3223\nι : Type ?u.3229\nκ : Type ?u.3228\nC : (ι → Option α) → κ\nh : AlmostMono C\n⊢ h ∈ 0 → (fun x i => Option.getD (idxFun h.line i) x) none = fun x => none"],"goalsAfter":[],"content":"simp only [Multiset.not_mem_zero, IsEmpty.forall_iff]"},{"tailPos":6811,"headPos":6686,"goalsBefore":["α : Type ?u.3223\nι : Type ?u.3229\nκ : Type ?u.3228\nC : (ι → Option α) → κ\n⊢ Inhabited (ColorFocused C)"],"goalsAfter":[],"content":"refine' ⟨⟨0, fun _ => none, fun h => _, Multiset.nodup_zero⟩⟩\n  simp only [Multiset.not_mem_zero, IsEmpty.forall_iff]"},{"tailPos":6683,"headPos":6681,"goalsBefore":["α : Type ?u.3223\nι : Type ?u.3229\nκ : Type ?u.3228\nC : (ι → Option α) → κ\n⊢ Inhabited (ColorFocused C)"],"goalsAfter":[],"content":"by"},{"tailPos":6811,"headPos":6681,"goalsBefore":["α : Type ?u.3223\nι : Type ?u.3229\nκ : Type ?u.3228\nC : (ι → Option α) → κ\n⊢ Inhabited (ColorFocused C)"],"goalsAfter":[],"content":"by\n  refine' ⟨⟨0, fun _ => none, fun h => _, Multiset.nodup_zero⟩⟩\n  simp only [Multiset.not_mem_zero, IsEmpty.forall_iff]"},{"tailPos":7216,"headPos":7166,"goalsBefore":["α : Type ?u.3745\nα' : Type ?u.3749\nι : Type ?u.3744\nf : α → α'\nl : Line α ι\n⊢ (fun i => Option.map f (idxFun l i)) (Exists.choose (_ : ∃ i, idxFun l i = none)) = none"],"goalsAfter":[],"content":"simp only [l.proper.choose_spec, Option.map_none']"},{"tailPos":7165,"headPos":7163,"goalsBefore":["α : Type ?u.3745\nα' : Type ?u.3749\nι : Type ?u.3744\nf : α → α'\nl : Line α ι\n⊢ (fun i => Option.map f (idxFun l i)) (Exists.choose (_ : ∃ i, idxFun l i = none)) = none"],"goalsAfter":[],"content":"by"},{"tailPos":7216,"headPos":7163,"goalsBefore":["α : Type ?u.3745\nα' : Type ?u.3749\nι : Type ?u.3744\nf : α → α'\nl : Line α ι\n⊢ (fun i => Option.map f (idxFun l i)) (Exists.choose (_ : ∃ i, idxFun l i = none)) = none"],"goalsAfter":[],"content":"by simp only [l.proper.choose_spec, Option.map_none']"},{"tailPos":8655,"headPos":8615,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i = none\n⊢ (fun x i => Option.getD (idxFun l i) x) x i = x"],"goalsAfter":[],"content":"simp only [Option.getD_none, h, l.apply]"},{"tailPos":8612,"headPos":8610,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i = none\n⊢ (fun x i => Option.getD (idxFun l i) x) x i = x"],"goalsAfter":[],"content":"by"},{"tailPos":8655,"headPos":8610,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i = none\n⊢ (fun x i => Option.getD (idxFun l i) x) x i = x"],"goalsAfter":[],"content":"by\n  simp only [Option.getD_none, h, l.apply]"},{"tailPos":8868,"headPos":8860,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ some ((fun x i => Option.getD (idxFun l i) x) x i) = idxFun l i"],"goalsAfter":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ some ((fun i => Option.getD (idxFun l i) x) i) = idxFun l i"],"content":"l.apply,"},{"tailPos":8893,"headPos":8869,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ some ((fun i => Option.getD (idxFun l i) x) i) = idxFun l i"],"goalsAfter":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ idxFun l i = idxFun l i"],"content":"Option.getD_of_ne_none h"},{"tailPos":8894,"headPos":8893,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ idxFun l i = idxFun l i"],"goalsAfter":[],"content":"]"},{"tailPos":8894,"headPos":8856,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ some ((fun x i => Option.getD (idxFun l i) x) x i) = idxFun l i"],"goalsAfter":[],"content":"rw [l.apply, Option.getD_of_ne_none h]"},{"tailPos":8855,"headPos":8853,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ some ((fun x i => Option.getD (idxFun l i) x) x i) = idxFun l i"],"goalsAfter":[],"content":"by"},{"tailPos":8894,"headPos":8853,"goalsBefore":["α : Type u_1\nι : Type u_2\nl : Line α ι\nx : α\ni : ι\nh : idxFun l i ≠ none\n⊢ some ((fun x i => Option.getD (idxFun l i) x) x i) = idxFun l i"],"goalsAfter":[],"content":"by rw [l.apply, Option.getD_of_ne_none h]"},{"tailPos":9141,"headPos":9092,"goalsBefore":["α : Type u_1\nα' : Type u_2\nι : Type u_3\nf : α → α'\nl : Line α ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (map f l) i) x) (f x) = f ∘ (fun x i => Option.getD (idxFun l i) x) x"],"goalsAfter":["α : Type u_1\nα' : Type u_2\nι : Type u_3\nf : α → α'\nl : Line α ι\nx : α\n⊢ (fun i => f (Option.getD (idxFun l i) x)) = f ∘ fun i => Option.getD (idxFun l i) x"],"content":"simp only [Line.apply, Line.map, Option.getD_map]"},{"tailPos":9147,"headPos":9144,"goalsBefore":["α : Type u_1\nα' : Type u_2\nι : Type u_3\nf : α → α'\nl : Line α ι\nx : α\n⊢ (fun i => f (Option.getD (idxFun l i) x)) = f ∘ fun i => Option.getD (idxFun l i) x"],"goalsAfter":[],"content":"rfl"},{"tailPos":9147,"headPos":9092,"goalsBefore":["α : Type u_1\nα' : Type u_2\nι : Type u_3\nf : α → α'\nl : Line α ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (map f l) i) x) (f x) = f ∘ (fun x i => Option.getD (idxFun l i) x) x"],"goalsAfter":[],"content":"simp only [Line.apply, Line.map, Option.getD_map]\n  rfl"},{"tailPos":9089,"headPos":9087,"goalsBefore":["α : Type u_1\nα' : Type u_2\nι : Type u_3\nf : α → α'\nl : Line α ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (map f l) i) x) (f x) = f ∘ (fun x i => Option.getD (idxFun l i) x) x"],"goalsAfter":[],"content":"by"},{"tailPos":9147,"headPos":9087,"goalsBefore":["α : Type u_1\nα' : Type u_2\nι : Type u_3\nf : α → α'\nl : Line α ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (map f l) i) x) (f x) = f ∘ (fun x i => Option.getD (idxFun l i) x) x"],"goalsAfter":[],"content":"by\n  simp only [Line.apply, Line.map, Option.getD_map]\n  rfl"},{"tailPos":9356,"headPos":9348,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x)"],"goalsAfter":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x i = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) i"],"content":"funext i"},{"tailPos":9366,"headPos":9359,"goalsBefore":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x i = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) i"],"goalsAfter":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inl val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inr val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inr val✝)"],"content":"cases i"},{"tailPos":9370,"headPos":9367,"goalsBefore":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inl val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inr val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inr val✝)"],"goalsAfter":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inl val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inr val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inr val✝)"],"content":"<;>"},{"tailPos":9374,"headPos":9371,"goalsBefore":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inl val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inl val✝)"],"goalsAfter":[],"content":"rfl"},{"tailPos":9374,"headPos":9371,"goalsBefore":["case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x (Sum.inr val✝) =\n    Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) (Sum.inr val✝)"],"goalsAfter":[],"content":"rfl"},{"tailPos":9374,"headPos":9359,"goalsBefore":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x i = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x) i"],"goalsAfter":[],"content":"cases i <;> rfl"},{"tailPos":9374,"headPos":9348,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x)"],"goalsAfter":[],"content":"funext i\n  cases i <;> rfl"},{"tailPos":9345,"headPos":9343,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x)"],"goalsAfter":[],"content":"by"},{"tailPos":9374,"headPos":9343,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nv : ι → α\nl : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (vertical v l) i) x) x = Sum.elim v ((fun x i => Option.getD (idxFun l i) x) x)"],"goalsAfter":[],"content":"by\n  funext i\n  cases i <;> rfl"},{"tailPos":9597,"headPos":9589,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v"],"goalsAfter":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x i = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v i"],"content":"funext i"},{"tailPos":9607,"headPos":9600,"goalsBefore":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x i = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v i"],"goalsAfter":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inr val✝)"],"content":"cases i"},{"tailPos":9611,"headPos":9608,"goalsBefore":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inr val✝)"],"goalsAfter":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inr val✝)"],"content":"<;>"},{"tailPos":9615,"headPos":9612,"goalsBefore":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inl val✝)"],"goalsAfter":[],"content":"rfl"},{"tailPos":9615,"headPos":9612,"goalsBefore":["case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v (Sum.inr val✝)"],"goalsAfter":[],"content":"rfl"},{"tailPos":9615,"headPos":9600,"goalsBefore":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x i = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v i"],"goalsAfter":[],"content":"cases i <;> rfl"},{"tailPos":9615,"headPos":9589,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v"],"goalsAfter":[],"content":"funext i\n  cases i <;> rfl"},{"tailPos":9586,"headPos":9584,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v"],"goalsAfter":[],"content":"by"},{"tailPos":9615,"headPos":9584,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nv : ι' → α\nx : α\n⊢ (fun x i => Option.getD (idxFun (horizontal l v) i) x) x = Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) v"],"goalsAfter":[],"content":"by\n  funext i\n  cases i <;> rfl"},{"tailPos":9838,"headPos":9830,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x)"],"goalsAfter":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x i =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) i"],"content":"funext i"},{"tailPos":9848,"headPos":9841,"goalsBefore":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x i =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) i"],"goalsAfter":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inr val✝)"],"content":"cases i"},{"tailPos":9852,"headPos":9849,"goalsBefore":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inr val✝)"],"goalsAfter":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inl val✝)","case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inr val✝)"],"content":"<;>"},{"tailPos":9856,"headPos":9853,"goalsBefore":["case h.inl\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inl val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inl val✝)"],"goalsAfter":[],"content":"rfl"},{"tailPos":9856,"headPos":9853,"goalsBefore":["case h.inr\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\nval✝ : ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x (Sum.inr val✝) =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) (Sum.inr val✝)"],"goalsAfter":[],"content":"rfl"},{"tailPos":9856,"headPos":9841,"goalsBefore":["case h\nα : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\ni : ι ⊕ ι'\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x i =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x) i"],"goalsAfter":[],"content":"cases i <;> rfl"},{"tailPos":9856,"headPos":9830,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x)"],"goalsAfter":[],"content":"funext i\n  cases i <;> rfl"},{"tailPos":9827,"headPos":9825,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x)"],"goalsAfter":[],"content":"by"},{"tailPos":9856,"headPos":9825,"goalsBefore":["α : Type u_1\nι : Type u_2\nι' : Type u_3\nl : Line α ι\nl' : Line α ι'\nx : α\n⊢ (fun x i => Option.getD (idxFun (prod l l') i) x) x =\n    Sum.elim ((fun x i => Option.getD (idxFun l i) x) x) ((fun x i => Option.getD (idxFun l' i) x) x)"],"goalsAfter":[],"content":"by\n  funext i\n  cases i <;> rfl"},{"tailPos":10041,"headPos":10032,"goalsBefore":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun i => Option.getD (idxFun (diagonal α ι) i) x) = fun x_1 => x"],"goalsAfter":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun i => Option.getD (idxFun (diagonal α ι) i) x) = fun x_1 => x"],"content":"simp_rw ["},{"tailPos":10055,"headPos":10041,"goalsBefore":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun i => Option.getD (idxFun (diagonal α ι) i) x) = fun x_1 => x"],"goalsAfter":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun i => Option.getD none x) = fun x_1 => x"],"content":"Line.diagonal,"},{"tailPos":10072,"headPos":10056,"goalsBefore":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun i => Option.getD none x) = fun x_1 => x"],"goalsAfter":[],"content":"simp only [Option.getD_none]"},{"tailPos":10073,"headPos":10032,"goalsBefore":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (diagonal α ι) i) x) x = fun x_1 => x"],"goalsAfter":[],"content":"simp_rw [Line.diagonal, Option.getD_none]"},{"tailPos":10029,"headPos":10027,"goalsBefore":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (diagonal α ι) i) x) x = fun x_1 => x"],"goalsAfter":[],"content":"by"},{"tailPos":10073,"headPos":10027,"goalsBefore":["α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nx : α\n⊢ (fun x i => Option.getD (idxFun (diagonal α ι) i) x) x = fun x_1 => x"],"goalsAfter":[],"content":"by\n  simp_rw [Line.diagonal, Option.getD_none]"},{"tailPos":11002,"headPos":10993,"goalsBefore":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (map (↑e) l) i) x) (↑e x)) = c"],"goalsAfter":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (map (↑e) l) i) x) (↑e x)) =\n    (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x)"],"content":"← lc x,"},{"tailPos":11017,"headPos":11003,"goalsBefore":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (map (↑e) l) i) x) (↑e x)) =\n    (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x)"],"goalsAfter":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C (↑e ∘ (fun x i => Option.getD (idxFun l i) x) x) = (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x)"],"content":"Line.map_apply"},{"tailPos":11018,"headPos":11017,"goalsBefore":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C (↑e ∘ (fun x i => Option.getD (idxFun l i) x) x) = (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x)"],"goalsAfter":[],"content":"]"},{"tailPos":11018,"headPos":10989,"goalsBefore":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (map (↑e) l) i) x) (↑e x)) = c"],"goalsAfter":[],"content":"rw [← lc x, Line.map_apply]"},{"tailPos":10988,"headPos":10986,"goalsBefore":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (map (↑e) l) i) x) (↑e x)) = c"],"goalsAfter":[],"content":"by"},{"tailPos":11018,"headPos":10986,"goalsBefore":["α α' : Type u\ne : α ≃ α'\nκ : Type (max v u)\nx✝¹ : Finite κ\nι : Type\nx✝ : Fintype ι\nh : ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nC : (ι → α') → κ\nl : Line α ι\nc : κ\nlc : ∀ (x : α), (fun v => C (↑e ∘ v)) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (map (↑e) l) i) x) (↑e x)) = c"],"goalsAfter":[],"content":"by rw [← lc x, Line.map_apply]"},{"tailPos":11107,"headPos":11097,"goalsBefore":["⊢ ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":["κ : Type (max v u)\ninst✝ : Finite κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"content":"intro κ _"},{"tailPos":11136,"headPos":11112,"goalsBefore":["κ : Type (max v u)\ninst✝ : Finite κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos\nκ : Type (max v u)\ninst✝ : Finite κ\nh : Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l","case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"content":"by_cases h : Nonempty κ"},{"tailPos":11143,"headPos":11141,"goalsBefore":["case pos\nκ : Type (max v u)\ninst✝ : Finite κ\nh : Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l","case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos\nκ : Type (max v u)\ninst✝ : Finite κ\nh : Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"content":"·"},{"tailPos":11236,"headPos":11144,"goalsBefore":["case pos\nκ : Type (max v u)\ninst✝ : Finite κ\nh : Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"refine' ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩"},{"tailPos":11236,"headPos":11141,"goalsBefore":["case pos\nκ : Type (max v u)\ninst✝ : Finite κ\nh : Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l","case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":["case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"content":"· refine' ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩"},{"tailPos":11243,"headPos":11241,"goalsBefore":["case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":["case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"content":"·"},{"tailPos":11315,"headPos":11244,"goalsBefore":["case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩"},{"tailPos":11315,"headPos":11241,"goalsBefore":["case neg\nκ : Type (max v u)\ninst✝ : Finite κ\nh : ¬Nonempty κ\n⊢ ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"· exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩"},{"tailPos":11315,"headPos":11097,"goalsBefore":["⊢ ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"intro κ _\n    by_cases h : Nonempty κ\n    · refine' ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩\n    · exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩"},{"tailPos":11028,"headPos":11026,"goalsBefore":["⊢ ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"by"},{"tailPos":11315,"headPos":11026,"goalsBefore":["⊢ ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → PEmpty) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"by\n    -- This deals with the degenerate case where `α` is empty.\n    intro κ _\n    by_cases h : Nonempty κ\n    · refine' ⟨Unit, inferInstance, fun C => ⟨default, Classical.arbitrary _, PEmpty.rec⟩⟩\n    · exact ⟨Empty, inferInstance, fun C => (h ⟨C (Empty.rec)⟩).elim⟩"},{"tailPos":11435,"headPos":11415,"goalsBefore":["⊢ ∀ {α : Type u} [inst : Fintype α],\n    (∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l) →\n      ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"content":"intro α _ ihα κ _"},{"tailPos":11465,"headPos":11440,"goalsBefore":["α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"content":"cases nonempty_fintype κ"},{"tailPos":11682,"headPos":11658,"goalsBefore":["case intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l","case neg\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"content":"by_cases h : Nonempty α"},{"tailPos":11792,"headPos":11706,"goalsBefore":["case neg\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case neg\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ ∀ (x : Option α), C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) x) = C fun x => none"],"content":"refine' ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩"},{"tailPos":11819,"headPos":11799,"goalsBefore":["case neg\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ ∀ (x : Option α), C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) x) = C fun x => none"],"goalsAfter":["case neg.none\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) none) = C fun x => none","case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"content":"rintro (_ | ⟨a⟩)"},{"tailPos":11828,"headPos":11826,"goalsBefore":["case neg.none\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) none) = C fun x => none","case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"goalsAfter":["case neg.none\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) none) = C fun x => none"],"content":"·"},{"tailPos":11832,"headPos":11829,"goalsBefore":["case neg.none\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) none) = C fun x => none"],"goalsAfter":[],"content":"rfl"},{"tailPos":11832,"headPos":11826,"goalsBefore":["case neg.none\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) none) = C fun x => none","case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"goalsAfter":["case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"content":"· rfl"},{"tailPos":11841,"headPos":11839,"goalsBefore":["case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"goalsAfter":["case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"content":"·"},{"tailPos":11864,"headPos":11842,"goalsBefore":["case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"goalsAfter":[],"content":"exact (h ⟨a⟩).elim"},{"tailPos":11864,"headPos":11839,"goalsBefore":["case neg.some\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\nC : (Unit → Option α) → κ\na : α\n⊢ C ((fun x i => Option.getD (idxFun (diagonal (Option α) Unit) i) x) (some a)) = C fun x => none"],"goalsAfter":[],"content":"· exact (h ⟨a⟩).elim"},{"tailPos":11864,"headPos":11706,"goalsBefore":["case neg\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"refine' ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩\n      rintro (_ | ⟨a⟩)\n      · rfl\n      · exact (h ⟨a⟩).elim"},{"tailPos":11864,"headPos":11687,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l","case neg\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : ¬Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"content":"on_goal 2 =>\n      refine' ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩\n      rintro (_ | ⟨a⟩)\n      · rfl\n      · exact (h ⟨a⟩).elim"},{"tailPos":12218,"headPos":12013,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l","case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"content":"suffices key :\n      ∀ r : ℕ,\n        ∃ (ι : Type)(_ : Fintype ι),\n          ∀ C : (ι → Option α) → κ,\n            (∃ s : ColorFocused C, Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"},{"tailPos":12403,"headPos":12401,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l","case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"content":"·"},{"tailPos":12460,"headPos":12404,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"content":"obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)"},{"tailPos":12523,"headPos":12467,"goalsBefore":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\n⊢ ¬∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1"],"content":"refine' ⟨ι, _inst, fun C => (hι C).resolve_left _⟩"},{"tailPos":12548,"headPos":12530,"goalsBefore":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\n⊢ ¬∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ False"],"content":"rintro ⟨s, sr⟩"},{"tailPos":12599,"headPos":12555,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ False"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Nat.succ (Fintype.card κ) ≤ Fintype.card κ"],"content":"apply Nat.not_succ_le_self (Fintype.card κ)"},{"tailPos":12626,"headPos":12610,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Nat.succ (Fintype.card κ) ≤ Fintype.card κ"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Fintype.card κ + 1 ≤ Fintype.card κ"],"content":"← Nat.add_one,"},{"tailPos":12634,"headPos":12627,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Fintype.card κ + 1 ≤ Fintype.card κ"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ ↑Multiset.card s.lines ≤ Fintype.card κ"],"content":"← sr,"},{"tailPos":12657,"headPos":12635,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ ↑Multiset.card s.lines ≤ Fintype.card κ"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ ↑Multiset.card (Multiset.map ?pos.intro.intro.intro.f✝ s.lines) ≤ Fintype.card κ","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16278","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16276"],"content":"← Multiset.card_map,"},{"tailPos":12676,"headPos":12658,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ ↑Multiset.card (Multiset.map ?pos.intro.intro.intro.f✝ s.lines) ≤ Fintype.card κ","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16278","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16276"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Finset.card { val := Multiset.map ?pos.intro.intro.intro.f✝ s.lines, nodup := ?m.16325 } ≤ Fintype.card κ","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16322","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Multiset.Nodup (Multiset.map ?pos.intro.intro.intro.f✝ s.lines)","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323"],"content":"← Finset.card_mk"},{"tailPos":12677,"headPos":12676,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Finset.card { val := Multiset.map ?pos.intro.intro.intro.f✝ s.lines, nodup := ?m.16325 } ≤ Fintype.card κ","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16322","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Multiset.Nodup (Multiset.map ?pos.intro.intro.intro.f✝ s.lines)","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Finset.card { val := Multiset.map ?pos.intro.intro.intro.f✝ s.lines, nodup := ?m.16325 } ≤ Fintype.card κ","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16322","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Multiset.Nodup (Multiset.map ?pos.intro.intro.intro.f✝ s.lines)","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323"],"content":"]"},{"tailPos":12677,"headPos":12606,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Nat.succ (Fintype.card κ) ≤ Fintype.card κ"],"goalsAfter":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Finset.card { val := Multiset.map ?pos.intro.intro.intro.f✝ s.lines, nodup := ?m.16325 } ≤ Fintype.card κ","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16322","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Multiset.Nodup (Multiset.map ?pos.intro.intro.intro.f✝ s.lines)","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323"],"content":"rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]"},{"tailPos":12736,"headPos":12684,"goalsBefore":["case pos.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Finset.card { val := Multiset.map ?pos.intro.intro.intro.f✝ s.lines, nodup := ?m.16325 } ≤ Fintype.card κ","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Type ?u.16322","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323","α : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ Multiset.Nodup (Multiset.map ?pos.intro.intro.intro.f✝ s.lines)","case pos.intro.intro.intro.f\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Fintype.card κ + 1) ∨ ∃ l, IsMono C l\nC : (ι → Option α) → κ\ns : ColorFocused C\nsr : ↑Multiset.card s.lines = Fintype.card κ + 1\n⊢ AlmostMono C → ?m.16323"],"goalsAfter":[],"content":"exact Finset.card_le_univ ⟨_, s.distinct_colors⟩"},{"tailPos":12736,"headPos":12404,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)\n      refine' ⟨ι, _inst, fun C => (hι C).resolve_left _⟩\n      rintro ⟨s, sr⟩\n      apply Nat.not_succ_le_self (Fintype.card κ)\n      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]\n      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩"},{"tailPos":12736,"headPos":12401,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nkey : ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l","case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"content":"· obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)\n      refine' ⟨ι, _inst, fun C => (hι C).resolve_left _⟩\n      rintro ⟨s, sr⟩\n      apply Nat.not_succ_le_self (Fintype.card κ)\n      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]\n      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩"},{"tailPos":12804,"headPos":12797,"goalsBefore":["case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∀ (r : ℕ), ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"content":"intro r"},{"tailPos":12832,"headPos":12809,"goalsBefore":["case key\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.zero\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.zero) ∨ ∃ l, IsMono C l","case key.succ\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nihr : ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"induction' r with r ihr"},{"tailPos":12921,"headPos":12919,"goalsBefore":["case key.zero\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.zero) ∨ ∃ l, IsMono C l","case key.succ\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nihr : ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.zero\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.zero) ∨ ∃ l, IsMono C l"],"content":"·"},{"tailPos":13005,"headPos":12922,"goalsBefore":["case key.zero\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.zero) ∨ ∃ l, IsMono C l"],"goalsAfter":[],"content":"exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩"},{"tailPos":13005,"headPos":12919,"goalsBefore":["case key.zero\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.zero) ∨ ∃ l, IsMono C l","case key.succ\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nihr : ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nihr : ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"· exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩"},{"tailPos":13176,"headPos":13142,"goalsBefore":["case key.succ\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nihr : ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"obtain ⟨ι, _inst, hι⟩ := ihr"},{"tailPos":13433,"headPos":13390,"goalsBefore":["case key.succ.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nihα : ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nihα : ∃ ι_1 x, ∀ (C : (ι_1 → α) → (ι → Option α) → κ), ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"specialize ihα ((ι → Option α) → κ)"},{"tailPos":13475,"headPos":13438,"goalsBefore":["case key.succ.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nihα : ∃ ι_1 x, ∀ (C : (ι_1 → α) → (ι → Option α) → κ), ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nhι' : ∀ (C : (ι' → α) → (ι → Option α) → κ), ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"obtain ⟨ι', _inst, hι'⟩ := ihα"},{"tailPos":13597,"headPos":13555,"goalsBefore":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nhι' : ∀ (C : (ι' → α) → (ι → Option α) → κ), ∃ l, IsMono C l\n⊢ ∃ ι x, ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nhι' : ∀ (C : (ι' → α) → (ι → Option α) → κ), ∃ l, IsMono C l\n⊢ ∀ (C : (ι ⊕ ι' → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"refine' ⟨Sum ι ι', inferInstance, _⟩"},{"tailPos":13609,"headPos":13602,"goalsBefore":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nhι' : ∀ (C : (ι' → α) → (ι → Option α) → κ), ∃ l, IsMono C l\n⊢ ∀ (C : (ι ⊕ ι' → Option α) → κ), (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nhι' : ∀ (C : (ι' → α) → (ι → Option α) → κ), ∃ l, IsMono C l\nC : (ι ⊕ ι' → Option α) → κ\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"intro C"},{"tailPos":13788,"headPos":13732,"goalsBefore":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nhι' : ∀ (C : (ι' → α) → (ι → Option α) → κ), ∃ l, IsMono C l\nC : (ι ⊕ ι' → Option α) → κ\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nhι' : ∃ l, IsMono (fun v' v => C (Sum.elim v (some ∘ v'))) l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))"},{"tailPos":13971,"headPos":13939,"goalsBefore":["case key.succ.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nhι' : ∃ l, IsMono (fun v' v => C (Sum.elim v (some ∘ v'))) l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"obtain ⟨l', C', hl'⟩ := hι'"},{"tailPos":14164,"headPos":14143,"goalsBefore":["α : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\n⊢ (∃ l, IsMono C' l) → ∃ l, IsMono C l"],"goalsAfter":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\n⊢ ∃ l, IsMono C l"],"content":"rintro ⟨l, c, hl⟩"},{"tailPos":14251,"headPos":14171,"goalsBefore":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\n⊢ ∃ l, IsMono C l"],"goalsAfter":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      ((fun x i =>\n          Option.getD\n            (idxFun (horizontal l (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) i) x)\n        x) =\n    c"],"content":"refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩"},{"tailPos":14284,"headPos":14262,"goalsBefore":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      ((fun x i =>\n          Option.getD\n            (idxFun (horizontal l (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) i) x)\n        x) =\n    c"],"goalsAfter":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun l i) x) x)\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) =\n    c"],"content":"Line.horizontal_apply,"},{"tailPos":14292,"headPos":14285,"goalsBefore":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun l i) x) x)\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) =\n    c"],"goalsAfter":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun l i) x) x)\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) =\n    C' ((fun x i => Option.getD (idxFun l i) x) ?intro.intro)","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ Option α"],"content":"← hl,"},{"tailPos":14300,"headPos":14293,"goalsBefore":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun l i) x) x)\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) =\n    C' ((fun x i => Option.getD (idxFun l i) x) ?intro.intro)","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ Option α"],"goalsAfter":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun l i) x) x)\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) ?intro.intro)\n      ((fun x i => Option.getD (idxFun l i) x) ?intro.intro)","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ α","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ Option α","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ Option α"],"content":"← hl'"},{"tailPos":14301,"headPos":14300,"goalsBefore":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun l i) x) x)\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) ?intro.intro)\n      ((fun x i => Option.getD (idxFun l i) x) ?intro.intro)","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ α","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ Option α","case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ Option α"],"goalsAfter":[],"content":"]"},{"tailPos":14301,"headPos":14258,"goalsBefore":["case intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nl : Line (Option α) ι\nc : κ\nhl : ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : Option α\n⊢ C\n      ((fun x i =>\n          Option.getD\n            (idxFun (horizontal l (some ∘ (fun x i => Option.getD (idxFun l' i) x) (Classical.arbitrary α))) i) x)\n        x) =\n    c"],"goalsAfter":[],"content":"rw [Line.horizontal_apply, ← hl, ← hl']"},{"tailPos":14301,"headPos":14143,"goalsBefore":["α : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\n⊢ (∃ l, IsMono C' l) → ∃ l, IsMono C l"],"goalsAfter":[],"content":"rintro ⟨l, c, hl⟩\n      refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩\n      rw [Line.horizontal_apply, ← hl, ← hl']"},{"tailPos":14136,"headPos":14134,"goalsBefore":["α : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\n⊢ (∃ l, IsMono C' l) → ∃ l, IsMono C l"],"goalsAfter":[],"content":"by"},{"tailPos":14301,"headPos":14134,"goalsBefore":["α : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\n⊢ (∃ l, IsMono C' l) → ∃ l, IsMono C l"],"goalsAfter":[],"content":"by\n      rintro ⟨l, c, hl⟩\n      refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩\n      rw [Line.horizontal_apply, ← hl, ← hl']"},{"tailPos":14301,"headPos":14068,"goalsBefore":["case key.succ.intro.intro.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"have mono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l := by\n      rintro ⟨l, c, hl⟩\n      refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩\n      rw [Line.horizontal_apply, ← hl, ← hl']"},{"tailPos":14414,"headPos":14397,"goalsBefore":["case key.succ.intro.intro.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nhι : ∀ (C : (ι → Option α) → κ), (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\nhι : (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C' l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"specialize hι C'"},{"tailPos":14452,"headPos":14419,"goalsBefore":["case key.succ.intro.intro.intro.intro.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\nhι : (∃ s, ↑Multiset.card s.lines = r) ∨ ∃ l, IsMono C' l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro.intro.intro.inl.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l","case key.succ.intro.intro.intro.intro.intro.intro.inr\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\nh : ∃ l, IsMono C' l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"rcases hι with (⟨s, sr⟩ | h)"},{"tailPos":14499,"headPos":14470,"goalsBefore":["case key.succ.intro.intro.intro.intro.intro.intro.inr\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\nh : ∃ l, IsMono C' l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":[],"content":"exact Or.inr (mono_of_mono h)"},{"tailPos":14499,"headPos":14457,"goalsBefore":["case key.succ.intro.intro.intro.intro.intro.intro.inl.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l","case key.succ.intro.intro.intro.intro.intro.intro.inr\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\nh : ∃ l, IsMono C' l\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case key.succ.intro.intro.intro.intro.intro.intro.inl.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"on_goal 2 => exact Or.inr (mono_of_mono h)"},{"tailPos":14739,"headPos":14670,"goalsBefore":["case key.succ.intro.intro.intro.intro.intro.intro.inl.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case pos\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l","case neg\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"by_cases h : ∃ p ∈ s.lines, (p : AlmostMono _).color = C' s.focus"},{"tailPos":14815,"headPos":14813,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l","case neg\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case pos\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"·"},{"tailPos":14846,"headPos":14816,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"obtain ⟨p, p_mem, hp⟩ := h"},{"tailPos":14907,"headPos":14853,"goalsBefore":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun p.line i) x) x) = p.color"],"content":"refine' Or.inr (mono_of_mono ⟨p.line, p.color, _⟩)"},{"tailPos":14928,"headPos":14914,"goalsBefore":["case pos.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ ∀ (x : Option α), C' ((fun x i => Option.getD (idxFun p.line i) x) x) = p.color"],"goalsAfter":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) none) = p.color","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"content":"rintro (_ | _)"},{"tailPos":14942,"headPos":14939,"goalsBefore":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) none) = p.color","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"goalsAfter":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) none) = C' s.focus","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"content":"hp,"},{"tailPos":14963,"headPos":14943,"goalsBefore":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) none) = C' s.focus","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"goalsAfter":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' s.focus = C' s.focus","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"content":"s.is_focused p p_mem"},{"tailPos":14964,"headPos":14963,"goalsBefore":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' s.focus = C' s.focus","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"goalsAfter":["case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"content":"]"},{"tailPos":14964,"headPos":14935,"goalsBefore":["case pos.intro.intro.none\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) none) = p.color","case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"goalsAfter":["case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"content":"rw [hp, s.is_focused p p_mem]"},{"tailPos":14988,"headPos":14971,"goalsBefore":["case pos.intro.intro.some\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝¹ : Fintype κ\nh : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\np : AlmostMono C'\np_mem : p ∈ s.lines\nhp : p.color = C' s.focus\nval✝ : α\n⊢ C' ((fun x i => Option.getD (idxFun p.line i) x) (some val✝)) = p.color"],"goalsAfter":[],"content":"apply p.has_color"},{"tailPos":14988,"headPos":14816,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":[],"content":"obtain ⟨p, p_mem, hp⟩ := h\n      refine' Or.inr (mono_of_mono ⟨p.line, p.color, _⟩)\n      rintro (_ | _)\n      rw [hp, s.is_focused p p_mem]\n      apply p.has_color"},{"tailPos":14988,"headPos":14813,"goalsBefore":["case pos\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l","case neg\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case neg\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"content":"· obtain ⟨p, p_mem, hp⟩ := h\n      refine' Or.inr (mono_of_mono ⟨p.line, p.color, _⟩)\n      rintro (_ | _)\n      rw [hp, s.is_focused p p_mem]\n      apply p.has_color"},{"tailPos":15337,"headPos":15171,"goalsBefore":["case neg\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (∃ s, ↑Multiset.card s.lines = Nat.succ r) ∨ ∃ l, IsMono C l"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ AlmostMono C' → AlmostMono C","case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus","case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map ?neg.refine'_1✝ s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map ?neg.refine'_1✝ s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map ?neg.refine'_1✝ s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"content":"refine' Or.inl ⟨⟨(s.lines.map _).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => _⟩,\n            Sum.elim s.focus (l'.map some none), _, _⟩, _⟩"},{"tailPos":15458,"headPos":15456,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ AlmostMono C' → AlmostMono C","case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus","case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map ?neg.refine'_1✝ s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map ?neg.refine'_1✝ s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map ?neg.refine'_1✝ s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ AlmostMono C' → AlmostMono C"],"content":"·"},{"tailPos":15528,"headPos":15459,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ AlmostMono C' → AlmostMono C"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color"],"content":"refine' fun p => ⟨p.line.prod (l'.map some), p.color, fun x => _⟩"},{"tailPos":15555,"headPos":15539,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        ((fun x i => Option.getD (idxFun (map some l') i) x) (some x))) =\n    p.color"],"content":"Line.prod_apply,"},{"tailPos":15571,"headPos":15556,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        ((fun x i => Option.getD (idxFun (map some l') i) x) (some x))) =\n    p.color"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    p.color"],"content":"Line.map_apply,"},{"tailPos":15588,"headPos":15572,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    p.color"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    C' ((fun x i => Option.getD (idxFun p.line i) x) (some ?neg.refine'_1✝))","case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ α"],"content":"← p.has_color,"},{"tailPos":15610,"headPos":15589,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    C' ((fun x i => Option.getD (idxFun p.line i) x) (some ?neg.refine'_1✝))","case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ α"],"goalsAfter":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x)\n      ((fun x i => Option.getD (idxFun p.line i) x) (some ?neg.refine'_1✝))","case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ α","case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ α"],"content":"← congr_fun (hl' x)"},{"tailPos":15611,"headPos":15610,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C\n      (Sum.elim ((fun x i => Option.getD (idxFun p.line i) x) (some x))\n        (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x)\n      ((fun x i => Option.getD (idxFun p.line i) x) (some ?neg.refine'_1✝))","case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ α","case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ α"],"goalsAfter":[],"content":"]"},{"tailPos":15611,"headPos":15535,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\np : AlmostMono C'\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color"],"goalsAfter":[],"content":"rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]"},{"tailPos":15611,"headPos":15459,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ AlmostMono C' → AlmostMono C"],"goalsAfter":[],"content":"refine' fun p => ⟨p.line.prod (l'.map some), p.color, fun x => _⟩\n      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]"},{"tailPos":15611,"headPos":15456,"goalsBefore":["case neg.refine'_1\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ AlmostMono C' → AlmostMono C","case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus","case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map ?neg.refine'_1✝ s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map ?neg.refine'_1✝ s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map ?neg.refine'_1✝ s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus","case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"content":"· refine' fun p => ⟨p.line.prod (l'.map some), p.color, fun x => _⟩\n      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]"},{"tailPos":15668,"headPos":15666,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus","case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus"],"content":"·"},{"tailPos":15688,"headPos":15673,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus"],"goalsAfter":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C (Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) (some x))) = C' s.focus"],"content":"vertical_apply,"},{"tailPos":15711,"headPos":15689,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C (Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) (some x))) = C' s.focus"],"goalsAfter":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C (Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) (some x))) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) s.focus"],"content":"← congr_fun (hl' x),"},{"tailPos":15726,"headPos":15712,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C (Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) (some x))) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) s.focus"],"goalsAfter":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C (Sum.elim s.focus (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) s.focus"],"content":"Line.map_apply"},{"tailPos":15727,"headPos":15726,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C (Sum.elim s.focus (some ∘ (fun x i => Option.getD (idxFun l' i) x) x)) =\n    (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) s.focus"],"goalsAfter":[],"content":"]"},{"tailPos":15727,"headPos":15669,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus"],"goalsAfter":[],"content":"rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]"},{"tailPos":15727,"headPos":15666,"goalsBefore":["case neg.refine'_2\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nx : α\n⊢ C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus","case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"content":"· rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]"},{"tailPos":15781,"headPos":15779,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)"],"content":"·"},{"tailPos":15791,"headPos":15782,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"simp_rw ["},{"tailPos":15809,"headPos":15791,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p =\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ∨\n        p ∈\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"Multiset.mem_cons,"},{"tailPos":15826,"headPos":15810,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p =\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ∨\n        p ∈\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    (p =\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ∨\n        ∃ a,\n          a ∈ s.lines ∧\n            { line := prod a.line (map some l'), color := a.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod a.line (map some l')) i) x) (some x)) = a.color) } =\n              p) →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"simp only [Multiset.mem_map]"},{"tailPos":15827,"headPos":15782,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)"],"goalsAfter":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    (p =\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ∨\n        ∃ a,\n          a ∈ s.lines ∧\n            { line := prod a.line (map some l'), color := a.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod a.line (map some l')) i) x) (some x)) = a.color) } =\n              p) →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"simp_rw [Multiset.mem_cons, Multiset.mem_map]"},{"tailPos":15867,"headPos":15834,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    (p =\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ∨\n        ∃ a,\n          a ∈ s.lines ∧\n            { line := prod a.line (map some l'), color := a.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod a.line (map some l')) i) x) (some x)) = a.color) } =\n              p) →\n      (fun i => Option.getD (idxFun p.line i) none) =\n        Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3.inl\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                      C' s.focus) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none","case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"rintro _ (rfl | ⟨q, hq, rfl⟩)"},{"tailPos":15876,"headPos":15874,"goalsBefore":["case neg.refine'_3.inl\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                      C' s.focus) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none","case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3.inl\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                      C' s.focus) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"·"},{"tailPos":15903,"headPos":15877,"goalsBefore":["case neg.refine'_3.inl\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                      C' s.focus) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":[],"content":"simp only [vertical_apply]"},{"tailPos":15903,"headPos":15874,"goalsBefore":["case neg.refine'_3.inl\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := vertical s.focus (map some l'), color := C' s.focus,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                      C' s.focus) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none","case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"· simp only [vertical_apply]"},{"tailPos":15912,"headPos":15910,"goalsBefore":["case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":["case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"content":"·"},{"tailPos":15954,"headPos":15913,"goalsBefore":["case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":[],"content":"simp only [prod_apply, s.is_focused q hq]"},{"tailPos":15954,"headPos":15910,"goalsBefore":["case neg.refine'_3.inr.intro.intro\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\nq : AlmostMono C'\nhq : q ∈ s.lines\n⊢ (fun i =>\n      Option.getD\n        (idxFun\n          { line := prod q.line (map some l'), color := q.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod q.line (map some l')) i) x) (some x)) = q.color) }.line\n          i)\n        none) =\n    Sum.elim s.focus fun i => Option.getD (idxFun (map some l') i) none"],"goalsAfter":[],"content":"· simp only [prod_apply, s.is_focused q hq]"},{"tailPos":15954,"headPos":15782,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)"],"goalsAfter":[],"content":"simp_rw [Multiset.mem_cons, Multiset.mem_map]\n      rintro _ (rfl | ⟨q, hq, rfl⟩)\n      · simp only [vertical_apply]\n      · simp only [prod_apply, s.is_focused q hq]"},{"tailPos":15954,"headPos":15779,"goalsBefore":["case neg.refine'_3\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ∀ (p : AlmostMono C),\n    p ∈\n        { line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) } ::ₘ\n          Multiset.map\n            (fun p =>\n              { line := prod p.line (map some l'), color := p.color,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n            s.lines →\n      (fun x i => Option.getD (idxFun p.line i) x) none =\n        Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)","case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused := ?neg.refine'_3✝, distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"content":"· simp_rw [Multiset.mem_cons, Multiset.mem_map]\n      rintro _ (rfl | ⟨q, hq, rfl⟩)\n      · simp only [vertical_apply]\n      · simp only [prod_apply, s.is_focused q hq]"},{"tailPos":16056,"headPos":16054,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))"],"content":"·"},{"tailPos":16079,"headPos":16061,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                  C' s.focus) }.color ::ₘ\n      Multiset.map AlmostMono.color\n        (Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))"],"content":"Multiset.map_cons,"},{"tailPos":16097,"headPos":16080,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                  C' s.focus) }.color ::ₘ\n      Multiset.map AlmostMono.color\n        (Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                  C' s.focus) }.color ::ₘ\n      Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"content":"Multiset.map_map,"},{"tailPos":16118,"headPos":16098,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                  C' s.focus) }.color ::ₘ\n      Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ¬{ line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) }.color ∈\n        Multiset.map\n          (AlmostMono.color ∘ fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"content":"Multiset.nodup_cons,"},{"tailPos":16135,"headPos":16119,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ¬{ line := vertical s.focus (map some l'), color := C' s.focus,\n            has_color :=\n              (_ :\n                ∀ (x : α),\n                  C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                    C' s.focus) }.color ∈\n        Multiset.map\n          (AlmostMono.color ∘ fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (¬∃ a,\n        a ∈ s.lines ∧\n          (AlmostMono.color ∘ fun p =>\n                { line := prod p.line (map some l'), color := p.color,\n                  has_color :=\n                    (_ :\n                      ∀ (x : α),\n                        C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n              a =\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) }.color) ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"content":"Multiset.mem_map"},{"tailPos":16136,"headPos":16135,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (¬∃ a,\n        a ∈ s.lines ∧\n          (AlmostMono.color ∘ fun p =>\n                { line := prod p.line (map some l'), color := p.color,\n                  has_color :=\n                    (_ :\n                      ∀ (x : α),\n                        C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n              a =\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) }.color) ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (¬∃ a,\n        a ∈ s.lines ∧\n          (AlmostMono.color ∘ fun p =>\n                { line := prod p.line (map some l'), color := p.color,\n                  has_color :=\n                    (_ :\n                      ∀ (x : α),\n                        C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n              a =\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) }.color) ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"content":"]"},{"tailPos":16136,"headPos":16057,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))"],"goalsAfter":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (¬∃ a,\n        a ∈ s.lines ∧\n          (AlmostMono.color ∘ fun p =>\n                { line := prod p.line (map some l'), color := p.color,\n                  has_color :=\n                    (_ :\n                      ∀ (x : α),\n                        C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n              a =\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) }.color) ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"content":"rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]"},{"tailPos":16214,"headPos":16143,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ (¬∃ a,\n        a ∈ s.lines ∧\n          (AlmostMono.color ∘ fun p =>\n                { line := prod p.line (map some l'), color := p.color,\n                  has_color :=\n                    (_ :\n                      ∀ (x : α),\n                        C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n              a =\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) }.color) ∧\n    Multiset.Nodup\n      (Multiset.map\n        (AlmostMono.color ∘ fun p =>\n          { line := prod p.line (map some l'), color := p.color,\n            has_color :=\n              (_ :\n                ∀ (x : α), C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n        s.lines)"],"goalsAfter":[],"content":"exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩"},{"tailPos":16214,"headPos":16057,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))"],"goalsAfter":[],"content":"rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]\n      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩"},{"tailPos":16214,"headPos":16054,"goalsBefore":["case neg.refine'_4\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ Multiset.Nodup\n    (Multiset.map AlmostMono.color\n      ({ line := vertical s.focus (map some l'), color := C' s.focus,\n          has_color :=\n            (_ :\n              ∀ (x : α),\n                C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) = C' s.focus) } ::ₘ\n        Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines))","case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors := ?neg.refine'_4✝ }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors :=\n            (_ :\n              Multiset.Nodup\n                (Multiset.map AlmostMono.color\n                  ({ line := vertical s.focus (map some l'), color := C' s.focus,\n                      has_color :=\n                        (_ :\n                          ∀ (x : α),\n                            C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                              C' s.focus) } ::ₘ\n                    Multiset.map\n                      (fun p =>\n                        { line := prod p.line (map some l'), color := p.color,\n                          has_color :=\n                            (_ :\n                              ∀ (x : α),\n                                C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                  p.color) })\n                      s.lines))) }.lines =\n    Nat.succ r"],"content":"· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]\n      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩"},{"tailPos":16268,"headPos":16266,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors :=\n            (_ :\n              Multiset.Nodup\n                (Multiset.map AlmostMono.color\n                  ({ line := vertical s.focus (map some l'), color := C' s.focus,\n                      has_color :=\n                        (_ :\n                          ∀ (x : α),\n                            C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                              C' s.focus) } ::ₘ\n                    Multiset.map\n                      (fun p =>\n                        { line := prod p.line (map some l'), color := p.color,\n                          has_color :=\n                            (_ :\n                              ∀ (x : α),\n                                C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                  p.color) })\n                      s.lines))) }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors :=\n            (_ :\n              Multiset.Nodup\n                (Multiset.map AlmostMono.color\n                  ({ line := vertical s.focus (map some l'), color := C' s.focus,\n                      has_color :=\n                        (_ :\n                          ∀ (x : α),\n                            C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                              C' s.focus) } ::ₘ\n                    Multiset.map\n                      (fun p =>\n                        { line := prod p.line (map some l'), color := p.color,\n                          has_color :=\n                            (_ :\n                              ∀ (x : α),\n                                C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                  p.color) })\n                      s.lines))) }.lines =\n    Nat.succ r"],"content":"·"},{"tailPos":16292,"headPos":16273,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors :=\n            (_ :\n              Multiset.Nodup\n                (Multiset.map AlmostMono.color\n                  ({ line := vertical s.focus (map some l'), color := C' s.focus,\n                      has_color :=\n                        (_ :\n                          ∀ (x : α),\n                            C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                              C' s.focus) } ::ₘ\n                    Multiset.map\n                      (fun p =>\n                        { line := prod p.line (map some l'), color := p.color,\n                          has_color :=\n                            (_ :\n                              ∀ (x : α),\n                                C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                  p.color) })\n                      s.lines))) }.lines =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n        (Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines) +\n      1 =\n    Nat.succ r"],"content":"Multiset.card_cons,"},{"tailPos":16311,"headPos":16293,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n        (Multiset.map\n          (fun p =>\n            { line := prod p.line (map some l'), color := p.color,\n              has_color :=\n                (_ :\n                  ∀ (x : α),\n                    C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n          s.lines) +\n      1 =\n    Nat.succ r"],"goalsAfter":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card s.lines + 1 = Nat.succ r"],"content":"Multiset.card_map,"},{"tailPos":16314,"headPos":16312,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card s.lines + 1 = Nat.succ r"],"goalsAfter":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ r + 1 = Nat.succ r"],"content":"sr"},{"tailPos":16315,"headPos":16314,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ r + 1 = Nat.succ r"],"goalsAfter":[],"content":"]"},{"tailPos":16315,"headPos":16269,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors :=\n            (_ :\n              Multiset.Nodup\n                (Multiset.map AlmostMono.color\n                  ({ line := vertical s.focus (map some l'), color := C' s.focus,\n                      has_color :=\n                        (_ :\n                          ∀ (x : α),\n                            C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                              C' s.focus) } ::ₘ\n                    Multiset.map\n                      (fun p =>\n                        { line := prod p.line (map some l'), color := p.color,\n                          has_color :=\n                            (_ :\n                              ∀ (x : α),\n                                C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                  p.color) })\n                      s.lines))) }.lines =\n    Nat.succ r"],"goalsAfter":[],"content":"rw [Multiset.card_cons, Multiset.card_map, sr]"},{"tailPos":16315,"headPos":16266,"goalsBefore":["case neg.refine'_5\nα : Type u\ninst✝¹ : Fintype α\nκ : Type (max v u)\ninst✝ : Finite κ\nval✝ : Fintype κ\nh✝ : Nonempty α\nr : ℕ\nι : Type\n_inst✝ : Fintype ι\nι' : Type\n_inst : Fintype ι'\nC : (ι ⊕ ι' → Option α) → κ\nl' : Line α ι'\nC' : (ι → Option α) → κ\nhl' : ∀ (x : α), (fun v' v => C (Sum.elim v (some ∘ v'))) ((fun x i => Option.getD (idxFun l' i) x) x) = C'\nmono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l\ns : ColorFocused C'\nsr : ↑Multiset.card s.lines = r\nh : ¬∃ p, p ∈ s.lines ∧ p.color = C' s.focus\n⊢ ↑Multiset.card\n      {\n          lines :=\n            { line := vertical s.focus (map some l'), color := C' s.focus,\n                has_color :=\n                  (_ :\n                    ∀ (x : α),\n                      C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                        C' s.focus) } ::ₘ\n              Multiset.map\n                (fun p =>\n                  { line := prod p.line (map some l'), color := p.color,\n                    has_color :=\n                      (_ :\n                        ∀ (x : α),\n                          C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) = p.color) })\n                s.lines,\n          focus := Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none),\n          is_focused :=\n            (_ :\n              ∀ (p : AlmostMono C),\n                p ∈\n                    { line := vertical s.focus (map some l'), color := C' s.focus,\n                        has_color :=\n                          (_ :\n                            ∀ (x : α),\n                              C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                                C' s.focus) } ::ₘ\n                      Multiset.map\n                        (fun p =>\n                          { line := prod p.line (map some l'), color := p.color,\n                            has_color :=\n                              (_ :\n                                ∀ (x : α),\n                                  C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                    p.color) })\n                        s.lines →\n                  (fun x i => Option.getD (idxFun p.line i) x) none =\n                    Sum.elim s.focus ((fun x i => Option.getD (idxFun (map some l') i) x) none)),\n          distinct_colors :=\n            (_ :\n              Multiset.Nodup\n                (Multiset.map AlmostMono.color\n                  ({ line := vertical s.focus (map some l'), color := C' s.focus,\n                      has_color :=\n                        (_ :\n                          ∀ (x : α),\n                            C ((fun x i => Option.getD (idxFun (vertical s.focus (map some l')) i) x) (some x)) =\n                              C' s.focus) } ::ₘ\n                    Multiset.map\n                      (fun p =>\n                        { line := prod p.line (map some l'), color := p.color,\n                          has_color :=\n                            (_ :\n                              ∀ (x : α),\n                                C ((fun x i => Option.getD (idxFun (prod p.line (map some l')) i) x) (some x)) =\n                                  p.color) })\n                      s.lines))) }.lines =\n    Nat.succ r"],"goalsAfter":[],"content":"· rw [Multiset.card_cons, Multiset.card_map, sr]"},{"tailPos":16315,"headPos":11415,"goalsBefore":["⊢ ∀ {α : Type u} [inst : Fintype α],\n    (∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l) →\n      ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"intro α _ ihα κ _\n    cases nonempty_fintype κ\n    -- Later we'll need `α` to be nonempty. So we first deal with the trivial case where `α` is\n    -- empty.\n    -- Then `Option α` has only one element, so any line is monochromatic.\n    by_cases h : Nonempty α\n    on_goal 2 =>\n      refine' ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩\n      rintro (_ | ⟨a⟩)\n      · rfl\n      · exact (h ⟨a⟩).elim\n    -- The key idea is to show that for every `r`, in high dimension we can either find\n    -- `r` color focused lines or a monochromatic line.\n    suffices key :\n      ∀ r : ℕ,\n        ∃ (ι : Type)(_ : Fintype ι),\n          ∀ C : (ι → Option α) → κ,\n            (∃ s : ColorFocused C, Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n    -- Given the key claim, we simply take `r = |κ| + 1`. We cannot have this many distinct colors\n    -- so we must be in the second case, where there is a monochromatic line.\n    · obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)\n      refine' ⟨ι, _inst, fun C => (hι C).resolve_left _⟩\n      rintro ⟨s, sr⟩\n      apply Nat.not_succ_le_self (Fintype.card κ)\n      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]\n      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩\n    -- We now prove the key claim, by induction on `r`.\n    intro r\n    induction' r with r ihr\n    -- The base case `r = 0` is trivial as the empty collection is color-focused.\n    · exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩\n    -- Supposing the key claim holds for `r`, we need to show it for `r+1`. First pick a high\n    -- enough dimension `ι` for `r`.\n    obtain ⟨ι, _inst, hι⟩ := ihr\n    -- Then since the theorem holds for `α` with any number of colors, pick a dimension `ι'` such\n    -- that `ι' → α` always has a monochromatic line whenever it is `(ι → Option α) → κ`-colored.\n    specialize ihα ((ι → Option α) → κ)\n    obtain ⟨ι', _inst, hι'⟩ := ihα\n    -- We claim that `ι ⊕ ι'` works for `Option α` and `κ`-coloring.\n    refine' ⟨Sum ι ι', inferInstance, _⟩\n    intro C\n    -- A `κ`-coloring of `ι ⊕ ι' → Option α` induces an `(ι → Option α) → κ`-coloring of `ι' → α`.\n    specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))\n    -- By choice of `ι'` this coloring has a monochromatic line `l'` with color class `C'`, where\n    -- `C'` is a `κ`-coloring of `ι → α`.\n    obtain ⟨l', C', hl'⟩ := hι'\n    -- If `C'` has a monochromatic line, then so does `C`. We use this in two places below.\n    have mono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l := by\n      rintro ⟨l, c, hl⟩\n      refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩\n      rw [Line.horizontal_apply, ← hl, ← hl']\n    -- By choice of `ι`, `C'` either has `r` color-focused lines or a monochromatic line.\n    specialize hι C'\n    rcases hι with (⟨s, sr⟩ | h)\n    on_goal 2 => exact Or.inr (mono_of_mono h)\n    -- Here we assume `C'` has `r` color focused lines. We split into cases depending on whether\n    -- one of these `r` lines has the same color as the focus point.\n    by_cases h : ∃ p ∈ s.lines, (p : AlmostMono _).color = C' s.focus\n    -- If so then this is a `C'`-monochromatic line and we are done.\n    · obtain ⟨p, p_mem, hp⟩ := h\n      refine' Or.inr (mono_of_mono ⟨p.line, p.color, _⟩)\n      rintro (_ | _)\n      rw [hp, s.is_focused p p_mem]\n      apply p.has_color\n    -- If not, we get `r+1` color focused lines by taking the product of the `r` lines with `l'`\n    -- and adding to this the vertical line obtained by the focus point and `l`.\n    refine' Or.inl ⟨⟨(s.lines.map _).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => _⟩,\n            Sum.elim s.focus (l'.map some none), _, _⟩, _⟩\n    -- Porting note: Needed to reorder the following two goals\n    -- The product lines are almost monochromatic.\n    · refine' fun p => ⟨p.line.prod (l'.map some), p.color, fun x => _⟩\n      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]\n    -- The vertical line is almost monochromatic.\n    · rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]\n    -- Our `r+1` lines have the same endpoint.\n    · simp_rw [Multiset.mem_cons, Multiset.mem_map]\n      rintro _ (rfl | ⟨q, hq, rfl⟩)\n      · simp only [vertical_apply]\n      · simp only [prod_apply, s.is_focused q hq]\n    -- Our `r+1` lines have distinct colors (this is why we needed to split into cases above).\n    · rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]\n      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩\n    -- Finally, we really do have `r+1` lines!\n    · rw [Multiset.card_cons, Multiset.card_map, sr]"},{"tailPos":11322,"headPos":11320,"goalsBefore":["⊢ ∀ {α : Type u} [inst : Fintype α],\n    (∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l) →\n      ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"by"},{"tailPos":16315,"headPos":11320,"goalsBefore":["⊢ ∀ {α : Type u} [inst : Fintype α],\n    (∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → α) → κ), ∃ l, IsMono C l) →\n      ∀ (κ : Type (max v u)) [inst : Finite κ], ∃ ι x, ∀ (C : (ι → Option α) → κ), ∃ l, IsMono C l"],"goalsAfter":[],"content":"by\n    -- Now we have to show that the theorem holds for `Option α` if it holds for `α`.\n    intro α _ ihα κ _\n    cases nonempty_fintype κ\n    -- Later we'll need `α` to be nonempty. So we first deal with the trivial case where `α` is\n    -- empty.\n    -- Then `Option α` has only one element, so any line is monochromatic.\n    by_cases h : Nonempty α\n    on_goal 2 =>\n      refine' ⟨Unit, inferInstance, fun C => ⟨diagonal _ Unit, C fun _ => none, ?_⟩⟩\n      rintro (_ | ⟨a⟩)\n      · rfl\n      · exact (h ⟨a⟩).elim\n    -- The key idea is to show that for every `r`, in high dimension we can either find\n    -- `r` color focused lines or a monochromatic line.\n    suffices key :\n      ∀ r : ℕ,\n        ∃ (ι : Type)(_ : Fintype ι),\n          ∀ C : (ι → Option α) → κ,\n            (∃ s : ColorFocused C, Multiset.card s.lines = r) ∨ ∃ l, IsMono C l\n    -- Given the key claim, we simply take `r = |κ| + 1`. We cannot have this many distinct colors\n    -- so we must be in the second case, where there is a monochromatic line.\n    · obtain ⟨ι, _inst, hι⟩ := key (Fintype.card κ + 1)\n      refine' ⟨ι, _inst, fun C => (hι C).resolve_left _⟩\n      rintro ⟨s, sr⟩\n      apply Nat.not_succ_le_self (Fintype.card κ)\n      rw [← Nat.add_one, ← sr, ← Multiset.card_map, ← Finset.card_mk]\n      exact Finset.card_le_univ ⟨_, s.distinct_colors⟩\n    -- We now prove the key claim, by induction on `r`.\n    intro r\n    induction' r with r ihr\n    -- The base case `r = 0` is trivial as the empty collection is color-focused.\n    · exact ⟨Empty, inferInstance, fun C => Or.inl ⟨default, Multiset.card_zero⟩⟩\n    -- Supposing the key claim holds for `r`, we need to show it for `r+1`. First pick a high\n    -- enough dimension `ι` for `r`.\n    obtain ⟨ι, _inst, hι⟩ := ihr\n    -- Then since the theorem holds for `α` with any number of colors, pick a dimension `ι'` such\n    -- that `ι' → α` always has a monochromatic line whenever it is `(ι → Option α) → κ`-colored.\n    specialize ihα ((ι → Option α) → κ)\n    obtain ⟨ι', _inst, hι'⟩ := ihα\n    -- We claim that `ι ⊕ ι'` works for `Option α` and `κ`-coloring.\n    refine' ⟨Sum ι ι', inferInstance, _⟩\n    intro C\n    -- A `κ`-coloring of `ι ⊕ ι' → Option α` induces an `(ι → Option α) → κ`-coloring of `ι' → α`.\n    specialize hι' fun v' v => C (Sum.elim v (some ∘ v'))\n    -- By choice of `ι'` this coloring has a monochromatic line `l'` with color class `C'`, where\n    -- `C'` is a `κ`-coloring of `ι → α`.\n    obtain ⟨l', C', hl'⟩ := hι'\n    -- If `C'` has a monochromatic line, then so does `C`. We use this in two places below.\n    have mono_of_mono : (∃ l, IsMono C' l) → ∃ l, IsMono C l := by\n      rintro ⟨l, c, hl⟩\n      refine' ⟨l.horizontal (some ∘ l' (Classical.arbitrary α)), c, fun x => _⟩\n      rw [Line.horizontal_apply, ← hl, ← hl']\n    -- By choice of `ι`, `C'` either has `r` color-focused lines or a monochromatic line.\n    specialize hι C'\n    rcases hι with (⟨s, sr⟩ | h)\n    on_goal 2 => exact Or.inr (mono_of_mono h)\n    -- Here we assume `C'` has `r` color focused lines. We split into cases depending on whether\n    -- one of these `r` lines has the same color as the focus point.\n    by_cases h : ∃ p ∈ s.lines, (p : AlmostMono _).color = C' s.focus\n    -- If so then this is a `C'`-monochromatic line and we are done.\n    · obtain ⟨p, p_mem, hp⟩ := h\n      refine' Or.inr (mono_of_mono ⟨p.line, p.color, _⟩)\n      rintro (_ | _)\n      rw [hp, s.is_focused p p_mem]\n      apply p.has_color\n    -- If not, we get `r+1` color focused lines by taking the product of the `r` lines with `l'`\n    -- and adding to this the vertical line obtained by the focus point and `l`.\n    refine' Or.inl ⟨⟨(s.lines.map _).cons ⟨(l'.map some).vertical s.focus, C' s.focus, fun x => _⟩,\n            Sum.elim s.focus (l'.map some none), _, _⟩, _⟩\n    -- Porting note: Needed to reorder the following two goals\n    -- The product lines are almost monochromatic.\n    · refine' fun p => ⟨p.line.prod (l'.map some), p.color, fun x => _⟩\n      rw [Line.prod_apply, Line.map_apply, ← p.has_color, ← congr_fun (hl' x)]\n    -- The vertical line is almost monochromatic.\n    · rw [vertical_apply, ← congr_fun (hl' x), Line.map_apply]\n    -- Our `r+1` lines have the same endpoint.\n    · simp_rw [Multiset.mem_cons, Multiset.mem_map]\n      rintro _ (rfl | ⟨q, hq, rfl⟩)\n      · simp only [vertical_apply]\n      · simp only [prod_apply, s.is_focused q hq]\n    -- Our `r+1` lines have distinct colors (this is why we needed to split into cases above).\n    · rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]\n      exact ⟨fun ⟨q, hq, he⟩ => h ⟨q, hq, he⟩, s.distinct_colors⟩\n    -- Finally, we really do have `r+1` lines!\n    · rw [Multiset.card_cons, Multiset.card_map, sr]"},{"tailPos":17027,"headPos":17018,"goalsBefore":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = c.down"],"goalsAfter":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = ((ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x)).down"],"content":"← hc x,"},{"tailPos":17047,"headPos":17028,"goalsBefore":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = ((ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x)).down"],"goalsAfter":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = { down := C ((fun x i => Option.getD (idxFun l i) x) x) }.down"],"content":"Function.comp_apply"},{"tailPos":17048,"headPos":17047,"goalsBefore":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = { down := C ((fun x i => Option.getD (idxFun l i) x) x) }.down"],"goalsAfter":[],"content":"]"},{"tailPos":17048,"headPos":17014,"goalsBefore":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = c.down"],"goalsAfter":[],"content":"rw [← hc x, Function.comp_apply]"},{"tailPos":17013,"headPos":17011,"goalsBefore":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = c.down"],"goalsAfter":[],"content":"by"},{"tailPos":17048,"headPos":17011,"goalsBefore":["α : Type u\ninst✝¹ : Finite α\nκ : Type v\ninst✝ : Finite κ\nι : Type\nιfin : Fintype ι\nhι : ∀ (C : (ι → α) → ULift κ), ∃ l, IsMono C l\nC : (ι → α) → κ\nl : Line α ι\nc : ULift κ\nhc : ∀ (x : α), (ULift.up ∘ C) ((fun x i => Option.getD (idxFun l i) x) x) = c\nx : α\n⊢ C ((fun x i => Option.getD (idxFun l i) x) x) = c.down"],"goalsAfter":[],"content":"by rw [← hc x, Function.comp_apply]"},{"tailPos":17621,"headPos":17551,"goalsBefore":["M : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":["case intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → { x // x ∈ S }) → κ), ∃ l, Line.IsMono C l\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"content":"obtain ⟨ι, _inst, hι⟩ := Line.exists_mono_in_high_dimension S κ"},{"tailPos":17628,"headPos":17624,"goalsBefore":["case intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → { x // x ∈ S }) → κ), ∃ l, Line.IsMono C l\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":["case intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → { x // x ∈ S }) → κ), ∃ l, Line.IsMono C l\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"content":"skip"},{"tailPos":17670,"headPos":17631,"goalsBefore":["case intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nhι : ∀ (C : (ι → { x // x ∈ S }) → κ), ∃ l, Line.IsMono C l\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":["case intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nhι : ∃ l, Line.IsMono (fun v => C (∑ i : ι, ↑(v i))) l\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"content":"specialize hι fun v => C <| ∑ i, v i"},{"tailPos":17701,"headPos":17673,"goalsBefore":["case intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nhι : ∃ l, Line.IsMono (fun v => C (∑ i : ι, ↑(v i))) l\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":["case intro.intro.intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"content":"obtain ⟨l, c, hl⟩ := hι"},{"tailPos":17782,"headPos":17704,"goalsBefore":["case intro.intro.intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":["case intro.intro.intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"content":"set s : Finset ι :=  Finset.univ.filter (fun i => l.idxFun i = none ) with hs"},{"tailPos":17911,"headPos":17785,"goalsBefore":["case intro.intro.intro.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s","case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M","case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (?m.28895 i) (Line.idxFun l i)) 0) = c"],"content":"refine'\n    ⟨s.card, Finset.card_pos.mpr ⟨l.proper.choose, _⟩, ∑ i in sᶜ, ((l.idxFun i).map _).getD 0,\n      c, _⟩"},{"tailPos":17916,"headPos":17914,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s","case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M","case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (?m.28895 i) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s"],"content":"·"},{"tailPos":17924,"headPos":17921,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.filter (fun i => Line.idxFun l i = none) Finset.univ"],"content":"hs,"},{"tailPos":17942,"headPos":17925,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.filter (fun i => Line.idxFun l i = none) Finset.univ"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.univ ∧\n    Line.idxFun l (Exists.choose (_ : ∃ i, Line.idxFun l i = none)) = none"],"content":"Finset.mem_filter"},{"tailPos":17943,"headPos":17942,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.univ ∧\n    Line.idxFun l (Exists.choose (_ : ∃ i, Line.idxFun l i = none)) = none"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.univ ∧\n    Line.idxFun l (Exists.choose (_ : ∃ i, Line.idxFun l i = none)) = none"],"content":"]"},{"tailPos":17943,"headPos":17917,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.univ ∧\n    Line.idxFun l (Exists.choose (_ : ∃ i, Line.idxFun l i = none)) = none"],"content":"rw [hs, Finset.mem_filter]"},{"tailPos":17999,"headPos":17948,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ Finset.univ ∧\n    Line.idxFun l (Exists.choose (_ : ∃ i, Line.idxFun l i = none)) = none"],"goalsAfter":[],"content":"exact ⟨Finset.mem_univ _, l.proper.choose_spec⟩"},{"tailPos":17999,"headPos":17917,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s"],"goalsAfter":[],"content":"rw [hs, Finset.mem_filter]\n    exact ⟨Finset.mem_univ _, l.proper.choose_spec⟩"},{"tailPos":17999,"headPos":17914,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ Exists.choose (_ : ∃ i, Line.idxFun l i = none) ∈ s","case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M","case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (?m.28895 i) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M","case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (?m.28895 i) (Line.idxFun l i)) 0) = c"],"content":"· rw [hs, Finset.mem_filter]\n    exact ⟨Finset.mem_univ _, l.proper.choose_spec⟩"},{"tailPos":18004,"headPos":18002,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M","case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (?m.28895 i) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M"],"content":"·"},{"tailPos":18021,"headPos":18005,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M"],"goalsAfter":[],"content":"exact fun m => m"},{"tailPos":18021,"headPos":18002,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\ni : ι\n⊢ { x // x ∈ S } → M","case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (?m.28895 i) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) = c"],"content":"· exact fun m => m"},{"tailPos":18034,"headPos":18024,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ ∀ (s_1 : M),\n    s_1 ∈ S → C (Finset.card s • s_1 + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) = c"],"content":"intro x xs"},{"tailPos":18059,"headPos":18041,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"content":"← hl ⟨x, xs⟩"},{"tailPos":18060,"headPos":18059,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"content":"]"},{"tailPos":18060,"headPos":18037,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) = c"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"content":"rw [← hl ⟨x, xs⟩]"},{"tailPos":18071,"headPos":18063,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\nhl : ∀ (x : { x // x ∈ S }), (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) x) = c\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"content":"clear hl"},{"tailPos":18072,"headPos":18071,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"content":";"},{"tailPos":18078,"headPos":18073,"goalsBefore":["case intro.intro.intro.intro.refine'_3\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ C (Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0) =\n    (fun v => C (∑ i : ι, ↑(v i))) ((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i : ι, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"congr"},{"tailPos":18115,"headPos":18085,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i : ι, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i) +\n      ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"← Finset.sum_add_sum_compl s"},{"tailPos":18116,"headPos":18115,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i) +\n      ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i) +\n      ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"]"},{"tailPos":18116,"headPos":18081,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i : ι, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i) +\n      ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"rw [← Finset.sum_add_sum_compl s]"},{"tailPos":18126,"headPos":18119,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x + ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i) +\n      ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)","case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"congr 1"},{"tailPos":18131,"headPos":18129,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)","case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"·"},{"tailPos":18156,"headPos":18136,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ _x in s, x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"← Finset.sum_const"},{"tailPos":18157,"headPos":18156,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ _x in s, x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ _x in s, x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"]"},{"tailPos":18157,"headPos":18132,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ _x in s, x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"rw [← Finset.sum_const]"},{"tailPos":18188,"headPos":18162,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ _x in s, x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∀ (x_1 : ι), x_1 ∈ s → x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } x_1)"],"content":"apply Finset.sum_congr rfl"},{"tailPos":18203,"headPos":18193,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∀ (x_1 : ι), x_1 ∈ s → x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } x_1)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ s\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"intro i hi"},{"tailPos":18215,"headPos":18212,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ s\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"hs,"},{"tailPos":18233,"headPos":18216,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"Finset.mem_filter"},{"tailPos":18234,"headPos":18233,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"]"},{"tailPos":18240,"headPos":18208,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ s\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"rw [hs, Finset.mem_filter] at hi"},{"tailPos":18275,"headPos":18249,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑{ val := x, property := xs }"],"content":"l.apply_none _ _ hi.right,"},{"tailPos":18290,"headPos":18276,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑{ val := x, property := xs }"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = x"],"content":"Subtype.coe_mk"},{"tailPos":18291,"headPos":18290,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = x"],"goalsAfter":[],"content":"]"},{"tailPos":18291,"headPos":18245,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ Line.idxFun l i = none\n⊢ x = ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":[],"content":"rw [l.apply_none _ _ hi.right, Subtype.coe_mk]"},{"tailPos":18291,"headPos":18132,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":[],"content":"rw [← Finset.sum_const]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.mem_filter] at hi\n    rw [l.apply_none _ _ hi.right, Subtype.coe_mk]"},{"tailPos":18291,"headPos":18129,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ Finset.card s • x = ∑ i in s, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)","case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"· rw [← Finset.sum_const]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.mem_filter] at hi\n    rw [l.apply_none _ _ hi.right, Subtype.coe_mk]"},{"tailPos":18296,"headPos":18294,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"·"},{"tailPos":18323,"headPos":18297,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∀ (x_1 : ι),\n    x_1 ∈ sᶜ →\n      Option.getD (Option.map (fun m => ↑m) (Line.idxFun l x_1)) 0 =\n        ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } x_1)"],"content":"apply Finset.sum_congr rfl"},{"tailPos":18338,"headPos":18328,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∀ (x_1 : ι),\n    x_1 ∈ sᶜ →\n      Option.getD (Option.map (fun m => ↑m) (Line.idxFun l x_1)) 0 =\n        ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } x_1)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ sᶜ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"intro i hi"},{"tailPos":18350,"headPos":18347,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ sᶜ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.filter (fun i => Line.idxFun l i = none) Finset.univᶜ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"hs,"},{"tailPos":18371,"headPos":18351,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.filter (fun i => Line.idxFun l i = none) Finset.univᶜ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.filter (fun x => ¬Line.idxFun l x = none) Finset.univ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"Finset.compl_filter,"},{"tailPos":18389,"headPos":18372,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.filter (fun x => ¬Line.idxFun l x = none) Finset.univ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"Finset.mem_filter"},{"tailPos":18390,"headPos":18389,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"]"},{"tailPos":18396,"headPos":18343,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ sᶜ\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"rw [hs, Finset.compl_filter, Finset.mem_filter] at hi"},{"tailPos":18460,"headPos":18401,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"content":"obtain ⟨y, hy⟩ := Option.ne_none_iff_exists.mp hi.right"},{"tailPos":18474,"headPos":18465,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑(Option.getD (Line.idxFun l i) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑(Option.getD (Line.idxFun l i) { val := x, property := xs })"],"content":"simp_rw ["},{"tailPos":18481,"headPos":18474,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑(Option.getD (Line.idxFun l i) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (some y)) 0 = ↑(Option.getD (some y) { val := x, property := xs })"],"content":"← hy,"},{"tailPos":18499,"headPos":18482,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (some y)) 0 = ↑(Option.getD (some y) { val := x, property := xs })"],"goalsAfter":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (some ↑y) 0 = ↑(Option.getD (some y) { val := x, property := xs })"],"content":"Option.map_some',"},{"tailPos":18511,"headPos":18500,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (some ↑y) 0 = ↑(Option.getD (some y) { val := x, property := xs })"],"goalsAfter":[],"content":"simp only [Option.getD]"},{"tailPos":18512,"headPos":18465,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a.intro\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\ni : ι\nhi : i ∈ Finset.univ ∧ ¬Line.idxFun l i = none\ny : { x // x ∈ S }\nhy : some y = Line.idxFun l i\n⊢ Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":[],"content":"simp_rw [← hy, Option.map_some', Option.getD]"},{"tailPos":18512,"headPos":18297,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":[],"content":"apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.compl_filter, Finset.mem_filter] at hi\n    obtain ⟨y, hy⟩ := Option.ne_none_iff_exists.mp hi.right\n    simp_rw [← hy, Option.map_some', Option.getD]"},{"tailPos":18512,"headPos":18294,"goalsBefore":["case intro.intro.intro.intro.refine'_3.e_a.e_a\nM : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\nι : Type\n_inst : Fintype ι\nl : Line { x // x ∈ S } ι\nc : κ\ns : Finset ι := Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nhs : s = Finset.filter (fun i => Line.idxFun l i = none) Finset.univ\nx : M\nxs : x ∈ S\n⊢ ∑ i in sᶜ, Option.getD (Option.map (fun m => ↑m) (Line.idxFun l i)) 0 =\n    ∑ i in sᶜ, ↑((fun x i => Option.getD (Line.idxFun l i) x) { val := x, property := xs } i)"],"goalsAfter":[],"content":"· apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.compl_filter, Finset.mem_filter] at hi\n    obtain ⟨y, hy⟩ := Option.ne_none_iff_exists.mp hi.right\n    simp_rw [← hy, Option.map_some', Option.getD]"},{"tailPos":18512,"headPos":17551,"goalsBefore":["M : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":[],"content":"obtain ⟨ι, _inst, hι⟩ := Line.exists_mono_in_high_dimension S κ\n  skip\n  specialize hι fun v => C <| ∑ i, v i\n  obtain ⟨l, c, hl⟩ := hι\n  set s : Finset ι :=  Finset.univ.filter (fun i => l.idxFun i = none ) with hs\n  refine'\n    ⟨s.card, Finset.card_pos.mpr ⟨l.proper.choose, _⟩, ∑ i in sᶜ, ((l.idxFun i).map _).getD 0,\n      c, _⟩\n  · rw [hs, Finset.mem_filter]\n    exact ⟨Finset.mem_univ _, l.proper.choose_spec⟩\n  · exact fun m => m\n  intro x xs\n  rw [← hl ⟨x, xs⟩]\n  clear hl; congr\n  rw [← Finset.sum_add_sum_compl s]\n  congr 1\n  · rw [← Finset.sum_const]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.mem_filter] at hi\n    rw [l.apply_none _ _ hi.right, Subtype.coe_mk]\n  · apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.compl_filter, Finset.mem_filter] at hi\n    obtain ⟨y, hy⟩ := Option.ne_none_iff_exists.mp hi.right\n    simp_rw [← hy, Option.map_some', Option.getD]"},{"tailPos":17548,"headPos":17546,"goalsBefore":["M : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":[],"content":"by"},{"tailPos":18512,"headPos":17546,"goalsBefore":["M : Type u_1\nκ : Type u_2\ninst✝¹ : AddCommMonoid M\nS : Finset M\ninst✝ : Finite κ\nC : M → κ\n⊢ ∃ a, a > 0 ∧ ∃ b c, ∀ (s : M), s ∈ S → C (a • s + b) = c"],"goalsAfter":[],"content":"by\n  obtain ⟨ι, _inst, hι⟩ := Line.exists_mono_in_high_dimension S κ\n  skip\n  specialize hι fun v => C <| ∑ i, v i\n  obtain ⟨l, c, hl⟩ := hι\n  set s : Finset ι :=  Finset.univ.filter (fun i => l.idxFun i = none ) with hs\n  refine'\n    ⟨s.card, Finset.card_pos.mpr ⟨l.proper.choose, _⟩, ∑ i in sᶜ, ((l.idxFun i).map _).getD 0,\n      c, _⟩\n  · rw [hs, Finset.mem_filter]\n    exact ⟨Finset.mem_univ _, l.proper.choose_spec⟩\n  · exact fun m => m\n  intro x xs\n  rw [← hl ⟨x, xs⟩]\n  clear hl; congr\n  rw [← Finset.sum_add_sum_compl s]\n  congr 1\n  · rw [← Finset.sum_const]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.mem_filter] at hi\n    rw [l.apply_none _ _ hi.right, Subtype.coe_mk]\n  · apply Finset.sum_congr rfl\n    intro i hi\n    rw [hs, Finset.compl_filter, Finset.mem_filter] at hi\n    obtain ⟨y, hy⟩ := Option.ne_none_iff_exists.mp hi.right\n    simp_rw [← hy, Option.map_some', Option.getD]"}]
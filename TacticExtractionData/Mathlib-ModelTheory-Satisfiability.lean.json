[{"tailPos":4439,"headPos":4370,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\n⊢ IsSatisfiable (LHom.onTheory φ T) ↔ IsSatisfiable T"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\nh' : IsSatisfiable T\n⊢ IsSatisfiable (LHom.onTheory φ T)"],"content":"refine' ⟨isSatisfiable_of_isSatisfiable_onTheory φ, fun h' => _⟩"},{"tailPos":4505,"headPos":4444,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\nh' : IsSatisfiable T\n⊢ IsSatisfiable (LHom.onTheory φ T)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\nh' : IsSatisfiable T\nthis : Inhabited ↑(Nonempty.some h')\n⊢ IsSatisfiable (LHom.onTheory φ T)"],"content":"haveI : Inhabited h'.some := Classical.inhabited_of_nonempty'"},{"tailPos":4564,"headPos":4510,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\nh' : IsSatisfiable T\nthis : Inhabited ↑(Nonempty.some h')\n⊢ IsSatisfiable (LHom.onTheory φ T)"],"goalsAfter":[],"content":"exact Model.isSatisfiable (h'.some.defaultExpansion h)"},{"tailPos":4564,"headPos":4370,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\n⊢ IsSatisfiable (LHom.onTheory φ T) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"refine' ⟨isSatisfiable_of_isSatisfiable_onTheory φ, fun h' => _⟩\n    haveI : Inhabited h'.some := Classical.inhabited_of_nonempty'\n    exact Model.isSatisfiable (h'.some.defaultExpansion h)"},{"tailPos":4564,"headPos":4356,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\n⊢ IsSatisfiable (LHom.onTheory φ T) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"classical\n    refine' ⟨isSatisfiable_of_isSatisfiable_onTheory φ, fun h' => _⟩\n    haveI : Inhabited h'.some := Classical.inhabited_of_nonempty'\n    exact Model.isSatisfiable (h'.some.defaultExpansion h)"},{"tailPos":4353,"headPos":4351,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\n⊢ IsSatisfiable (LHom.onTheory φ T) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"by"},{"tailPos":4564,"headPos":4351,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nL' : Language\nφ : L →ᴸ L'\nh : LHom.Injective φ\n⊢ IsSatisfiable (LHom.onTheory φ T) ↔ IsSatisfiable T"],"goalsAfter":[],"content":"by\n  classical\n    refine' ⟨isSatisfiable_of_isSatisfiable_onTheory φ, fun h' => _⟩\n    haveI : Inhabited h'.some := Classical.inhabited_of_nonempty'\n    exact Model.isSatisfiable (h'.some.defaultExpansion h)"},{"tailPos":5411,"headPos":5252,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\n⊢ IsSatisfiable T"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\n⊢ IsSatisfiable T"],"content":"set M : Finset T → Type max u v := fun T0 : Finset T =>\n        (h (T0.map (Function.Embedding.subtype fun x => x ∈ T)) T0.map_subtype_subset).some.Carrier"},{"tailPos":5496,"headPos":5418,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\n⊢ IsSatisfiable T"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\n⊢ IsSatisfiable T"],"content":"let M' := Filter.Product (Ultrafilter.of (Filter.atTop : Filter (Finset T))) M"},{"tailPos":5565,"headPos":5536,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\n⊢ M' ⊨ T"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ M' ⊨ φ"],"content":"refine' ⟨fun φ hφ => _⟩"},{"tailPos":5607,"headPos":5578,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ M' ⊨ φ"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ ∀ᶠ (a : Finset ↑T) in ↑(Ultrafilter.of Filter.atTop), M a ⊨ φ"],"content":"Ultraproduct.sentence_realize"},{"tailPos":5608,"headPos":5607,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ ∀ᶠ (a : Finset ↑T) in ↑(Ultrafilter.of Filter.atTop), M a ⊨ φ"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ ∀ᶠ (a : Finset ↑T) in ↑(Ultrafilter.of Filter.atTop), M a ⊨ φ"],"content":"]"},{"tailPos":5608,"headPos":5574,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ M' ⊨ φ"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ ∀ᶠ (a : Finset ↑T) in ↑(Ultrafilter.of Filter.atTop), M a ⊨ φ"],"content":"rw [Ultraproduct.sentence_realize]"},{"tailPos":5896,"headPos":5617,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\n⊢ ∀ᶠ (a : Finset ↑T) in ↑(Ultrafilter.of Filter.atTop), M a ⊨ φ"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\ns : Finset ↑T\nh' : s ≥ {{ val := φ, property := hφ }}\n⊢ φ ∈ ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) s)"],"content":"refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)"},{"tailPos":6071,"headPos":5905,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\ns : Finset ↑T\nh' : s ≥ {{ val := φ, property := hφ }}\n⊢ φ ∈ ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\ns : Finset ↑T\nh' : s ≥ {{ val := φ, property := hφ }}\n⊢ ∃ x, { val := φ, property := (_ : φ ∈ T) } ∈ s"],"content":"simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]"},{"tailPos":6129,"headPos":6080,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nφ : Sentence L\nhφ : φ ∈ T\ns : Finset ↑T\nh' : s ≥ {{ val := φ, property := hφ }}\n⊢ ∃ x, { val := φ, property := (_ : φ ∈ T) } ∈ s"],"goalsAfter":[],"content":"exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩"},{"tailPos":6129,"headPos":5536,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\n⊢ M' ⊨ T"],"goalsAfter":[],"content":"refine' ⟨fun φ hφ => _⟩\n        rw [Ultraproduct.sentence_realize]\n        refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩"},{"tailPos":5527,"headPos":5525,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\n⊢ M' ⊨ T"],"goalsAfter":[],"content":"by"},{"tailPos":6129,"headPos":5525,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\n⊢ M' ⊨ T"],"goalsAfter":[],"content":"by\n        refine' ⟨fun φ hφ => _⟩\n        rw [Ultraproduct.sentence_realize]\n        refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩"},{"tailPos":6129,"headPos":5503,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\n⊢ IsSatisfiable T"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nh' : M' ⊨ T\n⊢ IsSatisfiable T"],"content":"have h' : M' ⊨ T := by\n        refine' ⟨fun φ hφ => _⟩\n        rw [Ultraproduct.sentence_realize]\n        refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩"},{"tailPos":6165,"headPos":6136,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\nM : Finset ↑T → Type (max u v) :=\n  fun T0 => ↑(Nonempty.some (_ : IsSatisfiable ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ T) T0)))\nM' : Type (max u v) := Filter.Product (↑(Ultrafilter.of Filter.atTop)) M\nh' : M' ⊨ T\n⊢ IsSatisfiable T"],"goalsAfter":[],"content":"exact ⟨ModelType.of T M'⟩"},{"tailPos":6165,"headPos":5252,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\n⊢ IsSatisfiable T"],"goalsAfter":[],"content":"set M : Finset T → Type max u v := fun T0 : Finset T =>\n        (h (T0.map (Function.Embedding.subtype fun x => x ∈ T)) T0.map_subtype_subset).some.Carrier\n      let M' := Filter.Product (Ultrafilter.of (Filter.atTop : Filter (Finset T))) M\n      have h' : M' ⊨ T := by\n        refine' ⟨fun φ hφ => _⟩\n        rw [Ultraproduct.sentence_realize]\n        refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩\n      exact ⟨ModelType.of T M'⟩"},{"tailPos":6165,"headPos":5236,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\n⊢ IsSatisfiable T"],"goalsAfter":[],"content":"classical\n      set M : Finset T → Type max u v := fun T0 : Finset T =>\n        (h (T0.map (Function.Embedding.subtype fun x => x ∈ T)) T0.map_subtype_subset).some.Carrier\n      let M' := Filter.Product (Ultrafilter.of (Filter.atTop : Filter (Finset T))) M\n      have h' : M' ⊨ T := by\n        refine' ⟨fun φ hφ => _⟩\n        rw [Ultraproduct.sentence_realize]\n        refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩\n      exact ⟨ModelType.of T M'⟩"},{"tailPos":5231,"headPos":5229,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\n⊢ IsSatisfiable T"],"goalsAfter":[],"content":"by"},{"tailPos":6165,"headPos":5229,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nh : IsFinitelySatisfiable T\n⊢ IsSatisfiable T"],"goalsAfter":[],"content":"by\n    classical\n      set M : Finset T → Type max u v := fun T0 : Finset T =>\n        (h (T0.map (Function.Embedding.subtype fun x => x ∈ T)) T0.map_subtype_subset).some.Carrier\n      let M' := Filter.Product (Ultrafilter.of (Filter.atTop : Filter (Finset T))) M\n      have h' : M' ⊨ T := by\n        refine' ⟨fun φ hφ => _⟩\n        rw [Ultraproduct.sentence_realize]\n        refine'\n          Filter.Eventually.filter_mono (Ultrafilter.of_le _)\n            (Filter.eventually_atTop.2\n              ⟨{⟨φ, hφ⟩}, fun s h' =>\n                Theory.realize_sentence_of_mem (s.map (Function.Embedding.subtype fun x => x ∈ T))\n                  _⟩)\n        simp only [Finset.coe_map, Function.Embedding.coe_subtype, Set.mem_image, Finset.mem_coe,\n          Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n        exact ⟨hφ, h' (Finset.mem_singleton_self _)⟩\n      exact ⟨ModelType.of T M'⟩"},{"tailPos":6584,"headPos":6514,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (i : ι), IsSatisfiable (T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ IsSatisfiable (⋃ (i : ι), T i)"],"content":"refine' ⟨fun h' i => h'.mono (Set.subset_iUnion _ _), fun h' => _⟩"},{"tailPos":6631,"headPos":6591,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ IsSatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"content":"isSatisfiable_iff_isFinitelySatisfiable,"},{"tailPos":6653,"headPos":6632,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ ∀ (T0 : Finset (Sentence L)), (↑T0 ⊆ ⋃ (i : ι), T i) → IsSatisfiable ↑T0"],"content":"IsFinitelySatisfiable"},{"tailPos":6654,"headPos":6653,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ ∀ (T0 : Finset (Sentence L)), (↑T0 ⊆ ⋃ (i : ι), T i) → IsSatisfiable ↑T0"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ ∀ (T0 : Finset (Sentence L)), (↑T0 ⊆ ⋃ (i : ι), T i) → IsSatisfiable ↑T0"],"content":"]"},{"tailPos":6654,"headPos":6587,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ IsSatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ ∀ (T0 : Finset (Sentence L)), (↑T0 ⊆ ⋃ (i : ι), T i) → IsSatisfiable ↑T0"],"content":"rw [isSatisfiable_iff_isFinitelySatisfiable, IsFinitelySatisfiable]"},{"tailPos":6669,"headPos":6657,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\n⊢ ∀ (T0 : Finset (Sentence L)), (↑T0 ⊆ ⋃ (i : ι), T i) → IsSatisfiable ↑T0"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\nT0 : Finset (Sentence L)\nhT0 : ↑T0 ⊆ ⋃ (i : ι), T i\n⊢ IsSatisfiable ↑T0"],"content":"intro T0 hT0"},{"tailPos":6742,"headPos":6672,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\nT0 : Finset (Sentence L)\nhT0 : ↑T0 ⊆ ⋃ (i : ι), T i\n⊢ IsSatisfiable ↑T0"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\nT0 : Finset (Sentence L)\nhT0 : ↑T0 ⊆ ⋃ (i : ι), T i\ni : ι\nhi : ↑T0 ⊆ T i\n⊢ IsSatisfiable ↑T0"],"content":"obtain ⟨i, hi⟩ := h.exists_mem_subset_of_finset_subset_biUnion hT0"},{"tailPos":6765,"headPos":6745,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\nh' : ∀ (i : ι), IsSatisfiable (T i)\nT0 : Finset (Sentence L)\nhT0 : ↑T0 ⊆ ⋃ (i : ι), T i\ni : ι\nhi : ↑T0 ⊆ T i\n⊢ IsSatisfiable ↑T0"],"goalsAfter":[],"content":"exact (h' i).mono hi"},{"tailPos":6765,"headPos":6514,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (i : ι), IsSatisfiable (T i)"],"goalsAfter":[],"content":"refine' ⟨fun h' i => h'.mono (Set.subset_iUnion _ _), fun h' => _⟩\n  rw [isSatisfiable_iff_isFinitelySatisfiable, IsFinitelySatisfiable]\n  intro T0 hT0\n  obtain ⟨i, hi⟩ := h.exists_mem_subset_of_finset_subset_biUnion hT0\n  exact (h' i).mono hi"},{"tailPos":6511,"headPos":6509,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (i : ι), IsSatisfiable (T i)"],"goalsAfter":[],"content":"by"},{"tailPos":6765,"headPos":6509,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\ninst✝ : Nonempty ι\nT : ι → Theory L\nh : Directed (fun x x_1 => x ⊆ x_1) T\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (i : ι), IsSatisfiable (T i)"],"goalsAfter":[],"content":"by\n  refine' ⟨fun h' i => h'.mono (Set.subset_iUnion _ _), fun h' => _⟩\n  rw [isSatisfiable_iff_isFinitelySatisfiable, IsFinitelySatisfiable]\n  intro T0 hT0\n  obtain ⟨i, hi⟩ := h.exists_mem_subset_of_finset_subset_biUnion hT0\n  exact (h' i).mono hi"},{"tailPos":7271,"headPos":7203,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"content":"haveI : Inhabited M := Classical.inhabited_of_nonempty inferInstance"},{"tailPos":7298,"headPos":7278,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"content":"Cardinal.lift_mk_le'"},{"tailPos":7299,"headPos":7298,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"content":"]"},{"tailPos":7304,"headPos":7274,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"content":"rw [Cardinal.lift_mk_le'] at h"},{"tailPos":7406,"headPos":7307,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis : Inhabited M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"content":"letI : (constantsOn α).Structure M := constantsOn.structure (Function.extend (↑) h.some default)"},{"tailPos":7559,"headPos":7500,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ distinctConstantsTheory L s"],"content":"refine' ((LHom.onTheory_model _ _).2 inferInstance).union _"},{"tailPos":7597,"headPos":7568,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ distinctConstantsTheory L s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ Set.InjOn (fun i => ↑(Language.con L i)) s"],"content":"model_distinctConstantsTheory"},{"tailPos":7598,"headPos":7597,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ Set.InjOn (fun i => ↑(Language.con L i)) s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ Set.InjOn (fun i => ↑(Language.con L i)) s"],"content":"]"},{"tailPos":7598,"headPos":7564,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ distinctConstantsTheory L s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ Set.InjOn (fun i => ↑(Language.con L i)) s"],"content":"rw [model_distinctConstantsTheory]"},{"tailPos":7632,"headPos":7603,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ Set.InjOn (fun i => ↑(Language.con L i)) s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ a = b"],"content":"refine' fun a as b bs ab => _"},{"tailPos":7665,"headPos":7641,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ a = b"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ ↑{ val := a, property := as } = b"],"content":"← Subtype.coe_mk a as,"},{"tailPos":7690,"headPos":7666,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ ↑{ val := a, property := as } = b"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ ↑{ val := a, property := as } = ↑{ val := b, property := bs }"],"content":"← Subtype.coe_mk b bs,"},{"tailPos":7710,"headPos":7691,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ ↑{ val := a, property := as } = ↑{ val := b, property := bs }"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ { val := a, property := as } = { val := b, property := bs }"],"content":"← Subtype.ext_iff"},{"tailPos":7711,"headPos":7710,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ { val := a, property := as } = { val := b, property := bs }"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ { val := a, property := as } = { val := b, property := bs }"],"content":"]"},{"tailPos":7711,"headPos":7637,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ a = b"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ { val := a, property := as } = { val := b, property := bs }"],"content":"rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]"},{"tailPos":7914,"headPos":7716,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\na : α\nas : a ∈ s\nb : α\nbs : b ∈ s\nab : (fun i => ↑(Language.con L i)) a = (fun i => ↑(Language.con L i)) b\n⊢ { val := a, property := as } = { val := b, property := bs }"],"goalsAfter":[],"content":"exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))"},{"tailPos":7914,"headPos":7500,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s"],"goalsAfter":[],"content":"refine' ((LHom.onTheory_model _ _).2 inferInstance).union _\n    rw [model_distinctConstantsTheory]\n    refine' fun a as b bs ab => _\n    rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]\n    exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))"},{"tailPos":7495,"headPos":7493,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s"],"goalsAfter":[],"content":"by"},{"tailPos":7914,"headPos":7493,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ M ⊨ LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s"],"goalsAfter":[],"content":"by\n    refine' ((LHom.onTheory_model _ _).2 inferInstance).union _\n    rw [model_distinctConstantsTheory]\n    refine' fun a as b bs ab => _\n    rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]\n    exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))"},{"tailPos":7914,"headPos":7409,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝ : Inhabited M\nthis : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝¹ : Inhabited M\nthis✝ : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\nthis : M ⊨ LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"content":"have : M ⊨ (L.lhomWithConstants α).onTheory T ∪ L.distinctConstantsTheory s := by\n    refine' ((LHom.onTheory_model _ _).2 inferInstance).union _\n    rw [model_distinctConstantsTheory]\n    refine' fun a as b bs ab => _\n    rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]\n    exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))"},{"tailPos":7944,"headPos":7917,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : Nonempty (↑s ↪ M)\nthis✝¹ : Inhabited M\nthis✝ : Structure (constantsOn α) M := constantsOn.structure (Function.extend Subtype.val (↑(Nonempty.some h)) default)\nthis : M ⊨ LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"exact Model.isSatisfiable M"},{"tailPos":7944,"headPos":7203,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"haveI : Inhabited M := Classical.inhabited_of_nonempty inferInstance\n  rw [Cardinal.lift_mk_le'] at h\n  letI : (constantsOn α).Structure M := constantsOn.structure (Function.extend (↑) h.some default)\n  have : M ⊨ (L.lhomWithConstants α).onTheory T ∪ L.distinctConstantsTheory s := by\n    refine' ((LHom.onTheory_model _ _).2 inferInstance).union _\n    rw [model_distinctConstantsTheory]\n    refine' fun a as b bs ab => _\n    rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]\n    exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))\n  exact Model.isSatisfiable M"},{"tailPos":7200,"headPos":7198,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"by"},{"tailPos":7944,"headPos":7198,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Nonempty M\ninst✝¹ : Structure L M\ninst✝ : M ⊨ T\nh : lift (#↑s) ≤ lift (#M)\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"by\n  haveI : Inhabited M := Classical.inhabited_of_nonempty inferInstance\n  rw [Cardinal.lift_mk_le'] at h\n  letI : (constantsOn α).Structure M := constantsOn.structure (Function.extend (↑) h.some default)\n  have : M ⊨ (L.lhomWithConstants α).onTheory T ∪ L.distinctConstantsTheory s := by\n    refine' ((LHom.onTheory_model _ _).2 inferInstance).union _\n    rw [model_distinctConstantsTheory]\n    refine' fun a as b bs ab => _\n    rw [← Subtype.coe_mk a as, ← Subtype.coe_mk b bs, ← Subtype.ext_iff]\n    exact\n      h.some.injective\n        ((Subtype.coe_injective.extend_apply h.some default ⟨a, as⟩).symm.trans\n          (ab.trans (Subtype.coe_injective.extend_apply h.some default ⟨b, bs⟩)))\n  exact Model.isSatisfiable M"},{"tailPos":8420,"headPos":8386,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable\n    (LHom.onTheory (lhomWithConstants L α) T ∪\n      ⋃ (t : Finset ↑s), distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) t))"],"content":"distinctConstantsTheory_eq_iUnion,"},{"tailPos":8438,"headPos":8421,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable\n    (LHom.onTheory (lhomWithConstants L α) T ∪\n      ⋃ (t : Finset ↑s), distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) t))"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable\n    (⋃ (i : Finset ↑s),\n      LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))"],"content":"Set.union_iUnion,"},{"tailPos":8471,"headPos":8439,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable\n    (⋃ (i : Finset ↑s),\n      LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))","L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"isSatisfiable_directed_union_iff"},{"tailPos":8472,"headPos":8471,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))","L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))","L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"]"},{"tailPos":8472,"headPos":8382,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))","L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"rw [distinctConstantsTheory_eq_iUnion, Set.union_iUnion, isSatisfiable_directed_union_iff]"},{"tailPos":8479,"headPos":8477,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))","L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))"],"content":"·"},{"tailPos":8677,"headPos":8480,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))"],"goalsAfter":[],"content":"exact fun t =>\n        isSatisfiable_union_distinctConstantsTheory_of_card_le T _ M\n          ((lift_le_aleph0.2 (finset_card_lt_aleph0 _).le).trans\n            (aleph0_le_lift.2 (aleph0_le_mk M)))"},{"tailPos":8677,"headPos":8477,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∀ (i : Finset ↑s),\n    IsSatisfiable\n      (LHom.onTheory (lhomWithConstants L α) T ∪\n        distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i))","L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"· exact fun t =>\n        isSatisfiable_union_distinctConstantsTheory_of_card_le T _ M\n          ((lift_le_aleph0.2 (finset_card_lt_aleph0 _).le).trans\n            (aleph0_le_lift.2 (aleph0_le_mk M)))"},{"tailPos":8684,"headPos":8682,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"·"},{"tailPos":8711,"headPos":8685,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["case a\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Monotone fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"apply Monotone.directed_le"},{"tailPos":8788,"headPos":8718,"goalsBefore":["case a\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Monotone fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["case a\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Monotone fun i => ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"content":"refine' monotone_const.union (monotone_distinctConstantsTheory.comp _)"},{"tailPos":8853,"headPos":8795,"goalsBefore":["case a\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Monotone fun i => ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":["case a\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Monotone fun i => (fun a => ↑a) '' ↑i"],"content":"simp only [Finset.coe_map, Function.Embedding.coe_subtype]"},{"tailPos":9009,"headPos":8860,"goalsBefore":["case a\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Monotone fun i => (fun a => ↑a) '' ↑i"],"goalsAfter":[],"content":"exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2"},{"tailPos":9009,"headPos":8685,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":[],"content":"apply Monotone.directed_le\n      refine' monotone_const.union (monotone_distinctConstantsTheory.comp _)\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2"},{"tailPos":9009,"headPos":8682,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i =>\n    LHom.onTheory (lhomWithConstants L α) T ∪\n      distinctConstantsTheory L ↑(Finset.map (Function.Embedding.subtype fun x => x ∈ s) i)"],"goalsAfter":[],"content":"· apply Monotone.directed_le\n      refine' monotone_const.union (monotone_distinctConstantsTheory.comp _)\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2"},{"tailPos":9009,"headPos":8382,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"rw [distinctConstantsTheory_eq_iUnion, Set.union_iUnion, isSatisfiable_directed_union_iff]\n    · exact fun t =>\n        isSatisfiable_union_distinctConstantsTheory_of_card_le T _ M\n          ((lift_le_aleph0.2 (finset_card_lt_aleph0 _).le).trans\n            (aleph0_le_lift.2 (aleph0_le_mk M)))\n    · apply Monotone.directed_le\n      refine' monotone_const.union (monotone_distinctConstantsTheory.comp _)\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2"},{"tailPos":9009,"headPos":8368,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"classical\n    rw [distinctConstantsTheory_eq_iUnion, Set.union_iUnion, isSatisfiable_directed_union_iff]\n    · exact fun t =>\n        isSatisfiable_union_distinctConstantsTheory_of_card_le T _ M\n          ((lift_le_aleph0.2 (finset_card_lt_aleph0 _).le).trans\n            (aleph0_le_lift.2 (aleph0_le_mk M)))\n    · apply Monotone.directed_le\n      refine' monotone_const.union (monotone_distinctConstantsTheory.comp _)\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2"},{"tailPos":8365,"headPos":8363,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"by"},{"tailPos":9009,"headPos":8363,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\ns : Set α\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ IsSatisfiable (LHom.onTheory (lhomWithConstants L α) T ∪ distinctConstantsTheory L s)"],"goalsAfter":[],"content":"by\n  classical\n    rw [distinctConstantsTheory_eq_iUnion, Set.union_iUnion, isSatisfiable_directed_union_iff]\n    · exact fun t =>\n        isSatisfiable_union_distinctConstantsTheory_of_card_le T _ M\n          ((lift_le_aleph0.2 (finset_card_lt_aleph0 _).le).trans\n            (aleph0_le_lift.2 (aleph0_le_mk M)))\n    · apply Monotone.directed_le\n      refine' monotone_const.union (monotone_distinctConstantsTheory.comp _)\n      simp only [Finset.coe_map, Function.Embedding.coe_subtype]\n      exact Monotone.comp (g := Set.image ((↑) : s → α)) (f := ((↑) : Finset s → Set s))\n        Set.monotone_image fun _ _ => Finset.coe_subset.2"},{"tailPos":9592,"headPos":9487,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∃ N, lift κ ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\n⊢ ∃ N, lift κ ≤ (#↑N)"],"content":"obtain ⟨N⟩ :=\n    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set κ.out) M"},{"tailPos":9674,"headPos":9595,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\n⊢ ∃ N, lift κ ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\n⊢ lift κ ≤\n    (#↑(ModelType.reduct (lhomWithConstants L (Quotient.out κ))\n          (Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T))))"],"content":"refine' ⟨(N.is_model.mono (Set.subset_union_left _ _)).bundled.reduct _, _⟩"},{"tailPos":9766,"headPos":9677,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\n⊢ lift κ ≤\n    (#↑(ModelType.reduct (lhomWithConstants L (Quotient.out κ))\n          (Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T))))"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤\n    (#↑(ModelType.reduct (lhomWithConstants L (Quotient.out κ))\n          (Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T))))"],"content":"haveI : N ⊨ distinctConstantsTheory _ _ := N.is_model.mono (Set.subset_union_right _ _)"},{"tailPos":9798,"headPos":9773,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤\n    (#↑(ModelType.reduct (lhomWithConstants L (Quotient.out κ))\n          (Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T))))"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑(Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T)))"],"content":"ModelType.reduct_Carrier,"},{"tailPos":9805,"headPos":9799,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑(Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T)))"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑N)"],"content":"coe_of"},{"tailPos":9806,"headPos":9805,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑N)"],"content":"]"},{"tailPos":9806,"headPos":9769,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤\n    (#↑(ModelType.reduct (lhomWithConstants L (Quotient.out κ))\n          (Model.bundled (_ : ↑N ⊨ LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T))))"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑N)"],"content":"rw [ModelType.reduct_Carrier, coe_of]"},{"tailPos":9880,"headPos":9809,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift κ ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#Quotient.out κ) ≤ (#↑N)"],"content":"refine' _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out κ).symm)) _"},{"tailPos":9898,"headPos":9887,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#Quotient.out κ) ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑Set.univ) ≤ (#↑N)"],"content":"← mk_univ"},{"tailPos":9899,"headPos":9898,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑Set.univ) ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑Set.univ) ≤ (#↑N)"],"content":"]"},{"tailPos":9899,"headPos":9883,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#Quotient.out κ) ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑Set.univ) ≤ (#↑N)"],"content":"rw [← mk_univ]"},{"tailPos":10004,"headPos":9902,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑Set.univ) ≤ (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (lift (#↑N)) ≤ lift (#↑N)"],"content":"refine'\n    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{_, max u v w}.1 _)"},{"tailPos":10020,"headPos":10011,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (lift (#↑N)) ≤ lift (#↑N)"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑N) ≤ lift (#↑N)"],"content":"lift_lift"},{"tailPos":10021,"headPos":10020,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (#↑N) ≤ lift (#↑N)"],"goalsAfter":[],"content":"]"},{"tailPos":10021,"headPos":10007,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\nN : ModelType (LHom.onTheory (lhomWithConstants L (Quotient.out κ)) T ∪ distinctConstantsTheory L Set.univ)\nthis : ↑N ⊨ distinctConstantsTheory L Set.univ\n⊢ lift (lift (#↑N)) ≤ lift (#↑N)"],"goalsAfter":[],"content":"rw [lift_lift]"},{"tailPos":10021,"headPos":9487,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∃ N, lift κ ≤ (#↑N)"],"goalsAfter":[],"content":"obtain ⟨N⟩ :=\n    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set κ.out) M\n  refine' ⟨(N.is_model.mono (Set.subset_union_left _ _)).bundled.reduct _, _⟩\n  haveI : N ⊨ distinctConstantsTheory _ _ := N.is_model.mono (Set.subset_union_right _ _)\n  rw [ModelType.reduct_Carrier, coe_of]\n  refine' _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out κ).symm)) _\n  rw [← mk_univ]\n  refine'\n    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{_, max u v w}.1 _)\n  rw [lift_lift]"},{"tailPos":9484,"headPos":9482,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∃ N, lift κ ≤ (#↑N)"],"goalsAfter":[],"content":"by"},{"tailPos":10021,"headPos":9482,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' T : Theory L\nκ : Cardinal\nM : Type w'\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Infinite M\n⊢ ∃ N, lift κ ≤ (#↑N)"],"goalsAfter":[],"content":"by\n  obtain ⟨N⟩ :=\n    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set κ.out) M\n  refine' ⟨(N.is_model.mono (Set.subset_union_left _ _)).bundled.reduct _, _⟩\n  haveI : N ⊨ distinctConstantsTheory _ _ := N.is_model.mono (Set.subset_union_right _ _)\n  rw [ModelType.reduct_Carrier, coe_of]\n  refine' _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out κ).symm)) _\n  rw [← mk_univ]\n  refine'\n    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{_, max u v w}.1 _)\n  rw [lift_lift]"},{"tailPos":10491,"headPos":10367,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsSatisfiable (⋃ (i : ι), T i)"],"content":"refine'\n      ⟨fun h s => h.mono (Set.iUnion_mono fun _ => Set.iUnion_subset_iff.2 fun _ => refl _),\n        fun h => _⟩"},{"tailPos":10539,"headPos":10500,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsSatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"content":"isSatisfiable_iff_isFinitelySatisfiable"},{"tailPos":10540,"headPos":10539,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"content":"]"},{"tailPos":10540,"headPos":10496,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsSatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"content":"rw [isSatisfiable_iff_isFinitelySatisfiable]"},{"tailPos":10555,"headPos":10545,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\n⊢ IsFinitelySatisfiable (⋃ (i : ι), T i)"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (i : ι), T i\n⊢ IsSatisfiable ↑s"],"content":"intro s hs"},{"tailPos":10591,"headPos":10564,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (i : ι), T i\n⊢ IsSatisfiable ↑s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"content":"Set.iUnion_eq_iUnion_finset"},{"tailPos":10592,"headPos":10591,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"content":"]"},{"tailPos":10598,"headPos":10560,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (i : ι), T i\n⊢ IsSatisfiable ↑s"],"goalsAfter":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"content":"rw [Set.iUnion_eq_iUnion_finset] at hs"},{"tailPos":10846,"headPos":10687,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i => ⋃ (i_1 : ι) (_ : i_1 ∈ i), T i_1"],"goalsAfter":[],"content":"exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩"},{"tailPos":10680,"headPos":10678,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i => ⋃ (i_1 : ι) (_ : i_1 ∈ i), T i_1"],"goalsAfter":[],"content":"by"},{"tailPos":10846,"headPos":10678,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ Directed (fun x x_1 => x ⊆ x_1) fun i => ⋃ (i_1 : ι) (_ : i_1 ∈ i), T i_1"],"goalsAfter":[],"content":"by\n      exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩"},{"tailPos":10850,"headPos":10603,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"goalsAfter":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\nt : Finset ι\nht : ↑s ⊆ ⋃ (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"content":"obtain ⟨t, ht⟩ := Directed.exists_mem_subset_of_finset_subset_biUnion (by\n      exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩) hs"},{"tailPos":10874,"headPos":10855,"goalsBefore":["case intro\nL : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\nh : ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)\ns : Finset (Sentence L)\nhs : ↑s ⊆ ⋃ (t : Finset ι) (i : ι) (_ : i ∈ t), T i\nt : Finset ι\nht : ↑s ⊆ ⋃ (i : ι) (_ : i ∈ t), T i\n⊢ IsSatisfiable ↑s"],"goalsAfter":[],"content":"exact (h t).mono ht"},{"tailPos":10874,"headPos":10367,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)"],"goalsAfter":[],"content":"refine'\n      ⟨fun h s => h.mono (Set.iUnion_mono fun _ => Set.iUnion_subset_iff.2 fun _ => refl _),\n        fun h => _⟩\n    rw [isSatisfiable_iff_isFinitelySatisfiable]\n    intro s hs\n    rw [Set.iUnion_eq_iUnion_finset] at hs\n    obtain ⟨t, ht⟩ := Directed.exists_mem_subset_of_finset_subset_biUnion (by\n      exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩) hs\n    exact (h t).mono ht"},{"tailPos":10874,"headPos":10353,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)"],"goalsAfter":[],"content":"classical\n    refine'\n      ⟨fun h s => h.mono (Set.iUnion_mono fun _ => Set.iUnion_subset_iff.2 fun _ => refl _),\n        fun h => _⟩\n    rw [isSatisfiable_iff_isFinitelySatisfiable]\n    intro s hs\n    rw [Set.iUnion_eq_iUnion_finset] at hs\n    obtain ⟨t, ht⟩ := Directed.exists_mem_subset_of_finset_subset_biUnion (by\n      exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩) hs\n    exact (h t).mono ht"},{"tailPos":10350,"headPos":10348,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)"],"goalsAfter":[],"content":"by"},{"tailPos":10874,"headPos":10348,"goalsBefore":["L : Language\nT✝ : Theory L\nα : Type w\nn : ℕ\nT' : Theory L\nι : Type u_1\nT : ι → Theory L\n⊢ IsSatisfiable (⋃ (i : ι), T i) ↔ ∀ (s : Finset ι), IsSatisfiable (⋃ (i : ι) (_ : i ∈ s), T i)"],"goalsAfter":[],"content":"by\n  classical\n    refine'\n      ⟨fun h s => h.mono (Set.iUnion_mono fun _ => Set.iUnion_subset_iff.2 fun _ => refl _),\n        fun h => _⟩\n    rw [isSatisfiable_iff_isFinitelySatisfiable]\n    intro s hs\n    rw [Set.iUnion_eq_iUnion_finset] at hs\n    obtain ⟨t, ht⟩ := Directed.exists_mem_subset_of_finset_subset_biUnion (by\n      exact Monotone.directed_le fun t1 t2 (h : ∀ ⦃x⦄, x ∈ t1 → x ∈ t2) =>\n        Set.iUnion_mono fun _ => Set.iUnion_mono' fun h1 => ⟨h h1, refl _⟩) hs\n    exact (h t).mono ht"},{"tailPos":11706,"headPos":11702,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ lift (#↑∅) ≤ lift κ"],"goalsAfter":[],"content":"simp only [mk_fintype, Fintype.card_of_isEmpty, Nat.cast_zero, lift_zero, ge_iff_le, zero_le]"},{"tailPos":11701,"headPos":11699,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ lift (#↑∅) ≤ lift κ"],"goalsAfter":[],"content":"by"},{"tailPos":11706,"headPos":11699,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ lift (#↑∅) ≤ lift κ"],"goalsAfter":[],"content":"by simp"},{"tailPos":11713,"headPos":11623,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"content":"obtain ⟨S, _, hS⟩ := exists_elementarySubstructure_card_eq L ∅ κ h1 (by simp) h2 h3"},{"tailPos":11773,"headPos":11749,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (lift (#{ x // x ∈ S })) = lift (lift κ)\n⊢ Small { x // x ∈ S }"],"content":"← lift_inj.{_, w + 1},"},{"tailPos":11784,"headPos":11774,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (lift (#{ x // x ∈ S })) = lift (lift κ)\n⊢ Small { x // x ∈ S }"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift (lift κ)\n⊢ Small { x // x ∈ S }"],"content":"lift_lift,"},{"tailPos":11794,"headPos":11785,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift (lift κ)\n⊢ Small { x // x ∈ S }"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"content":"lift_lift"},{"tailPos":11795,"headPos":11794,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"content":"]"},{"tailPos":11801,"headPos":11745,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"content":"rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS"},{"tailPos":11876,"headPos":11806,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":[],"content":"exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')"},{"tailPos":11876,"headPos":11745,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":[],"content":"rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')"},{"tailPos":11740,"headPos":11738,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":[],"content":"by"},{"tailPos":11876,"headPos":11738,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ Small { x // x ∈ S }"],"goalsAfter":[],"content":"by\n    rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')"},{"tailPos":11876,"headPos":11716,"goalsBefore":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\nthis : Small { x // x ∈ S }\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"content":"have : Small.{w} S := by\n    rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')"},{"tailPos":12054,"headPos":11879,"goalsBefore":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\nthis : Small { x // x ∈ S }\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\nthis : Small { x // x ∈ S }\n⊢ lift (#↑(Equiv.bundledInduced L (equivShrink { x // x ∈ S }))) = lift (#{ x // x ∈ S })"],"content":"refine'\n    ⟨(equivShrink S).bundledInduced L,\n      ⟨S.subtype.comp (Equiv.bundledInducedEquiv L _).symm.toElementaryEmbedding⟩,\n      lift_inj.1 (_root_.trans _ hS)⟩"},{"tailPos":12109,"headPos":12057,"goalsBefore":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\nS : ElementarySubstructure L M\nleft✝ : ∅ ⊆ ↑S\nhS : lift (#{ x // x ∈ S }) = lift κ\nthis : Small { x // x ∈ S }\n⊢ lift (#↑(Equiv.bundledInduced L (equivShrink { x // x ∈ S }))) = lift (#{ x // x ∈ S })"],"goalsAfter":[],"content":"simp only [Equiv.bundledInduced_α, lift_mk_shrink']"},{"tailPos":12109,"headPos":11623,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"obtain ⟨S, _, hS⟩ := exists_elementarySubstructure_card_eq L ∅ κ h1 (by simp) h2 h3\n  have : Small.{w} S := by\n    rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')\n  refine'\n    ⟨(equivShrink S).bundledInduced L,\n      ⟨S.subtype.comp (Equiv.bundledInducedEquiv L _).symm.toElementaryEmbedding⟩,\n      lift_inj.1 (_root_.trans _ hS)⟩\n  simp only [Equiv.bundledInduced_α, lift_mk_shrink']"},{"tailPos":11620,"headPos":11618,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by"},{"tailPos":12109,"headPos":11618,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Nonempty M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh3 : lift κ ≤ lift (#M)\n⊢ ∃ N, Nonempty (↑N ↪ₑ[L] M) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by\n  obtain ⟨S, _, hS⟩ := exists_elementarySubstructure_card_eq L ∅ κ h1 (by simp) h2 h3\n  have : Small.{w} S := by\n    rw [← lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS\n    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS κ.lift_lt_univ')\n  refine'\n    ⟨(equivShrink S).bundledInduced L,\n      ⟨S.subtype.comp (Equiv.bundledInducedEquiv L _).symm.toElementaryEmbedding⟩,\n      lift_inj.1 (_root_.trans _ hS)⟩\n  simp only [Equiv.bundledInduced_α, lift_mk_shrink']"},{"tailPos":12998,"headPos":12909,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"obtain ⟨N0, hN0⟩ := (L.elementaryDiagram M).exists_large_model_of_infinite_model κ M"},{"tailPos":13037,"headPos":13005,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (lift (#M)) ≤ lift (lift κ)\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"← lift_le.{max w w', max u v},"},{"tailPos":13048,"headPos":13038,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (lift (#M)) ≤ lift (lift κ)\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift (lift κ)\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"lift_lift,"},{"tailPos":13058,"headPos":13049,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift (lift κ)\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"lift_lift"},{"tailPos":13059,"headPos":13058,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"]"},{"tailPos":13065,"headPos":13001,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"rw [← lift_le.{max w w', max u v}, lift_lift, lift_lift] at h2"},{"tailPos":13302,"headPos":13251,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card (L[[M]])) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card L) + lift (#M) ≤ lift κ"],"content":"simp only [card_withConstants, lift_add, lift_lift]"},{"tailPos":13324,"headPos":13315,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card L) + lift (#M) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) + lift (card L) ≤ lift κ"],"content":"add_comm,"},{"tailPos":13375,"headPos":13325,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) + lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ max (lift (#M)) (lift (card L)) ≤ lift κ"],"content":"add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)),"},{"tailPos":13386,"headPos":13376,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ max (lift (#M)) (lift (card L)) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"max_le_iff"},{"tailPos":13387,"headPos":13386,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"]"},{"tailPos":13387,"headPos":13311,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card L) + lift (#M) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]"},{"tailPos":13420,"headPos":13400,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (lift (card L)) ≤ lift (lift κ)\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"← lift_le.{_, w'},"},{"tailPos":13431,"headPos":13421,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (lift (card L)) ≤ lift (lift κ)\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift (lift κ)\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"lift_lift,"},{"tailPos":13441,"headPos":13432,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift (lift κ)\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"lift_lift"},{"tailPos":13442,"headPos":13441,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"]"},{"tailPos":13448,"headPos":13396,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"content":"rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1"},{"tailPos":13475,"headPos":13457,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (#M) ≤ lift κ ∧ lift (card L) ≤ lift κ"],"goalsAfter":[],"content":"exact ⟨h2, h1⟩"},{"tailPos":13475,"headPos":13251,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card (L[[M]])) ≤ lift κ"],"goalsAfter":[],"content":"simp only [card_withConstants, lift_add, lift_lift]\n        rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n        rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1\n        exact ⟨h2, h1⟩"},{"tailPos":13242,"headPos":13240,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card (L[[M]])) ≤ lift κ"],"goalsAfter":[],"content":"by"},{"tailPos":13475,"headPos":13240,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ lift (card (L[[M]])) ≤ lift κ"],"goalsAfter":[],"content":"by\n        simp only [card_withConstants, lift_add, lift_lift]\n        rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n        rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1\n        exact ⟨h2, h1⟩"},{"tailPos":13517,"headPos":13502,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ lift (#↑N0)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ lift (#↑N0)"],"content":"← lift_umax',"},{"tailPos":13525,"headPos":13518,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ lift (#↑N0)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ (#↑N0)"],"content":"lift_id"},{"tailPos":13526,"headPos":13525,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ (#↑N0)"],"goalsAfter":[],"content":"]"},{"tailPos":13526,"headPos":13498,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ lift (#↑N0)"],"goalsAfter":[],"content":"rw [← lift_umax', lift_id]"},{"tailPos":13497,"headPos":13495,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ lift (#↑N0)"],"goalsAfter":[],"content":"by"},{"tailPos":13526,"headPos":13495,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ (#↑N0) ≤ lift (#↑N0)"],"goalsAfter":[],"content":"by rw [← lift_umax', lift_id]"},{"tailPos":13528,"headPos":13068,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"obtain ⟨N, ⟨NN0⟩, hN⟩ :=\n    exists_elementaryEmbedding_card_eq_of_le (L[[M]]) N0 κ\n      (aleph0_le_lift.1 ((aleph0_le_lift.2 (aleph0_le_mk M)).trans h2))\n      (by\n        simp only [card_withConstants, lift_add, lift_lift]\n        rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n        rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1\n        exact ⟨h2, h1⟩)\n      (hN0.trans (by rw [← lift_umax', lift_id]))"},{"tailPos":13533,"headPos":13531,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"·"},{"tailPos":13574,"headPos":13534,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\nthis : Structure L ↑N := LHom.reduct (lhomWithConstants L M) ↑N\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"letI := (lhomWithConstants L M).reduct N"},{"tailPos":13688,"headPos":13579,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\nthis : Structure L ↑N := LHom.reduct (lhomWithConstants L M) ↑N\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\nthis : Structure L ↑N := LHom.reduct (lhomWithConstants L M) ↑N\nh : ↑N ⊨ elementaryDiagram L M\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"content":"haveI h : N ⊨ L.elementaryDiagram M :=\n      (NN0.theory_model_iff (L.elementaryDiagram M)).2 inferInstance"},{"tailPos":13732,"headPos":13693,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\nthis : Structure L ↑N := LHom.reduct (lhomWithConstants L M) ↑N\nh : ↑N ⊨ elementaryDiagram L M\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\nthis : Structure L ↑N := LHom.reduct (lhomWithConstants L M) ↑N\nh : ↑N ⊨ elementaryDiagram L M\n⊢ M ↪ₑ[L] ↑(Bundled.of ↑N)"],"content":"refine' ⟨Bundled.of N, ⟨_⟩, hN⟩"},{"tailPos":13794,"headPos":13737,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\nthis : Structure L ↑N := LHom.reduct (lhomWithConstants L M) ↑N\nh : ↑N ⊨ elementaryDiagram L M\n⊢ M ↪ₑ[L] ↑(Bundled.of ↑N)"],"goalsAfter":[],"content":"apply ElementaryEmbedding.ofModelsElementaryDiagram L M N"},{"tailPos":13794,"headPos":13534,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"letI := (lhomWithConstants L M).reduct N\n    haveI h : N ⊨ L.elementaryDiagram M :=\n      (NN0.theory_model_iff (L.elementaryDiagram M)).2 inferInstance\n    refine' ⟨Bundled.of N, ⟨_⟩, hN⟩\n    apply ElementaryEmbedding.ofModelsElementaryDiagram L M N"},{"tailPos":13794,"headPos":13531,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\nN0 : Theory.ModelType (elementaryDiagram L M)\nhN0 : lift κ ≤ (#↑N0)\nN : Bundled (Structure (L[[M]]))\nhN : (#↑N) = κ\nNN0 : ↑N ↪ₑ[L[[M]]] ↑N0\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"· letI := (lhomWithConstants L M).reduct N\n    haveI h : N ⊨ L.elementaryDiagram M :=\n      (NN0.theory_model_iff (L.elementaryDiagram M)).2 inferInstance\n    refine' ⟨Bundled.of N, ⟨_⟩, hN⟩\n    apply ElementaryEmbedding.ofModelsElementaryDiagram L M N"},{"tailPos":13794,"headPos":12909,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"obtain ⟨N0, hN0⟩ := (L.elementaryDiagram M).exists_large_model_of_infinite_model κ M\n  rw [← lift_le.{max w w', max u v}, lift_lift, lift_lift] at h2\n  obtain ⟨N, ⟨NN0⟩, hN⟩ :=\n    exists_elementaryEmbedding_card_eq_of_le (L[[M]]) N0 κ\n      (aleph0_le_lift.1 ((aleph0_le_lift.2 (aleph0_le_mk M)).trans h2))\n      (by\n        simp only [card_withConstants, lift_add, lift_lift]\n        rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n        rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1\n        exact ⟨h2, h1⟩)\n      (hN0.trans (by rw [← lift_umax', lift_id]))\n  · letI := (lhomWithConstants L M).reduct N\n    haveI h : N ⊨ L.elementaryDiagram M :=\n      (NN0.theory_model_iff (L.elementaryDiagram M)).2 inferInstance\n    refine' ⟨Bundled.of N, ⟨_⟩, hN⟩\n    apply ElementaryEmbedding.ofModelsElementaryDiagram L M N"},{"tailPos":12906,"headPos":12904,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by"},{"tailPos":13794,"headPos":12904,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : lift (card L) ≤ lift κ\nh2 : lift (#M) ≤ lift κ\n⊢ ∃ N, Nonempty (M ↪ₑ[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by\n  obtain ⟨N0, hN0⟩ := (L.elementaryDiagram M).exists_large_model_of_infinite_model κ M\n  rw [← lift_le.{max w w', max u v}, lift_lift, lift_lift] at h2\n  obtain ⟨N, ⟨NN0⟩, hN⟩ :=\n    exists_elementaryEmbedding_card_eq_of_le (L[[M]]) N0 κ\n      (aleph0_le_lift.1 ((aleph0_le_lift.2 (aleph0_le_mk M)).trans h2))\n      (by\n        simp only [card_withConstants, lift_add, lift_lift]\n        rw [add_comm, add_eq_max (aleph0_le_lift.2 (infinite_iff.1 iM)), max_le_iff]\n        rw [← lift_le.{_, w'}, lift_lift, lift_lift] at h1\n        exact ⟨h2, h1⟩)\n      (hN0.trans (by rw [← lift_umax', lift_id]))\n  · letI := (lhomWithConstants L M).reduct N\n    haveI h : N ⊨ L.elementaryDiagram M :=\n      (NN0.theory_model_iff (L.elementaryDiagram M)).2 inferInstance\n    refine' ⟨Bundled.of N, ⟨_⟩, hN⟩\n    apply ElementaryEmbedding.ofModelsElementaryDiagram L M N"},{"tailPos":14545,"headPos":14491,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh✝ : lift κ ≤ lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh✝ : lift κ > lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"content":"cases le_or_gt (lift.{w'} κ) (Cardinal.lift.{w} (#M))"},{"tailPos":14649,"headPos":14566,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ ≤ lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ ≤ lift (#M)\nN : Bundled (Structure L)\nhN1 : Nonempty (↑N ↪ₑ[L] M)\nhN2 : (#↑N) = κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"content":"obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_le L M κ h1 h2 h"},{"tailPos":14684,"headPos":14654,"goalsBefore":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ ≤ lift (#M)\nN : Bundled (Structure L)\nhN1 : Nonempty (↑N ↪ₑ[L] M)\nhN2 : (#↑N) = κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"exact ⟨N, Or.inl hN1, hN2⟩"},{"tailPos":14684,"headPos":14566,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ ≤ lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_le L M κ h1 h2 h\n    exact ⟨N, Or.inl hN1, hN2⟩"},{"tailPos":14684,"headPos":14548,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ ≤ lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"case inl h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_le L M κ h1 h2 h\n    exact ⟨N, Or.inl hN1, hN2⟩"},{"tailPos":14796,"headPos":14705,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ > lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ > lift (#M)\nN : Bundled (Structure L)\nhN1 : Nonempty (M ↪ₑ[L] ↑N)\nhN2 : (#↑N) = κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"content":"obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_ge L M κ h2 (le_of_lt h)"},{"tailPos":14831,"headPos":14801,"goalsBefore":["case intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ > lift (#M)\nN : Bundled (Structure L)\nhN1 : Nonempty (M ↪ₑ[L] ↑N)\nhN2 : (#↑N) = κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"exact ⟨N, Or.inr hN1, hN2⟩"},{"tailPos":14831,"headPos":14705,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ > lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_ge L M κ h2 (le_of_lt h)\n    exact ⟨N, Or.inr hN1, hN2⟩"},{"tailPos":14831,"headPos":14687,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nh : lift κ > lift (#M)\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"case inr h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_ge L M κ h2 (le_of_lt h)\n    exact ⟨N, Or.inr hN1, hN2⟩"},{"tailPos":14831,"headPos":14491,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"cases le_or_gt (lift.{w'} κ) (Cardinal.lift.{w} (#M))\n  case inl h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_le L M κ h1 h2 h\n    exact ⟨N, Or.inl hN1, hN2⟩\n  case inr h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_ge L M κ h2 (le_of_lt h)\n    exact ⟨N, Or.inr hN1, hN2⟩"},{"tailPos":14488,"headPos":14486,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by"},{"tailPos":14831,"headPos":14486,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝ : Structure L M\niM : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (Nonempty (↑N ↪ₑ[L] M) ∨ Nonempty (M ↪ₑ[L] ↑N)) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by\n  cases le_or_gt (lift.{w'} κ) (Cardinal.lift.{w} (#M))\n  case inl h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_le L M κ h1 h2 h\n    exact ⟨N, Or.inl hN1, hN2⟩\n  case inr h =>\n    obtain ⟨N, hN1, hN2⟩ := exists_elementaryEmbedding_card_eq_of_ge L M κ h2 (le_of_lt h)\n    exact ⟨N, Or.inr hN1, hN2⟩"},{"tailPos":15535,"headPos":15455,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nNM : Nonempty (↑N ↪ₑ[L] M)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ","case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"content":"obtain ⟨N, NM | MN, hNκ⟩ := exists_elementaryEmbedding_card_eq L M κ h1 h2"},{"tailPos":15540,"headPos":15538,"goalsBefore":["case intro.intro.inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nNM : Nonempty (↑N ↪ₑ[L] M)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ","case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nNM : Nonempty (↑N ↪ₑ[L] M)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"content":"·"},{"tailPos":15597,"headPos":15541,"goalsBefore":["case intro.intro.inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nNM : Nonempty (↑N ↪ₑ[L] M)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"exact ⟨N, NM.some.elementarilyEquivalent.symm, hNκ⟩"},{"tailPos":15597,"headPos":15538,"goalsBefore":["case intro.intro.inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nNM : Nonempty (↑N ↪ₑ[L] M)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ","case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"content":"· exact ⟨N, NM.some.elementarilyEquivalent.symm, hNκ⟩"},{"tailPos":15602,"headPos":15600,"goalsBefore":["case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":["case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"content":"·"},{"tailPos":15654,"headPos":15603,"goalsBefore":["case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"exact ⟨N, MN.some.elementarilyEquivalent, hNκ⟩"},{"tailPos":15654,"headPos":15600,"goalsBefore":["case intro.intro.inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nN : Bundled (Structure L)\nhNκ : (#↑N) = κ\nMN : Nonempty (M ↪ₑ[L] ↑N)\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"· exact ⟨N, MN.some.elementarilyEquivalent, hNκ⟩"},{"tailPos":15654,"headPos":15455,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"obtain ⟨N, NM | MN, hNκ⟩ := exists_elementaryEmbedding_card_eq L M κ h1 h2\n  · exact ⟨N, NM.some.elementarilyEquivalent.symm, hNκ⟩\n  · exact ⟨N, MN.some.elementarilyEquivalent, hNκ⟩"},{"tailPos":15452,"headPos":15450,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by"},{"tailPos":15654,"headPos":15450,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w'\ninst✝¹ : Structure L M\ninst✝ : Infinite M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (M ≅[L] ↑N) ∧ (#↑N) = κ"],"goalsAfter":[],"content":"by\n  obtain ⟨N, NM | MN, hNκ⟩ := exists_elementaryEmbedding_card_eq L M κ h1 h2\n  · exact ⟨N, NM.some.elementarilyEquivalent.symm, hNκ⟩\n  · exact ⟨N, MN.some.elementarilyEquivalent, hNκ⟩"},{"tailPos":16105,"headPos":16094,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nM : ModelType T\nMI : Infinite ↑M\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nM : ModelType T\nMI this : Infinite ↑M\n⊢ ∃ N, (#↑N) = κ"],"content":"haveI := MI"},{"tailPos":16187,"headPos":16110,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nM : ModelType T\nMI this : Infinite ↑M\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":["case intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : ModelType T\nMI this : Infinite ↑M\nN : Bundled (Structure L)\nhN : ↑M ≅[L] ↑N\nh1 : ℵ₀ ≤ (#↑N)\nh2 : lift (card L) ≤ lift (#↑N)\n⊢ ∃ N_1, (#↑N_1) = (#↑N)"],"content":"obtain ⟨N, hN, rfl⟩ := exists_elementarilyEquivalent_card_eq L M κ h1 h2"},{"tailPos":16225,"headPos":16192,"goalsBefore":["case intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : ModelType T\nMI this : Infinite ↑M\nN : Bundled (Structure L)\nhN : ↑M ≅[L] ↑N\nh1 : ℵ₀ ≤ (#↑N)\nh2 : lift (card L) ≤ lift (#↑N)\n⊢ ∃ N_1, (#↑N_1) = (#↑N)"],"goalsAfter":["case intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : ModelType T\nMI this✝ : Infinite ↑M\nN : Bundled (Structure L)\nhN : ↑M ≅[L] ↑N\nh1 : ℵ₀ ≤ (#↑N)\nh2 : lift (card L) ≤ lift (#↑N)\nthis : Nonempty ↑N\n⊢ ∃ N_1, (#↑N_1) = (#↑N)"],"content":"haveI : Nonempty N := hN.nonempty"},{"tailPos":16270,"headPos":16230,"goalsBefore":["case intro.intro.intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : ModelType T\nMI this✝ : Infinite ↑M\nN : Bundled (Structure L)\nhN : ↑M ≅[L] ↑N\nh1 : ℵ₀ ≤ (#↑N)\nh2 : lift (card L) ≤ lift (#↑N)\nthis : Nonempty ↑N\n⊢ ∃ N_1, (#↑N_1) = (#↑N)"],"goalsAfter":[],"content":"exact ⟨hN.theory_model.bundled, rfl⟩"},{"tailPos":16270,"headPos":16094,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nM : ModelType T\nMI : Infinite ↑M\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":[],"content":"haveI := MI\n    obtain ⟨N, hN, rfl⟩ := exists_elementarilyEquivalent_card_eq L M κ h1 h2\n    haveI : Nonempty N := hN.nonempty\n    exact ⟨hN.theory_model.bundled, rfl⟩"},{"tailPos":16270,"headPos":16074,"goalsBefore":["case intro\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nM : ModelType T\nMI : Infinite ↑M\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":[],"content":"| intro M MI =>\n    haveI := MI\n    obtain ⟨N, hN, rfl⟩ := exists_elementarilyEquivalent_card_eq L M κ h1 h2\n    haveI : Nonempty N := hN.nonempty\n    exact ⟨hN.theory_model.bundled, rfl⟩"},{"tailPos":16270,"headPos":16059,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : ∃ M, Infinite ↑M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : ∃ M, Infinite ↑M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (#↑N) = κ"],"content":"cases h with\n  | intro M MI =>\n    haveI := MI\n    obtain ⟨N, hN, rfl⟩ := exists_elementarilyEquivalent_card_eq L M κ h1 h2\n    haveI : Nonempty N := hN.nonempty\n    exact ⟨hN.theory_model.bundled, rfl⟩"},{"tailPos":16056,"headPos":16054,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : ∃ M, Infinite ↑M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":[],"content":"by"},{"tailPos":16270,"headPos":16054,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : ∃ M, Infinite ↑M\nκ : Cardinal\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\n⊢ ∃ N, (#↑N) = κ"],"goalsAfter":[],"content":"by\n  cases h with\n  | intro M MI =>\n    haveI := MI\n    obtain ⟨N, hN, rfl⟩ := exists_elementarilyEquivalent_card_eq L M κ h1 h2\n    haveI : Nonempty N := hN.nonempty\n    exact ⟨hN.theory_model.bundled, rfl⟩"},{"tailPos":18014,"headPos":17994,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"content":"models_sentence_iff,"},{"tailPos":18028,"headPos":18015,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"IsSatisfiable"},{"tailPos":18029,"headPos":18028,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬Nonempty (ModelType (T ∪ {Formula.not φ}))"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"]"},{"tailPos":18029,"headPos":17990,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"rw [models_sentence_iff, IsSatisfiable]"},{"tailPos":18301,"headPos":18032,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ (∀ (M : ModelType T), ↑M ⊨ φ) ↔ ¬Nonempty (ModelType (T ∪ {Formula.not φ}))"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬Nonempty (ModelType (T ∪ {Formula.not φ}))\nM : ModelType T\n⊢ ↑M ⊨ φ"],"content":"refine'\n    ⟨fun h1 h2 =>\n      (Sentence.realize_not _).1\n        (realize_sentence_of_mem (T ∪ {Formula.not φ})\n          (Set.subset_union_right _ _ (Set.mem_singleton _)))\n        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),\n      fun h M => _⟩"},{"tailPos":18317,"headPos":18304,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬Nonempty (ModelType (T ∪ {Formula.not φ}))\nM : ModelType T\n⊢ ↑M ⊨ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ¬↑M ⊨ φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"contrapose! h"},{"tailPos":18348,"headPos":18324,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ¬↑M ⊨ φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"← Sentence.realize_not"},{"tailPos":18349,"headPos":18348,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"]"},{"tailPos":18354,"headPos":18320,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ¬↑M ⊨ φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"content":"rw [← Sentence.realize_not] at h"},{"tailPos":18481,"headPos":18357,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\n⊢ Nonempty (ModelType (T ∪ {Formula.not φ}))"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ ψ"],"content":"refine'\n    ⟨{  Carrier := M\n        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => _⟩ }⟩"},{"tailPos":18514,"headPos":18488,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ Formula.not φ"],"content":"Set.mem_singleton_iff.1 h'"},{"tailPos":18515,"headPos":18514,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ Formula.not φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ Formula.not φ"],"content":"]"},{"tailPos":18515,"headPos":18484,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ Formula.not φ"],"content":"rw [Set.mem_singleton_iff.1 h']"},{"tailPos":18525,"headPos":18518,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : ModelType T\nh : ↑M ⊨ Formula.not φ\nψ : Sentence L\nhψ : ψ ∈ T ∪ {Formula.not φ}\nh' : ψ ∈ {Formula.not φ}\n⊢ ↑M ⊨ Formula.not φ"],"goalsAfter":[],"content":"exact h"},{"tailPos":18525,"headPos":17990,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":[],"content":"rw [models_sentence_iff, IsSatisfiable]\n  refine'\n    ⟨fun h1 h2 =>\n      (Sentence.realize_not _).1\n        (realize_sentence_of_mem (T ∪ {Formula.not φ})\n          (Set.subset_union_right _ _ (Set.mem_singleton _)))\n        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),\n      fun h M => _⟩\n  contrapose! h\n  rw [← Sentence.realize_not] at h\n  refine'\n    ⟨{  Carrier := M\n        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => _⟩ }⟩\n  rw [Set.mem_singleton_iff.1 h']\n  exact h"},{"tailPos":17987,"headPos":17985,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":[],"content":"by"},{"tailPos":18525,"headPos":17985,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\n⊢ T ⊨ᵇ φ ↔ ¬IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":[],"content":"by\n  rw [models_sentence_iff, IsSatisfiable]\n  refine'\n    ⟨fun h1 h2 =>\n      (Sentence.realize_not _).1\n        (realize_sentence_of_mem (T ∪ {Formula.not φ})\n          (Set.subset_union_right _ _ (Set.mem_singleton _)))\n        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),\n      fun h M => _⟩\n  contrapose! h\n  rw [← Sentence.realize_not] at h\n  refine'\n    ⟨{  Carrier := M\n        is_model := ⟨fun ψ hψ => hψ.elim (realize_sentence_of_mem _) fun h' => _⟩ }⟩\n  rw [Set.mem_singleton_iff.1 h']\n  exact h"},{"tailPos":18830,"headPos":18804,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : T ⊨ᵇ φ\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬IsSatisfiable (T ∪ {Formula.not φ})\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"content":"models_iff_not_satisfiable"},{"tailPos":18831,"headPos":18830,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬IsSatisfiable (T ∪ {Formula.not φ})\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬IsSatisfiable (T ∪ {Formula.not φ})\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"content":"]"},{"tailPos":18836,"headPos":18800,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : T ⊨ᵇ φ\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬IsSatisfiable (T ∪ {Formula.not φ})\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"content":"rw [models_iff_not_satisfiable] at h"},{"tailPos":18852,"headPos":18839,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : ¬IsSatisfiable (T ∪ {Formula.not φ})\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ IsSatisfiable (T ∪ {Formula.not φ})"],"content":"contrapose! h"},{"tailPos":19009,"headPos":18901,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ M ⊨ T ∪ {Formula.not φ}"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ ∀ (a : Sentence L), a ∈ T → M ⊨ a"],"content":"simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]"},{"tailPos":19031,"headPos":19018,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ ∀ (a : Sentence L), a ∈ T → M ⊨ a"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ M ⊨ T"],"content":"← model_iff"},{"tailPos":19032,"headPos":19031,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ M ⊨ T"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ M ⊨ T"],"content":"]"},{"tailPos":19032,"headPos":19014,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ ∀ (a : Sentence L), a ∈ T → M ⊨ a"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ M ⊨ T"],"content":"rw [← model_iff]"},{"tailPos":19065,"headPos":19037,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ ¬M ⊨ φ ∧ M ⊨ T"],"goalsAfter":[],"content":"exact ⟨h, inferInstance⟩"},{"tailPos":19065,"headPos":18901,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ M ⊨ T ∪ {Formula.not φ}"],"goalsAfter":[],"content":"simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, inferInstance⟩"},{"tailPos":18896,"headPos":18894,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ M ⊨ T ∪ {Formula.not φ}"],"goalsAfter":[],"content":"by"},{"tailPos":19065,"headPos":18894,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ M ⊨ T ∪ {Formula.not φ}"],"goalsAfter":[],"content":"by\n    simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, inferInstance⟩"},{"tailPos":19065,"headPos":18855,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\n⊢ IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\nthis : M ⊨ T ∪ {Formula.not φ}\n⊢ IsSatisfiable (T ∪ {Formula.not φ})"],"content":"have : M ⊨ T ∪ {Formula.not φ} := by\n    simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, inferInstance⟩"},{"tailPos":19095,"headPos":19068,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nh : ¬M ⊨ φ\nthis : M ⊨ T ∪ {Formula.not φ}\n⊢ IsSatisfiable (T ∪ {Formula.not φ})"],"goalsAfter":[],"content":"exact Model.isSatisfiable M"},{"tailPos":19095,"headPos":18800,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : T ⊨ᵇ φ\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":[],"content":"rw [models_iff_not_satisfiable] at h\n  contrapose! h\n  have : M ⊨ T ∪ {Formula.not φ} := by\n    simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, inferInstance⟩\n  exact Model.isSatisfiable M"},{"tailPos":18797,"headPos":18795,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : T ⊨ᵇ φ\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":[],"content":"by"},{"tailPos":19095,"headPos":18795,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : Sentence L\nh : T ⊨ᵇ φ\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ"],"goalsAfter":[],"content":"by\n  rw [models_iff_not_satisfiable] at h\n  contrapose! h\n  have : M ⊨ T ∪ {Formula.not φ} := by\n    simp only [Set.union_singleton, model_iff, Set.mem_insert_iff, forall_eq_or_imp,\n      Sentence.realize_not]\n    rw [← model_iff]\n    exact ⟨h, inferInstance⟩\n  exact Model.isSatisfiable M"},{"tailPos":19684,"headPos":19657,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"content":"cases' h.2 φ with hφ hφn"},{"tailPos":19689,"headPos":19687,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"content":"·"},{"tailPos":19730,"headPos":19690,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬T ⊨ᵇ Formula.not φ"],"content":"simp only [hφ, not_true, iff_false_iff]"},{"tailPos":19759,"headPos":19739,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬T ⊨ᵇ Formula.not φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬∀ (M : ModelType T), ↑M ⊨ Formula.not φ"],"content":"models_sentence_iff,"},{"tailPos":19770,"headPos":19760,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬∀ (M : ModelType T), ↑M ⊨ Formula.not φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ∃ x, ¬↑x ⊨ Formula.not φ"],"content":"not_forall"},{"tailPos":19771,"headPos":19770,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ∃ x, ¬↑x ⊨ Formula.not φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ∃ x, ¬↑x ⊨ Formula.not φ"],"content":"]"},{"tailPos":19771,"headPos":19735,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬T ⊨ᵇ Formula.not φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ∃ x, ¬↑x ⊨ Formula.not φ"],"content":"rw [models_sentence_iff, not_forall]"},{"tailPos":19801,"headPos":19776,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ∃ x, ¬↑x ⊨ Formula.not φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬↑(Nonempty.some (_ : IsSatisfiable T)) ⊨ Formula.not φ"],"content":"refine' ⟨h.1.some, _⟩"},{"tailPos":19857,"headPos":19806,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ¬↑(Nonempty.some (_ : IsSatisfiable T)) ⊨ Formula.not φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ↑(Nonempty.some (_ : IsSatisfiable T)) ⊨ φ"],"content":"simp only [Sentence.realize_not, Classical.not_not]"},{"tailPos":19895,"headPos":19862,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ ↑(Nonempty.some (_ : IsSatisfiable T)) ⊨ φ"],"goalsAfter":[],"content":"exact models_sentence_iff.1 hφ _"},{"tailPos":19895,"headPos":19690,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":[],"content":"simp only [hφ, not_true, iff_false_iff]\n    rw [models_sentence_iff, not_forall]\n    refine' ⟨h.1.some, _⟩\n    simp only [Sentence.realize_not, Classical.not_not]\n    exact models_sentence_iff.1 hφ _"},{"tailPos":19895,"headPos":19687,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"content":"· simp only [hφ, not_true, iff_false_iff]\n    rw [models_sentence_iff, not_forall]\n    refine' ⟨h.1.some, _⟩\n    simp only [Sentence.realize_not, Classical.not_not]\n    exact models_sentence_iff.1 hφ _"},{"tailPos":19900,"headPos":19898,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"content":"·"},{"tailPos":19931,"headPos":19901,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ ¬T ⊨ᵇ φ"],"content":"simp only [hφn, true_iff_iff]"},{"tailPos":19945,"headPos":19936,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ ¬T ⊨ᵇ φ"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\nhφ : T ⊨ᵇ φ\n⊢ False"],"content":"intro hφ"},{"tailPos":19973,"headPos":19954,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\nhφ : T ⊨ᵇ φ\n⊢ False"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : ∀ (M : ModelType T), ↑M ⊨ Formula.not φ\nhφ : ∀ (M : ModelType T), ↑M ⊨ φ\n⊢ False"],"content":"models_sentence_iff"},{"tailPos":19974,"headPos":19973,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : ∀ (M : ModelType T), ↑M ⊨ Formula.not φ\nhφ : ∀ (M : ModelType T), ↑M ⊨ φ\n⊢ False"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : ∀ (M : ModelType T), ↑M ⊨ Formula.not φ\nhφ : ∀ (M : ModelType T), ↑M ⊨ φ\n⊢ False"],"content":"]"},{"tailPos":19979,"headPos":19950,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\nhφ : T ⊨ᵇ φ\n⊢ False"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : ∀ (M : ModelType T), ↑M ⊨ Formula.not φ\nhφ : ∀ (M : ModelType T), ↑M ⊨ φ\n⊢ False"],"content":"rw [models_sentence_iff] at *"},{"tailPos":20011,"headPos":19984,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : ∀ (M : ModelType T), ↑M ⊨ Formula.not φ\nhφ : ∀ (M : ModelType T), ↑M ⊨ φ\n⊢ False"],"goalsAfter":[],"content":"exact hφn h.1.some (hφ _)"},{"tailPos":20011,"headPos":19901,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":[],"content":"simp only [hφn, true_iff_iff]\n    intro hφ\n    rw [models_sentence_iff] at *\n    exact hφn h.1.some (hφ _)"},{"tailPos":20011,"headPos":19898,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nhφn : T ⊨ᵇ Formula.not φ\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":[],"content":"· simp only [hφn, true_iff_iff]\n    intro hφ\n    rw [models_sentence_iff] at *\n    exact hφn h.1.some (hφ _)"},{"tailPos":20011,"headPos":19657,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":[],"content":"cases' h.2 φ with hφ hφn\n  · simp only [hφ, not_true, iff_false_iff]\n    rw [models_sentence_iff, not_forall]\n    refine' ⟨h.1.some, _⟩\n    simp only [Sentence.realize_not, Classical.not_not]\n    exact models_sentence_iff.1 hφ _\n  · simp only [hφn, true_iff_iff]\n    intro hφ\n    rw [models_sentence_iff] at *\n    exact hφn h.1.some (hφ _)"},{"tailPos":19654,"headPos":19652,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":[],"content":"by"},{"tailPos":20011,"headPos":19652,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\n⊢ T ⊨ᵇ Formula.not φ ↔ ¬T ⊨ᵇ φ"],"goalsAfter":[],"content":"by\n  cases' h.2 φ with hφ hφn\n  · simp only [hφ, not_true, iff_false_iff]\n    rw [models_sentence_iff, not_forall]\n    refine' ⟨h.1.some, _⟩\n    simp only [Sentence.realize_not, Classical.not_not]\n    exact models_sentence_iff.1 hφ _\n  · simp only [hφn, true_iff_iff]\n    intro hφ\n    rw [models_sentence_iff] at *\n    exact hφn h.1.some (hφ _)"},{"tailPos":20312,"headPos":20285,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφ : T ⊨ᵇ φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"content":"cases' h.2 φ with hφ hφn"},{"tailPos":20317,"headPos":20315,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφ : T ⊨ᵇ φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφ : T ⊨ᵇ φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"content":"·"},{"tailPos":20364,"headPos":20318,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφ : T ⊨ᵇ φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":[],"content":"exact iff_of_true (hφ.realize_sentence M) hφ"},{"tailPos":20364,"headPos":20315,"goalsBefore":["case inl\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφ : T ⊨ᵇ φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ","case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"content":"· exact iff_of_true (hφ.realize_sentence M) hφ"},{"tailPos":20369,"headPos":20367,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"content":"·"},{"tailPos":20488,"headPos":20370,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":[],"content":"exact\n      iff_of_false ((Sentence.realize_not M).1 (hφn.realize_sentence M))\n        ((h.models_not_iff φ).1 hφn)"},{"tailPos":20488,"headPos":20367,"goalsBefore":["case inr\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\nhφn : T ⊨ᵇ Formula.not φ\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":[],"content":"· exact\n      iff_of_false ((Sentence.realize_not M).1 (hφn.realize_sentence M))\n        ((h.models_not_iff φ).1 hφn)"},{"tailPos":20488,"headPos":20285,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":[],"content":"cases' h.2 φ with hφ hφn\n  · exact iff_of_true (hφ.realize_sentence M) hφ\n  · exact\n      iff_of_false ((Sentence.realize_not M).1 (hφn.realize_sentence M))\n        ((h.models_not_iff φ).1 hφn)"},{"tailPos":20282,"headPos":20280,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":[],"content":"by"},{"tailPos":20488,"headPos":20280,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsComplete T\nφ : Sentence L\nM : Type u_1\ninst✝² : Structure L M\ninst✝¹ : M ⊨ T\ninst✝ : Nonempty M\n⊢ M ⊨ φ ↔ T ⊨ᵇ φ"],"goalsAfter":[],"content":"by\n  cases' h.2 φ with hφ hφn\n  · exact iff_of_true (hφ.realize_sentence M) hφ\n  · exact\n      iff_of_false ((Sentence.realize_not M).1 (hφn.realize_sentence M))\n        ((h.models_not_iff φ).1 hφn)"},{"tailPos":21599,"headPos":21543,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ φ ∈ T"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\ncon : Formula.not φ ∈ T\n⊢ False"],"content":"refine' (h.mem_or_not_mem φ).resolve_right fun con => _"},{"tailPos":21633,"headPos":21606,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\ncon : Formula.not φ ∈ T\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable (T ∪ {Formula.not φ})\ncon : Formula.not φ ∈ T\n⊢ False"],"content":"models_iff_not_satisfiable,"},{"tailPos":21654,"headPos":21634,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable (T ∪ {Formula.not φ})\ncon : Formula.not φ ∈ T\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable (insert (Formula.not φ) T)\ncon : Formula.not φ ∈ T\n⊢ False"],"content":"Set.union_singleton,"},{"tailPos":21679,"headPos":21655,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable (insert (Formula.not φ) T)\ncon : Formula.not φ ∈ T\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable T\ncon : Formula.not φ ∈ T\n⊢ False"],"content":"Set.insert_eq_of_mem con"},{"tailPos":21680,"headPos":21679,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable T\ncon : Formula.not φ ∈ T\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable T\ncon : Formula.not φ ∈ T\n⊢ False"],"content":"]"},{"tailPos":21687,"headPos":21602,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\ncon : Formula.not φ ∈ T\n⊢ False"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable T\ncon : Formula.not φ ∈ T\n⊢ False"],"content":"rw [models_iff_not_satisfiable, Set.union_singleton, Set.insert_eq_of_mem con] at hφ"},{"tailPos":21703,"headPos":21690,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : ¬IsSatisfiable T\ncon : Formula.not φ ∈ T\n⊢ False"],"goalsAfter":[],"content":"exact hφ h.1"},{"tailPos":21703,"headPos":21543,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ φ ∈ T"],"goalsAfter":[],"content":"refine' (h.mem_or_not_mem φ).resolve_right fun con => _\n  rw [models_iff_not_satisfiable, Set.union_singleton, Set.insert_eq_of_mem con] at hφ\n  exact hφ h.1"},{"tailPos":21540,"headPos":21538,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ φ ∈ T"],"goalsAfter":[],"content":"by"},{"tailPos":21703,"headPos":21538,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nh : IsMaximal T\nφ : Sentence L\nhφ : T ⊨ᵇ φ\n⊢ φ ∈ T"],"goalsAfter":[],"content":"by\n  refine' (h.mem_or_not_mem φ).resolve_right fun con => _\n  rw [models_iff_not_satisfiable, Set.union_singleton, Set.insert_eq_of_mem con] at hφ\n  exact hφ h.1"},{"tailPos":22678,"headPos":22652,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize φ v xs"],"content":"BoundedFormula.realize_iff"},{"tailPos":22679,"headPos":22678,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize φ v xs"],"goalsAfter":[],"content":"]"},{"tailPos":22679,"headPos":22648,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ φ) v xs"],"goalsAfter":[],"content":"rw [BoundedFormula.realize_iff]"},{"tailPos":22647,"headPos":22645,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ φ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":22679,"headPos":22645,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ φ) v xs"],"goalsAfter":[],"content":"by rw [BoundedFormula.realize_iff]"},{"tailPos":23110,"headPos":23083,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (ψ ⇔ φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize φ v xs"],"content":"BoundedFormula.realize_iff,"},{"tailPos":23120,"headPos":23111,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize φ v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs"],"content":"Iff.comm,"},{"tailPos":23151,"headPos":23121,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ ψ) v xs"],"content":"← BoundedFormula.realize_iff"},{"tailPos":23152,"headPos":23151,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ ψ) v xs"],"content":"]"},{"tailPos":23152,"headPos":23079,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (ψ ⇔ φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ ψ) v xs"],"content":"rw [BoundedFormula.realize_iff, Iff.comm, ← BoundedFormula.realize_iff]"},{"tailPos":23169,"headPos":23155,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ ψ) v xs"],"goalsAfter":[],"content":"exact h M v xs"},{"tailPos":23169,"headPos":23079,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (ψ ⇔ φ) v xs"],"goalsAfter":[],"content":"rw [BoundedFormula.realize_iff, Iff.comm, ← BoundedFormula.realize_iff]\n  exact h M v xs"},{"tailPos":23076,"headPos":23074,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (ψ ⇔ φ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":23169,"headPos":23074,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (ψ ⇔ φ) v xs"],"goalsAfter":[],"content":"by\n  rw [BoundedFormula.realize_iff, Iff.comm, ← BoundedFormula.realize_iff]\n  exact h M v xs"},{"tailPos":23531,"headPos":23510,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize (φ ⇔ ψ) v xs\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"content":"have h1' := h1 M v xs"},{"tailPos":23555,"headPos":23534,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize (φ ⇔ ψ) v xs\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize (φ ⇔ ψ) v xs\nh2' : BoundedFormula.Realize (ψ ⇔ θ) v xs\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"content":"have h2' := h2 M v xs"},{"tailPos":23588,"headPos":23562,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize (φ ⇔ ψ) v xs\nh2' : BoundedFormula.Realize (ψ ⇔ θ) v xs\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs\nh2' : BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize θ v xs\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize θ v xs"],"content":"BoundedFormula.realize_iff"},{"tailPos":23589,"headPos":23588,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs\nh2' : BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize θ v xs\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize θ v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs\nh2' : BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize θ v xs\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize θ v xs"],"content":"]"},{"tailPos":23594,"headPos":23558,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize (φ ⇔ ψ) v xs\nh2' : BoundedFormula.Realize (ψ ⇔ θ) v xs\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs\nh2' : BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize θ v xs\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize θ v xs"],"content":"rw [BoundedFormula.realize_iff] at *"},{"tailPos":23641,"headPos":23597,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\nh1' : BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize ψ v xs\nh2' : BoundedFormula.Realize ψ v xs ↔ BoundedFormula.Realize θ v xs\n⊢ BoundedFormula.Realize φ v xs ↔ BoundedFormula.Realize θ v xs"],"goalsAfter":[],"content":"exact ⟨h2'.1 ∘ h1'.1, h1'.2 ∘ h2'.2⟩"},{"tailPos":23641,"headPos":23510,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":[],"content":"have h1' := h1 M v xs\n  have h2' := h2 M v xs\n  rw [BoundedFormula.realize_iff] at *\n  exact ⟨h2'.1 ∘ h1'.1, h1'.2 ∘ h2'.2⟩"},{"tailPos":23507,"headPos":23505,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":23641,"headPos":23505,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ θ : BoundedFormula L α n\nh1 : SemanticallyEquivalent T φ ψ\nh2 : SemanticallyEquivalent T ψ θ\nM : ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ BoundedFormula.Realize (φ ⇔ θ) v xs"],"goalsAfter":[],"content":"by\n  have h1' := h1 M v xs\n  have h2' := h2 M v xs\n  rw [BoundedFormula.realize_iff] at *\n  exact ⟨h2'.1 ∘ h1'.1, h1'.2 ∘ h2'.2⟩"},{"tailPos":25186,"headPos":25177,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"content":"simp_rw ["},{"tailPos":25209,"headPos":25186,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ T ⊨ᵇ ∀'φ ⇔ ∀'ψ"],"content":"SemanticallyEquivalent,"},{"tailPos":25231,"headPos":25210,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ T ⊨ᵇ ∀'φ ⇔ ∀'ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (∀'φ ⇔ ∀'ψ) v xs"],"content":"ModelsBoundedFormula,"},{"tailPos":25259,"headPos":25232,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (∀'φ ⇔ ∀'ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (∀'φ) v xs ↔ BoundedFormula.Realize (∀'ψ) v xs"],"content":"BoundedFormula.realize_iff,"},{"tailPos":25290,"headPos":25264,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (∀'φ) v xs ↔ BoundedFormula.Realize (∀'ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    (∀ (a : ↑M), BoundedFormula.Realize φ v (Fin.snoc xs a)) ↔ ∀ (a : ↑M), BoundedFormula.Realize ψ v (Fin.snoc xs a)"],"content":"simp only [BoundedFormula.realize_all]"},{"tailPos":25291,"headPos":25177,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    (∀ (a : ↑M), BoundedFormula.Realize φ v (Fin.snoc xs a)) ↔ ∀ (a : ↑M), BoundedFormula.Realize ψ v (Fin.snoc xs a)"],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_all]"},{"tailPos":25353,"headPos":25294,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    (∀ (a : ↑M), BoundedFormula.Realize φ v (Fin.snoc xs a)) ↔ ∀ (a : ↑M), BoundedFormula.Realize ψ v (Fin.snoc xs a)"],"goalsAfter":[],"content":"exact fun M v xs => forall_congr' fun a => h.realize_bd_iff"},{"tailPos":25353,"headPos":25177,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"goalsAfter":[],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_all]\n  exact fun M v xs => forall_congr' fun a => h.realize_bd_iff"},{"tailPos":25174,"headPos":25172,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"goalsAfter":[],"content":"by"},{"tailPos":25353,"headPos":25172,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∀'φ) (∀'ψ)"],"goalsAfter":[],"content":"by\n  simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_all]\n  exact fun M v xs => forall_congr' fun a => h.realize_bd_iff"},{"tailPos":25651,"headPos":25642,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"content":"simp_rw ["},{"tailPos":25674,"headPos":25651,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ T ⊨ᵇ ∃'φ ⇔ ∃'ψ"],"content":"SemanticallyEquivalent,"},{"tailPos":25696,"headPos":25675,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ T ⊨ᵇ ∃'φ ⇔ ∃'ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (∃'φ ⇔ ∃'ψ) v xs"],"content":"ModelsBoundedFormula,"},{"tailPos":25724,"headPos":25697,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (∃'φ ⇔ ∃'ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (∃'φ) v xs ↔ BoundedFormula.Realize (∃'ψ) v xs"],"content":"BoundedFormula.realize_iff,"},{"tailPos":25754,"headPos":25729,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (∃'φ) v xs ↔ BoundedFormula.Realize (∃'ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    (∃ a, BoundedFormula.Realize φ v (Fin.snoc xs a)) ↔ ∃ a, BoundedFormula.Realize ψ v (Fin.snoc xs a)"],"content":"simp only [BoundedFormula.realize_ex]"},{"tailPos":25755,"headPos":25642,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    (∃ a, BoundedFormula.Realize φ v (Fin.snoc xs a)) ↔ ∃ a, BoundedFormula.Realize ψ v (Fin.snoc xs a)"],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_ex]"},{"tailPos":25816,"headPos":25758,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    (∃ a, BoundedFormula.Realize φ v (Fin.snoc xs a)) ↔ ∃ a, BoundedFormula.Realize ψ v (Fin.snoc xs a)"],"goalsAfter":[],"content":"exact fun M v xs => exists_congr fun a => h.realize_bd_iff"},{"tailPos":25816,"headPos":25642,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"goalsAfter":[],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_ex]\n  exact fun M v xs => exists_congr fun a => h.realize_bd_iff"},{"tailPos":25639,"headPos":25637,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"goalsAfter":[],"content":"by"},{"tailPos":25816,"headPos":25637,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α (n + 1)\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∃'φ) (∃'ψ)"],"goalsAfter":[],"content":"by\n  simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_ex]\n  exact fun M v xs => exists_congr fun a => h.realize_bd_iff"},{"tailPos":26109,"headPos":26100,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"content":"simp_rw ["},{"tailPos":26132,"headPos":26109,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ T ⊨ᵇ ∼φ ⇔ ∼ψ"],"content":"SemanticallyEquivalent,"},{"tailPos":26154,"headPos":26133,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ T ⊨ᵇ ∼φ ⇔ ∼ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (∼φ ⇔ ∼ψ) v xs"],"content":"ModelsBoundedFormula,"},{"tailPos":26182,"headPos":26155,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (∼φ ⇔ ∼ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (∼φ) v xs ↔ BoundedFormula.Realize (∼ψ) v xs"],"content":"BoundedFormula.realize_iff,"},{"tailPos":26213,"headPos":26187,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (∼φ) v xs ↔ BoundedFormula.Realize (∼ψ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), ¬BoundedFormula.Realize φ v xs ↔ ¬BoundedFormula.Realize ψ v xs"],"content":"simp only [BoundedFormula.realize_not]"},{"tailPos":26214,"headPos":26100,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), ¬BoundedFormula.Realize φ v xs ↔ ¬BoundedFormula.Realize ψ v xs"],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_not]"},{"tailPos":26263,"headPos":26217,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), ¬BoundedFormula.Realize φ v xs ↔ ¬BoundedFormula.Realize ψ v xs"],"goalsAfter":[],"content":"exact fun M v xs => not_congr h.realize_bd_iff"},{"tailPos":26263,"headPos":26100,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"goalsAfter":[],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_not]\n  exact fun M v xs => not_congr h.realize_bd_iff"},{"tailPos":26097,"headPos":26095,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"goalsAfter":[],"content":"by"},{"tailPos":26263,"headPos":26095,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\n⊢ SemanticallyEquivalent T (∼φ) ∼ψ"],"goalsAfter":[],"content":"by\n  simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_not]\n  exact fun M v xs => not_congr h.realize_bd_iff"},{"tailPos":26622,"headPos":26613,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"content":"simp_rw ["},{"tailPos":26645,"headPos":26622,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ T ⊨ᵇ φ ⟹ φ' ⇔ ψ ⟹ ψ'"],"content":"SemanticallyEquivalent,"},{"tailPos":26667,"headPos":26646,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ T ⊨ᵇ φ ⟹ φ' ⇔ ψ ⟹ ψ'"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (φ ⟹ φ' ⇔ ψ ⟹ ψ') v xs"],"content":"ModelsBoundedFormula,"},{"tailPos":26695,"headPos":26668,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M), BoundedFormula.Realize (φ ⟹ φ' ⇔ ψ ⟹ ψ') v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (φ ⟹ φ') v xs ↔ BoundedFormula.Realize (ψ ⟹ ψ') v xs"],"content":"BoundedFormula.realize_iff,"},{"tailPos":26726,"headPos":26700,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize (φ ⟹ φ') v xs ↔ BoundedFormula.Realize (ψ ⟹ ψ') v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize φ v xs → BoundedFormula.Realize φ' v xs ↔\n      BoundedFormula.Realize ψ v xs → BoundedFormula.Realize ψ' v xs"],"content":"simp only [BoundedFormula.realize_imp]"},{"tailPos":26727,"headPos":26613,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize φ v xs → BoundedFormula.Realize φ' v xs ↔\n      BoundedFormula.Realize ψ v xs → BoundedFormula.Realize ψ' v xs"],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_imp]"},{"tailPos":26794,"headPos":26730,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ ∀ (M : ModelType T) (v : α → ↑M) (xs : Fin n → ↑M),\n    BoundedFormula.Realize φ v xs → BoundedFormula.Realize φ' v xs ↔\n      BoundedFormula.Realize ψ v xs → BoundedFormula.Realize ψ' v xs"],"goalsAfter":[],"content":"exact fun M v xs => imp_congr h.realize_bd_iff h'.realize_bd_iff"},{"tailPos":26794,"headPos":26613,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"goalsAfter":[],"content":"simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_imp]\n  exact fun M v xs => imp_congr h.realize_bd_iff h'.realize_bd_iff"},{"tailPos":26610,"headPos":26608,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"goalsAfter":[],"content":"by"},{"tailPos":26794,"headPos":26608,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ φ' ψ' : BoundedFormula L α n\nh : SemanticallyEquivalent T φ ψ\nh' : SemanticallyEquivalent T φ' ψ'\n⊢ SemanticallyEquivalent T (φ ⟹ φ') (ψ ⟹ ψ')"],"goalsAfter":[],"content":"by\n  simp_rw [SemanticallyEquivalent, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_imp]\n  exact fun M v xs => imp_congr h.realize_bd_iff h'.realize_bd_iff"},{"tailPos":27338,"headPos":27329,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ completeTheory L M ∨ Formula.not φ ∈ completeTheory L M"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ completeTheory L M ∨ Formula.not φ ∈ completeTheory L M"],"content":"simp_rw ["},{"tailPos":27353,"headPos":27338,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ completeTheory L M ∨ Formula.not φ ∈ completeTheory L M"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ {φ | M ⊨ φ} ∨ Formula.not φ ∈ {φ | M ⊨ φ}"],"content":"completeTheory,"},{"tailPos":27371,"headPos":27354,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ {φ | M ⊨ φ} ∨ Formula.not φ ∈ {φ | M ⊨ φ}"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ M ⊨ φ ∨ M ⊨ Formula.not φ"],"content":"Set.mem_setOf_eq,"},{"tailPos":27389,"headPos":27372,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ M ⊨ φ ∨ M ⊨ Formula.not φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ Formula.Realize φ default ∨ Formula.Realize (Formula.not φ) default"],"content":"Sentence.Realize,"},{"tailPos":27410,"headPos":27390,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ Formula.Realize φ default ∨ Formula.Realize (Formula.not φ) default"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ Formula.Realize φ default ∨ ¬Formula.Realize φ default"],"content":"Formula.realize_not,"},{"tailPos":27417,"headPos":27411,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ Formula.Realize φ default ∨ ¬Formula.Realize φ default"],"goalsAfter":[],"content":"simp only [or_not]"},{"tailPos":27418,"headPos":27329,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ completeTheory L M ∨ Formula.not φ ∈ completeTheory L M"],"goalsAfter":[],"content":"simp_rw [completeTheory, Set.mem_setOf_eq, Sentence.Realize, Formula.realize_not, or_not]"},{"tailPos":27326,"headPos":27324,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ completeTheory L M ∨ Formula.not φ ∈ completeTheory L M"],"goalsAfter":[],"content":"by"},{"tailPos":27418,"headPos":27324,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nM : Type w\ninst✝ : Structure L M\nφ : Sentence L\n⊢ φ ∈ completeTheory L M ∨ Formula.not φ ∈ completeTheory L M"],"goalsAfter":[],"content":"by\n  simp_rw [completeTheory, Set.mem_setOf_eq, Sentence.Realize, Formula.realize_not, or_not]"},{"tailPos":28153,"headPos":28149,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∼∼φ) v xs"],"goalsAfter":[],"content":"simp only [realize_iff, realize_not, not_not]"},{"tailPos":28146,"headPos":28144,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∼∼φ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":28153,"headPos":28144,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∼∼φ) v xs"],"goalsAfter":[],"content":"by\n  simp"},{"tailPos":28438,"headPos":28417,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⟹ ψ ⇔ ∼φ ⊔ ψ) v xs"],"goalsAfter":[],"content":"simp [imp_iff_not_or]"},{"tailPos":28416,"headPos":28414,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⟹ ψ ⇔ ∼φ ⊔ ψ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":28438,"headPos":28414,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⟹ ψ ⇔ ∼φ ⊔ ψ) v xs"],"goalsAfter":[],"content":"by simp [imp_iff_not_or]"},{"tailPos":28745,"headPos":28724,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⊔ ψ ⇔ ∼(∼φ ⊓ ∼ψ)) v xs"],"goalsAfter":[],"content":"simp [imp_iff_not_or]"},{"tailPos":28723,"headPos":28721,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⊔ ψ ⇔ ∼(∼φ ⊓ ∼ψ)) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":28745,"headPos":28721,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⊔ ψ ⇔ ∼(∼φ ⊓ ∼ψ)) v xs"],"goalsAfter":[],"content":"by simp [imp_iff_not_or]"},{"tailPos":29066,"headPos":29041,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⊓ ψ ⇔ ∼(∼φ ⊔ ∼ψ)) v xs"],"goalsAfter":[],"content":"simp [and_iff_not_or_not]"},{"tailPos":29038,"headPos":29036,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⊓ ψ ⇔ ∼(∼φ ⊔ ∼ψ)) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":29066,"headPos":29036,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⊓ ψ ⇔ ∼(∼φ ⊔ ∼ψ)) v xs"],"goalsAfter":[],"content":"by\n  simp [and_iff_not_or_not]"},{"tailPos":29383,"headPos":29379,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ✝ ψ : BoundedFormula L α n\nφ : BoundedFormula L α (n + 1)\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (∀'φ ⇔ ∼(∃'∼φ)) v xs"],"goalsAfter":[],"content":"simp only [realize_iff, realize_all, realize_not, realize_ex, not_exists, not_not]"},{"tailPos":29378,"headPos":29376,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ✝ ψ : BoundedFormula L α n\nφ : BoundedFormula L α (n + 1)\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (∀'φ ⇔ ∼(∃'∼φ)) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":29383,"headPos":29376,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ✝ ψ : BoundedFormula L α n\nφ : BoundedFormula L α (n + 1)\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (∀'φ ⇔ ∼(∃'∼φ)) v xs"],"goalsAfter":[],"content":"by simp"},{"tailPos":29698,"headPos":29694,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ✝ ψ : BoundedFormula L α n\nφ : BoundedFormula L α (n + 1)\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (∃'φ ⇔ ∼(∀'∼φ)) v xs"],"goalsAfter":[],"content":"simp only [realize_iff, realize_ex, realize_not, realize_all, not_forall, not_not]"},{"tailPos":29693,"headPos":29691,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ✝ ψ : BoundedFormula L α n\nφ : BoundedFormula L α (n + 1)\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (∃'φ ⇔ ∼(∀'∼φ)) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":29698,"headPos":29691,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ✝ ψ : BoundedFormula L α n\nφ : BoundedFormula L α (n + 1)\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (∃'φ ⇔ ∼(∀'∼φ)) v xs"],"goalsAfter":[],"content":"by simp"},{"tailPos":29976,"headPos":29972,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"content":"skip"},{"tailPos":29995,"headPos":29983,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize (∀'liftAt 1 n φ) v xs"],"content":"realize_iff,"},{"tailPos":30023,"headPos":29996,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize (∀'liftAt 1 n φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize φ v xs"],"content":"realize_all_liftAt_one_self"},{"tailPos":30024,"headPos":30023,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize φ v xs"],"goalsAfter":[],"content":"]"},{"tailPos":30024,"headPos":29979,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"goalsAfter":[],"content":"rw [realize_iff, realize_all_liftAt_one_self]"},{"tailPos":30024,"headPos":29972,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"goalsAfter":[],"content":"skip\n  rw [realize_iff, realize_all_liftAt_one_self]"},{"tailPos":29969,"headPos":29967,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":30024,"headPos":29967,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ ψ : BoundedFormula L α n\nM : Theory.ModelType T\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ ∀'liftAt 1 n φ) v xs"],"goalsAfter":[],"content":"by\n  skip\n  rw [realize_iff, realize_all_liftAt_one_self]"},{"tailPos":33225,"headPos":33213,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ toPrenex φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize (toPrenex φ) v xs"],"content":"realize_iff,"},{"tailPos":33242,"headPos":33226,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize (toPrenex φ) v xs"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize φ v xs"],"content":"realize_toPrenex"},{"tailPos":33243,"headPos":33242,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize φ v xs ↔ Realize φ v xs"],"goalsAfter":[],"content":"]"},{"tailPos":33243,"headPos":33209,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ toPrenex φ) v xs"],"goalsAfter":[],"content":"rw [realize_iff, realize_toPrenex]"},{"tailPos":33206,"headPos":33204,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ toPrenex φ) v xs"],"goalsAfter":[],"content":"by"},{"tailPos":33243,"headPos":33204,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nφ : BoundedFormula L α n\nM : Theory.ModelType ∅\nv : α → ↑M\nxs : Fin n → ↑M\n⊢ Realize (φ ⇔ toPrenex φ) v xs"],"goalsAfter":[],"content":"by\n  rw [realize_iff, realize_toPrenex]"},{"tailPos":33936,"headPos":33864,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ P φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nh' : ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ\n⊢ P φ","case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ"],"content":"suffices h' : ∀ {m} {φ : L.BoundedFormula α m}, φ.IsPrenex → P φ"},{"tailPos":33941,"headPos":33939,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nh' : ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ\n⊢ P φ","case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ"],"goalsAfter":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nh' : ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ\n⊢ P φ"],"content":"·"},{"tailPos":34016,"headPos":33942,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nh' : ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ\n⊢ P φ"],"goalsAfter":[],"content":"exact (hse φ.semanticallyEquivalent_toPrenex).2 (h' φ.toPrenex_isPrenex)"},{"tailPos":34016,"headPos":33939,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nh' : ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ\n⊢ P φ","case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ"],"goalsAfter":["case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ"],"content":"· exact (hse φ.semanticallyEquivalent_toPrenex).2 (h' φ.toPrenex_isPrenex)"},{"tailPos":34033,"headPos":34019,"goalsBefore":["case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ ∀ {m : ℕ} {φ : BoundedFormula L α m}, IsPrenex φ → P φ"],"goalsAfter":["case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nhφ : IsPrenex φ\n⊢ P φ"],"content":"intro m φ hφ"},{"tailPos":34083,"headPos":34036,"goalsBefore":["case h'\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nhφ : IsPrenex φ\n⊢ P φ"],"goalsAfter":["case h'.of_isQF\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α n✝\nhφ : IsQF φ✝\n⊢ P φ✝","case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)","case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"content":"induction' hφ with _ _ hφ _ _ _ hφ _ _ _ hφ"},{"tailPos":34088,"headPos":34086,"goalsBefore":["case h'.of_isQF\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α n✝\nhφ : IsQF φ✝\n⊢ P φ✝","case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)","case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":["case h'.of_isQF\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α n✝\nhφ : IsQF φ✝\n⊢ P φ✝"],"content":"·"},{"tailPos":34102,"headPos":34089,"goalsBefore":["case h'.of_isQF\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α n✝\nhφ : IsQF φ✝\n⊢ P φ✝"],"goalsAfter":[],"content":"exact hqf hφ"},{"tailPos":34102,"headPos":34086,"goalsBefore":["case h'.of_isQF\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α n✝\nhφ : IsQF φ✝\n⊢ P φ✝","case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)","case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":["case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)","case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"content":"· exact hqf hφ"},{"tailPos":34107,"headPos":34105,"goalsBefore":["case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)","case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":["case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)"],"content":"·"},{"tailPos":34122,"headPos":34108,"goalsBefore":["case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)"],"goalsAfter":[],"content":"exact hall hφ"},{"tailPos":34122,"headPos":34105,"goalsBefore":["case h'.all\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∀'φ✝)","case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":["case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"content":"· exact hall hφ"},{"tailPos":34127,"headPos":34125,"goalsBefore":["case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":["case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"content":"·"},{"tailPos":34141,"headPos":34128,"goalsBefore":["case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":[],"content":"exact hex hφ"},{"tailPos":34141,"headPos":34125,"goalsBefore":["case h'.ex\nL : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ✝¹ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\nm : ℕ\nφ : BoundedFormula L α m\nn✝ : ℕ\nφ✝ : BoundedFormula L α (n✝ + 1)\nh✝ : IsPrenex φ✝\nhφ : P φ✝\n⊢ P (∃'φ✝)"],"goalsAfter":[],"content":"· exact hex hφ"},{"tailPos":34141,"headPos":33864,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ P φ"],"goalsAfter":[],"content":"suffices h' : ∀ {m} {φ : L.BoundedFormula α m}, φ.IsPrenex → P φ\n  · exact (hse φ.semanticallyEquivalent_toPrenex).2 (h' φ.toPrenex_isPrenex)\n  intro m φ hφ\n  induction' hφ with _ _ hφ _ _ _ hφ _ _ _ hφ\n  · exact hqf hφ\n  · exact hall hφ\n  · exact hex hφ"},{"tailPos":33861,"headPos":33859,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ P φ"],"goalsAfter":[],"content":"by"},{"tailPos":34141,"headPos":33859,"goalsBefore":["L : Language\nT : Theory L\nα : Type w\nn : ℕ\nP : {m : ℕ} → BoundedFormula L α m → Prop\nφ : BoundedFormula L α n\nhqf : ∀ {m : ℕ} {ψ : BoundedFormula L α m}, IsQF ψ → P ψ\nhall : ∀ {m : ℕ} {ψ : BoundedFormula L α (m + 1)}, P ψ → P (∀'ψ)\nhex : ∀ {m : ℕ} {φ : BoundedFormula L α (m + 1)}, P φ → P (∃'φ)\nhse : ∀ {m : ℕ} {φ₁ φ₂ : BoundedFormula L α m}, Theory.SemanticallyEquivalent ∅ φ₁ φ₂ → (P φ₁ ↔ P φ₂)\n⊢ P φ"],"goalsAfter":[],"content":"by\n  suffices h' : ∀ {m} {φ : L.BoundedFormula α m}, φ.IsPrenex → P φ\n  · exact (hse φ.semanticallyEquivalent_toPrenex).2 (h' φ.toPrenex_isPrenex)\n  intro m φ hφ\n  induction' hφ with _ _ hφ _ _ _ hφ _ _ _ hφ\n  · exact hqf hφ\n  · exact hall hφ\n  · exact hex hφ"},{"tailPos":35888,"headPos":35805,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"content":"obtain ⟨_, _⟩ := Theory.exists_model_card_eq ⟨hS.some, hT hS.some⟩ κ h1 h2"},{"tailPos":35924,"headPos":35897,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ T ⊨ᵇ Formula.not φ"],"content":"Theory.models_sentence_iff,"},{"tailPos":35951,"headPos":35925,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ"],"content":"Theory.models_sentence_iff"},{"tailPos":35952,"headPos":35951,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ"],"content":"]"},{"tailPos":35952,"headPos":35893,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ"],"content":"rw [Theory.models_sentence_iff, Theory.models_sentence_iff]"},{"tailPos":35970,"headPos":35957,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\n⊢ (∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\ncon : ¬((∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ)\n⊢ False"],"content":"by_contra con"},{"tailPos":35991,"headPos":35975,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\ncon : ¬((∀ (M : Theory.ModelType T), ↑M ⊨ φ) ∨ ∀ (M : Theory.ModelType T), ↑M ⊨ Formula.not φ)\n⊢ False"],"goalsAfter":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\ncon : (∃ M, ¬↑M ⊨ φ) ∧ ∃ M, ¬↑M ⊨ Formula.not φ\n⊢ False"],"content":"push_neg  at con"},{"tailPos":36038,"headPos":35996,"goalsBefore":["case intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\ncon : (∃ M, ¬↑M ⊨ φ) ∧ ∃ M, ¬↑M ⊨ Formula.not φ\n⊢ False"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ¬↑MT ⊨ Formula.not φ\n⊢ False"],"content":"obtain ⟨⟨MF, hMF⟩, MT, hMT⟩ := con"},{"tailPos":36068,"headPos":36047,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ¬↑MT ⊨ Formula.not φ\n⊢ False"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ¬¬↑MT ⊨ φ\n⊢ False"],"content":"Sentence.realize_not,"},{"tailPos":36086,"headPos":36069,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ¬¬↑MT ⊨ φ\n⊢ False"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ False"],"content":"Classical.not_not"},{"tailPos":36087,"headPos":36086,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ False"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ False"],"content":"]"},{"tailPos":36094,"headPos":36043,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ¬↑MT ⊨ Formula.not φ\n⊢ False"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ False"],"content":"rw [Sentence.realize_not, Classical.not_not] at hMT"},{"tailPos":36112,"headPos":36099,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ False"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ ↑MF ⊨ φ"],"content":"refine' hMF _"},{"tailPos":36131,"headPos":36117,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\n⊢ ↑MF ⊨ φ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis : Infinite ↑MT\n⊢ ↑MF ⊨ φ"],"content":"haveI := hT MT"},{"tailPos":36150,"headPos":36136,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis : Infinite ↑MT\n⊢ ↑MF ⊨ φ"],"goalsAfter":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\n⊢ ↑MF ⊨ φ"],"content":"haveI := hT MF"},{"tailPos":36235,"headPos":36155,"goalsBefore":["case intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\n⊢ ↑MF ⊨ φ"],"goalsAfter":["case intro.intro.intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\nNT : Bundled (Structure L)\nMNT : ↑MT ≅[L] ↑NT\nhNT : (#↑NT) = κ\n⊢ ↑MF ⊨ φ"],"content":"obtain ⟨NT, MNT, hNT⟩ := exists_elementarilyEquivalent_card_eq L MT κ h1 h2"},{"tailPos":36320,"headPos":36240,"goalsBefore":["case intro.intro.intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\nNT : Bundled (Structure L)\nMNT : ↑MT ≅[L] ↑NT\nhNT : (#↑NT) = κ\n⊢ ↑MF ⊨ φ"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\nNT : Bundled (Structure L)\nMNT : ↑MT ≅[L] ↑NT\nhNT : (#↑NT) = κ\nNF : Bundled (Structure L)\nMNF : ↑MF ≅[L] ↑NF\nhNF : (#↑NF) = κ\n⊢ ↑MF ⊨ φ"],"content":"obtain ⟨NF, MNF, hNF⟩ := exists_elementarilyEquivalent_card_eq L MF κ h1 h2"},{"tailPos":36385,"headPos":36325,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\nNT : Bundled (Structure L)\nMNT : ↑MT ≅[L] ↑NT\nhNT : (#↑NT) = κ\nNF : Bundled (Structure L)\nMNF : ↑MF ≅[L] ↑NF\nhNF : (#↑NF) = κ\n⊢ ↑MF ⊨ φ"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\nNT : Bundled (Structure L)\nMNT : ↑MT ≅[L] ↑NT\nhNT : (#↑NT) = κ\nNF : Bundled (Structure L)\nMNF : ↑MF ≅[L] ↑NF\nhNF : (#↑NF) = κ\nTF : ↑(ElementarilyEquivalent.toModel T MNT) ≃[L] ↑(ElementarilyEquivalent.toModel T MNF)\n⊢ ↑MF ⊨ φ"],"content":"obtain ⟨TF⟩ := h (MNT.toModel T) (MNF.toModel T) hNT hNF"},{"tailPos":36513,"headPos":36390,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro\nL : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\nw✝ : Theory.ModelType T\nh✝ : (#↑w✝) = κ\nMF : Theory.ModelType T\nhMF : ¬↑MF ⊨ φ\nMT : Theory.ModelType T\nhMT : ↑MT ⊨ φ\nthis✝ : Infinite ↑MT\nthis : Infinite ↑MF\nNT : Bundled (Structure L)\nMNT : ↑MT ≅[L] ↑NT\nhNT : (#↑NT) = κ\nNF : Bundled (Structure L)\nMNF : ↑MF ≅[L] ↑NF\nhNF : (#↑NF) = κ\nTF : ↑(ElementarilyEquivalent.toModel T MNT) ≃[L] ↑(ElementarilyEquivalent.toModel T MNF)\n⊢ ↑MF ⊨ φ"],"goalsAfter":[],"content":"exact\n      ((MNT.realize_sentence φ).trans\n        ((TF.realize_sentence φ).trans (MNF.realize_sentence φ).symm)).1 hMT"},{"tailPos":36513,"headPos":35805,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":[],"content":"obtain ⟨_, _⟩ := Theory.exists_model_card_eq ⟨hS.some, hT hS.some⟩ κ h1 h2\n    rw [Theory.models_sentence_iff, Theory.models_sentence_iff]\n    by_contra con\n    push_neg  at con\n    obtain ⟨⟨MF, hMF⟩, MT, hMT⟩ := con\n    rw [Sentence.realize_not, Classical.not_not] at hMT\n    refine' hMF _\n    haveI := hT MT\n    haveI := hT MF\n    obtain ⟨NT, MNT, hNT⟩ := exists_elementarilyEquivalent_card_eq L MT κ h1 h2\n    obtain ⟨NF, MNF, hNF⟩ := exists_elementarilyEquivalent_card_eq L MF κ h1 h2\n    obtain ⟨TF⟩ := h (MNT.toModel T) (MNF.toModel T) hNT hNF\n    exact\n      ((MNT.realize_sentence φ).trans\n        ((TF.realize_sentence φ).trans (MNF.realize_sentence φ).symm)).1 hMT"},{"tailPos":35800,"headPos":35798,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":[],"content":"by"},{"tailPos":36513,"headPos":35798,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\nh : Categorical κ T\nh1 : ℵ₀ ≤ κ\nh2 : lift (card L) ≤ lift κ\nhS : Theory.IsSatisfiable T\nhT : ∀ (M : Theory.ModelType T), Infinite ↑M\nφ : Sentence L\n⊢ T ⊨ᵇ φ ∨ T ⊨ᵇ Formula.not φ"],"goalsAfter":[],"content":"by\n    obtain ⟨_, _⟩ := Theory.exists_model_card_eq ⟨hS.some, hT hS.some⟩ κ h1 h2\n    rw [Theory.models_sentence_iff, Theory.models_sentence_iff]\n    by_contra con\n    push_neg  at con\n    obtain ⟨⟨MF, hMF⟩, MT, hMT⟩ := con\n    rw [Sentence.realize_not, Classical.not_not] at hMT\n    refine' hMF _\n    haveI := hT MT\n    haveI := hT MF\n    obtain ⟨NT, MNT, hNT⟩ := exists_elementarilyEquivalent_card_eq L MT κ h1 h2\n    obtain ⟨NF, MNF, hNF⟩ := exists_elementarilyEquivalent_card_eq L MF κ h1 h2\n    obtain ⟨TF⟩ := h (MNT.toModel T) (MNF.toModel T) hNT hNF\n    exact\n      ((MNT.realize_sentence φ).trans\n        ((TF.realize_sentence φ).trans (MNF.realize_sentence φ).symm)).1 hMT"},{"tailPos":36724,"headPos":36699,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ Nonempty (↑M ≃[Language.empty] ↑N)"],"goalsAfter":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ lift (#↑M) = lift (#↑N)"],"content":"empty.nonempty_equiv_iff,"},{"tailPos":36728,"headPos":36725,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ lift (#↑M) = lift (#↑N)"],"goalsAfter":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ lift κ = lift (#↑N)"],"content":"hM,"},{"tailPos":36731,"headPos":36729,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ lift κ = lift (#↑N)"],"goalsAfter":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ lift κ = lift κ"],"content":"hN"},{"tailPos":36732,"headPos":36731,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ lift κ = lift κ"],"goalsAfter":[],"content":"]"},{"tailPos":36732,"headPos":36695,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ Nonempty (↑M ≃[Language.empty] ↑N)"],"goalsAfter":[],"content":"rw [empty.nonempty_equiv_iff, hM, hN]"},{"tailPos":36694,"headPos":36692,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ Nonempty (↑M ≃[Language.empty] ↑N)"],"goalsAfter":[],"content":"by"},{"tailPos":36732,"headPos":36692,"goalsBefore":["L : Language\nκ : Cardinal\nT✝ : Theory L\nT : Theory Language.empty\nM N : Theory.ModelType T\nhM : (#↑M) = κ\nhN : (#↑N) = κ\n⊢ Nonempty (↑M ≃[Language.empty] ↑N)"],"goalsAfter":[],"content":"by rw [empty.nonempty_equiv_iff, hM, hN]"},{"tailPos":36973,"headPos":36969,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\n⊢ lift (card Language.empty) ≤ lift ℵ₀"],"goalsAfter":[],"content":"simp only [empty_card, lift_id', zero_le]"},{"tailPos":36968,"headPos":36966,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\n⊢ lift (card Language.empty) ≤ lift ℵ₀"],"goalsAfter":[],"content":"by"},{"tailPos":36973,"headPos":36966,"goalsBefore":["L : Language\nκ : Cardinal\nT : Theory L\n⊢ lift (card Language.empty) ≤ lift ℵ₀"],"goalsAfter":[],"content":"by simp"}]
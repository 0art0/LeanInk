[{"tailPos":2771,"headPos":2637,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind l listEncode) = List.map some l","case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"content":"suffices h : ∀ (t : L.Term α) (l : List (Sum α (Σi, L.Functions i))),\n      listDecode (t.listEncode ++ l) = some t::listDecode l"},{"tailPos":2776,"headPos":2774,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind l listEncode) = List.map some l","case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"content":"·"},{"tailPos":2802,"headPos":2777,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind [] listEncode) = List.map some []","case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"content":"induction' l with t l lih"},{"tailPos":2809,"headPos":2807,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind [] listEncode) = List.map some []","case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind [] listEncode) = List.map some []"],"content":"·"},{"tailPos":2813,"headPos":2810,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind [] listEncode) = List.map some []"],"goalsAfter":[],"content":"rfl"},{"tailPos":2813,"headPos":2807,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind [] listEncode) = List.map some []","case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"content":"· rfl"},{"tailPos":2820,"headPos":2818,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"content":"·"},{"tailPos":2835,"headPos":2825,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (listEncode t ++ List.bind l listEncode) = List.map some (t :: l)"],"content":"cons_bind,"},{"tailPos":2860,"headPos":2836,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (listEncode t ++ List.bind l listEncode) = List.map some (t :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ some t :: listDecode (List.bind l listEncode) = List.map some (t :: l)"],"content":"h t (l.bind listEncode),"},{"tailPos":2865,"headPos":2861,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ some t :: listDecode (List.bind l listEncode) = List.map some (t :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ some t :: List.map some l = List.map some (t :: l)"],"content":"lih,"},{"tailPos":2874,"headPos":2866,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ some t :: List.map some l = List.map some (t :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ some t :: List.map some l = some t :: List.map some l"],"content":"List.map"},{"tailPos":2875,"headPos":2874,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ some t :: List.map some l = some t :: List.map some l"],"goalsAfter":[],"content":"]"},{"tailPos":2875,"headPos":2821,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"goalsAfter":[],"content":"rw [cons_bind, h t (l.bind listEncode), lih, List.map]"},{"tailPos":2875,"headPos":2818,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\nt : Term L α\nl : List (Term L α)\nlih : listDecode (List.bind l listEncode) = List.map some l\n⊢ listDecode (List.bind (t :: l) listEncode) = List.map some (t :: l)"],"goalsAfter":[],"content":"· rw [cons_bind, h t (l.bind listEncode), lih, List.map]"},{"tailPos":2875,"headPos":2777,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"goalsAfter":[],"content":"induction' l with t l lih\n    · rfl\n    · rw [cons_bind, h t (l.bind listEncode), lih, List.map]"},{"tailPos":2875,"headPos":2774,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nh : ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l\n⊢ listDecode (List.bind l listEncode) = List.map some l","case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"content":"· induction' l with t l lih\n    · rfl\n    · rw [cons_bind, h t (l.bind listEncode), lih, List.map]"},{"tailPos":2880,"headPos":2878,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"content":"·"},{"tailPos":2888,"headPos":2881,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nt : Term L α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"content":"intro t"},{"tailPos":2922,"headPos":2893,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nt : Term L α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\na : α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l","case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"content":"induction' t with a n f ts ih"},{"tailPos":2926,"headPos":2923,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\na : α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l","case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\na : α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l","case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"content":"<;>"},{"tailPos":2934,"headPos":2927,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\na : α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l"],"content":"intro l"},{"tailPos":2934,"headPos":2927,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"content":"intro l"},{"tailPos":2934,"headPos":2893,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\nt : Term L α\n⊢ ∀ (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l","case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"content":"induction' t with a n f ts ih <;> intro l"},{"tailPos":2941,"headPos":2939,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l","case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l"],"content":"·"},{"tailPos":2957,"headPos":2946,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ([Sum.inl a] ++ l) = some (var a) :: listDecode l"],"content":"listEncode,"},{"tailPos":2975,"headPos":2958,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ([Sum.inl a] ++ l) = some (var a) :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (Sum.inl a :: l) = some (var a) :: listDecode l"],"content":"singleton_append,"},{"tailPos":2986,"headPos":2976,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (Sum.inl a :: l) = some (var a) :: listDecode l"],"goalsAfter":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ some (var a) :: listDecode l = some (var a) :: listDecode l"],"content":"listDecode"},{"tailPos":2987,"headPos":2986,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ some (var a) :: listDecode l = some (var a) :: listDecode l"],"goalsAfter":[],"content":"]"},{"tailPos":2987,"headPos":2942,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l"],"goalsAfter":[],"content":"rw [listEncode, singleton_append, listDecode]"},{"tailPos":2987,"headPos":2939,"goalsBefore":["case h.var\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\na : α\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (var a) ++ l) = some (var a) :: listDecode l","case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"content":"· rw [listEncode, singleton_append, listDecode]"},{"tailPos":2994,"headPos":2992,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"content":"·"},{"tailPos":3010,"headPos":2999,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((Sum.inr { fst := n, snd := f } :: List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    some (func f ts) :: listDecode l"],"content":"listEncode,"},{"tailPos":3023,"headPos":3011,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((Sum.inr { fst := n, snd := f } :: List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (Sum.inr { fst := n, snd := f } :: ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"content":"cons_append,"},{"tailPos":3034,"headPos":3024,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (Sum.inr { fst := n, snd := f } :: ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"content":"listDecode"},{"tailPos":3035,"headPos":3034,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"content":"]"},{"tailPos":3035,"headPos":2995,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"content":"rw [listEncode, cons_append, listDecode]"},{"tailPos":3240,"headPos":3204,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind [] fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) [] ++ listDecode l","case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"content":"induction' finRange n with i l' l'ih"},{"tailPos":3251,"headPos":3249,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind [] fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) [] ++ listDecode l","case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind [] fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) [] ++ listDecode l"],"content":"·"},{"tailPos":3255,"headPos":3252,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind [] fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) [] ++ listDecode l"],"goalsAfter":[],"content":"rfl"},{"tailPos":3255,"headPos":3249,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind [] fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) [] ++ listDecode l","case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"content":"· rfl"},{"tailPos":3266,"headPos":3264,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"content":"·"},{"tailPos":3281,"headPos":3271,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((listEncode (ts i) ++ List.bind l' fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (i :: l') ++ listDecode l"],"content":"cons_bind,"},{"tailPos":3300,"headPos":3282,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((listEncode (ts i) ++ List.bind l' fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode (listEncode (ts i) ++ ((List.bind l' fun i => listEncode (ts i)) ++ l)) =\n    List.map (some ∘ ts) (i :: l') ++ listDecode l"],"content":"List.append_assoc,"},{"tailPos":3304,"headPos":3301,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode (listEncode (ts i) ++ ((List.bind l' fun i => listEncode (ts i)) ++ l)) =\n    List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (i :: l') ++ listDecode l"],"content":"ih,"},{"tailPos":3314,"headPos":3305,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) =\n    (some ∘ ts) i :: List.map (some ∘ ts) l' ++ listDecode l"],"content":"map_cons,"},{"tailPos":3320,"headPos":3315,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) =\n    (some ∘ ts) i :: List.map (some ∘ ts) l' ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l) = (some ∘ ts) i :: List.map (some ∘ ts) l' ++ listDecode l"],"content":"l'ih,"},{"tailPos":3333,"headPos":3321,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l) = (some ∘ ts) i :: List.map (some ∘ ts) l' ++ listDecode l"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l) = (some ∘ ts) i :: (List.map (some ∘ ts) l' ++ listDecode l)"],"content":"cons_append,"},{"tailPos":3347,"headPos":3334,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l) = (some ∘ ts) i :: (List.map (some ∘ ts) l' ++ listDecode l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l) = some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l)"],"content":"Function.comp"},{"tailPos":3348,"headPos":3347,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l) = some (ts i) :: (List.map (some ∘ ts) l' ++ listDecode l)"],"goalsAfter":[],"content":"]"},{"tailPos":3348,"headPos":3267,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":[],"content":"rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]"},{"tailPos":3348,"headPos":3264,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\ni : Fin n\nl' : List (Fin n)\nl'ih : listDecode ((List.bind l' fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) l' ++ listDecode l\n⊢ listDecode ((List.bind (i :: l') fun i => listEncode (ts i)) ++ l) = List.map (some ∘ ts) (i :: l') ++ listDecode l"],"goalsAfter":[],"content":"· rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]"},{"tailPos":3348,"headPos":3204,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l"],"goalsAfter":[],"content":"induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]"},{"tailPos":3195,"headPos":3193,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l"],"goalsAfter":[],"content":"by"},{"tailPos":3348,"headPos":3193,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l"],"goalsAfter":[],"content":"by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]"},{"tailPos":3348,"headPos":3042,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"content":"have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]"},{"tailPos":3529,"headPos":3522,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\n⊢ ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"content":"intro i"},{"tailPos":3544,"headPos":3542,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (List.map (some ∘ ts) (finRange n) ++ listDecode l) ↑i = some (some (ts i))"],"content":"h,"},{"tailPos":3557,"headPos":3545,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (List.map (some ∘ ts) (finRange n) ++ listDecode l) ↑i = some (some (ts i))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (List.map (some ∘ ts) (finRange n)) ↑i = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"content":"get?_append,"},{"tailPos":3566,"headPos":3558,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (List.map (some ∘ ts) (finRange n)) ↑i = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"content":"get?_map"},{"tailPos":3567,"headPos":3566,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"content":"]"},{"tailPos":3567,"headPos":3538,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"content":"rw [h, get?_append, get?_map]"},{"tailPos":3578,"headPos":3576,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))"],"content":"·"},{"tailPos":3645,"headPos":3579,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ∃ a, (∃ h, List.get (finRange n) { val := ↑i, isLt := h } = a) ∧ some (ts a) = some (ts i)"],"content":"simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]"},{"tailPos":3736,"headPos":3656,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ∃ a, (∃ h, List.get (finRange n) { val := ↑i, isLt := h } = a) ∧ some (ts a) = some (ts i)"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ List.get (finRange n) { val := ↑i, isLt := (_ : ↑i < length (finRange n)) } = i"],"content":"refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩"},{"tailPos":3764,"headPos":3751,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ List.get (finRange n) { val := ↑i, isLt := (_ : ↑i < length (finRange n)) } = i"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ { val := ↑i, isLt := (_ : ↑i < n) } = i"],"content":"get_finRange,"},{"tailPos":3772,"headPos":3765,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ { val := ↑i, isLt := (_ : ↑i < n) } = i"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ i = i"],"content":"Fin.eta"},{"tailPos":3773,"headPos":3772,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ i = i"],"goalsAfter":[],"content":"]"},{"tailPos":3773,"headPos":3747,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ List.get (finRange n) { val := ↑i, isLt := (_ : ↑i < length (finRange n)) } = i"],"goalsAfter":[],"content":"rw [get_finRange, Fin.eta]"},{"tailPos":3773,"headPos":3579,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))"],"goalsAfter":[],"content":"simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]"},{"tailPos":3773,"headPos":3576,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ Option.map (some ∘ ts) (get? (finRange n) ↑i) = some (some (ts i))","L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"content":"· simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]"},{"tailPos":3784,"headPos":3782,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"content":"·"},{"tailPos":3813,"headPos":3785,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ n ≤ length (List.map (some ∘ ts) (finRange n))"],"content":"refine' lt_of_lt_of_le i.2 _"},{"tailPos":3828,"headPos":3824,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ n ≤ length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":[],"content":"simp only [length_map, length_finRange, le_refl]"},{"tailPos":3828,"headPos":3785,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":[],"content":"refine' lt_of_lt_of_le i.2 _\n          simp"},{"tailPos":3828,"headPos":3782,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\ni : Fin n\n⊢ ↑i < length (List.map (some ∘ ts) (finRange n))"],"goalsAfter":[],"content":"· refine' lt_of_lt_of_le i.2 _\n          simp"},{"tailPos":3828,"headPos":3522,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\n⊢ ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":[],"content":"intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp"},{"tailPos":3513,"headPos":3511,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\n⊢ ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":[],"content":"by"},{"tailPos":3828,"headPos":3511,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\n⊢ ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":[],"content":"by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp"},{"tailPos":3828,"headPos":3355,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"content":"have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp"},{"tailPos":3910,"headPos":3835,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ (if h :\n        ∀ (i : Fin n),\n          Option.isSome\n              (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n            true then\n      some\n          (func f fun i =>\n            Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                  true)) ::\n        drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l))\n    else [none]) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i) = some (ts i)","case h.func.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ some\n        (func f fun i =>\n          Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n            (_ :\n              Option.isSome\n                  (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                true)) ::\n      drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"content":"refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _"},{"tailPos":3919,"headPos":3917,"goalsBefore":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i) = some (ts i)","case h.func.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ some\n        (func f fun i =>\n          Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n            (_ :\n              Option.isSome\n                  (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                true)) ::\n      drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i) = some (ts i)"],"content":"·"},{"tailPos":3944,"headPos":3924,"goalsBefore":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i) = some (ts i)"],"goalsAfter":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"content":"Option.join_eq_some,"},{"tailPos":3947,"headPos":3945,"goalsBefore":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))"],"goalsAfter":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ some (some (ts i)) = some (some (ts i))"],"content":"h'"},{"tailPos":3948,"headPos":3947,"goalsBefore":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ some (some (ts i)) = some (some (ts i))"],"goalsAfter":[],"content":"]"},{"tailPos":3948,"headPos":3920,"goalsBefore":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i) = some (ts i)"],"goalsAfter":[],"content":"rw [Option.join_eq_some, h']"},{"tailPos":3948,"headPos":3917,"goalsBefore":["case h.func.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i) = some (ts i)","case h.func.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ some\n        (func f fun i =>\n          Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n            (_ :\n              Option.isSome\n                  (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                true)) ::\n      drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ some\n        (func f fun i =>\n          Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n            (_ :\n              Option.isSome\n                  (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                true)) ::\n      drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"content":"· rw [Option.join_eq_some, h']"},{"tailPos":4046,"headPos":3955,"goalsBefore":["case h.func.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ some\n        (func f fun i =>\n          Option.get (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i))\n            (_ :\n              Option.isSome\n                  (Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)) =\n                true)) ::\n      drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) =\n    some (func f ts) :: listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ ts i ∈ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)","case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"content":"refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _"},{"tailPos":4055,"headPos":4053,"goalsBefore":["case h.func.refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ ts i ∈ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)","case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ ts i ∈ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)"],"content":"·"},{"tailPos":4065,"headPos":4056,"goalsBefore":["case h.func.refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ ts i ∈ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)"],"goalsAfter":[],"content":"simp [h']"},{"tailPos":4065,"headPos":4053,"goalsBefore":["case h.func.refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\ni : Fin n\n⊢ ts i ∈ Option.join (get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i)","case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"content":"· simp [h']"},{"tailPos":4074,"headPos":4072,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"content":"·"},{"tailPos":4081,"headPos":4079,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (List.map (some ∘ ts) (finRange n) ++ listDecode l) = listDecode l"],"content":"h,"},{"tailPos":4092,"headPos":4082,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (List.map (some ∘ ts) (finRange n) ++ listDecode l) = listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ listDecode l = listDecode l","case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (List.map (some ∘ ts) (finRange n)) = n"],"content":"drop_left'"},{"tailPos":4093,"headPos":4092,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ listDecode l = listDecode l","case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (List.map (some ∘ ts) (finRange n)) = n"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (List.map (some ∘ ts) (finRange n)) = n"],"content":"]"},{"tailPos":4093,"headPos":4075,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (List.map (some ∘ ts) (finRange n)) = n"],"content":"rw [h, drop_left']"},{"tailPos":4117,"headPos":4106,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (List.map (some ∘ ts) (finRange n)) = n"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (finRange n) = n"],"content":"length_map,"},{"tailPos":4133,"headPos":4118,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (finRange n) = n"],"goalsAfter":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ n = n"],"content":"length_finRange"},{"tailPos":4134,"headPos":4133,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ n = n"],"goalsAfter":[],"content":"]"},{"tailPos":4134,"headPos":4102,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ length (List.map (some ∘ ts) (finRange n)) = n"],"goalsAfter":[],"content":"rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":4075,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":[],"content":"rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":4072,"goalsBefore":["case h.func.refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\nh :\n  listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l) =\n    List.map (some ∘ ts) (finRange n) ++ listDecode l\nh' : ∀ (i : Fin n), get? (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) ↑i = some (some (ts i))\n⊢ drop n (listDecode ((List.bind (finRange n) fun i => listEncode (ts i)) ++ l)) = listDecode l"],"goalsAfter":[],"content":"· rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":2995,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":[],"content":"rw [listEncode, cons_append, listDecode]\n      have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]\n      have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp\n      refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _\n      · rw [Option.join_eq_some, h']\n      refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _\n      · simp [h']\n      · rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":2992,"goalsBefore":["case h.func\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List (Term L α)\nn : ℕ\nf : Functions L n\nts : Fin n → Term L α\nih :\n  ∀ (a : Fin n) (l : List (α ⊕ (i : ℕ) × Functions L i)),\n    listDecode (listEncode (ts a) ++ l) = some (ts a) :: listDecode l\nl : List (α ⊕ (i : ℕ) × Functions L i)\n⊢ listDecode (listEncode (func f ts) ++ l) = some (func f ts) :: listDecode l"],"goalsAfter":[],"content":"· rw [listEncode, cons_append, listDecode]\n      have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]\n      have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp\n      refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _\n      · rw [Option.join_eq_some, h']\n      refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _\n      · simp [h']\n      · rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":2881,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":[],"content":"intro t\n    induction' t with a n f ts ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n    · rw [listEncode, cons_append, listDecode]\n      have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]\n      have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp\n      refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _\n      · rw [Option.join_eq_some, h']\n      refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _\n      · simp [h']\n      · rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":2878,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ ∀ (t : Term L α) (l : List (α ⊕ (i : ℕ) × Functions L i)), listDecode (listEncode t ++ l) = some t :: listDecode l"],"goalsAfter":[],"content":"· intro t\n    induction' t with a n f ts ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n    · rw [listEncode, cons_append, listDecode]\n      have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]\n      have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp\n      refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _\n      · rw [Option.join_eq_some, h']\n      refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _\n      · simp [h']\n      · rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4134,"headPos":2637,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"goalsAfter":[],"content":"suffices h : ∀ (t : L.Term α) (l : List (Sum α (Σi, L.Functions i))),\n      listDecode (t.listEncode ++ l) = some t::listDecode l\n  · induction' l with t l lih\n    · rfl\n    · rw [cons_bind, h t (l.bind listEncode), lih, List.map]\n  · intro t\n    induction' t with a n f ts ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n    · rw [listEncode, cons_append, listDecode]\n      have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]\n      have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp\n      refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _\n      · rw [Option.join_eq_some, h']\n      refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _\n      · simp [h']\n      · rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":2634,"headPos":2632,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"goalsAfter":[],"content":"by"},{"tailPos":4134,"headPos":2632,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.2133\nP : Type ?u.2136\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List (Term L α)\n⊢ listDecode (List.bind l listEncode) = List.map some l"],"goalsAfter":[],"content":"by\n  suffices h : ∀ (t : L.Term α) (l : List (Sum α (Σi, L.Functions i))),\n      listDecode (t.listEncode ++ l) = some t::listDecode l\n  · induction' l with t l lih\n    · rfl\n    · rw [cons_bind, h t (l.bind listEncode), lih, List.map]\n  · intro t\n    induction' t with a n f ts ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n    · rw [listEncode, cons_append, listDecode]\n      have h : listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l) =\n          (finRange n).map (Option.some ∘ ts) ++ listDecode l := by\n        induction' finRange n with i l' l'ih\n        · rfl\n        · rw [cons_bind, List.append_assoc, ih, map_cons, l'ih, cons_append, Function.comp]\n      have h' : ∀ i : Fin n,\n          (listDecode (((finRange n).bind fun i : Fin n => (ts i).listEncode) ++ l)).get? ↑i =\n            some (some (ts i)) := by\n        intro i\n        rw [h, get?_append, get?_map]\n        · simp only [Option.map_eq_some', Function.comp_apply, get?_eq_some]\n          refine' ⟨i, ⟨lt_of_lt_of_le i.2 (ge_of_eq (length_finRange _)), _⟩, rfl⟩\n          rw [get_finRange, Fin.eta]\n        · refine' lt_of_lt_of_le i.2 _\n          simp\n      refine' (dif_pos fun i => Option.isSome_iff_exists.2 ⟨ts i, _⟩).trans _\n      · rw [Option.join_eq_some, h']\n      refine' congr (congr rfl (congr rfl (congr rfl (funext fun i => Option.get_of_mem _ _)))) _\n      · simp [h']\n      · rw [h, drop_left']\n        rw [length_map, length_finRange]"},{"tailPos":4503,"headPos":4467,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (List.bind [t] listEncode) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"content":"have h := listDecode_encode_list [t]"},{"tailPos":4526,"headPos":4512,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (List.bind [t] listEncode) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (listEncode t) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"content":"bind_singleton"},{"tailPos":4527,"headPos":4526,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (listEncode t) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (listEncode t) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"content":"]"},{"tailPos":4532,"headPos":4508,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (List.bind [t] listEncode) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (listEncode t) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"content":"rw [bind_singleton] at h"},{"tailPos":4606,"headPos":4537,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\nh : listDecode (listEncode t) = List.map some [t]\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"simp only [h, Option.join, head?, List.map, Option.some_bind, id.def]"},{"tailPos":4606,"headPos":4467,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"have h := listDecode_encode_list [t]\n    rw [bind_singleton] at h\n    simp only [h, Option.join, head?, List.map, Option.some_bind, id.def]"},{"tailPos":4462,"headPos":4460,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"by"},{"tailPos":4606,"headPos":4460,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.9122\nP : Type ?u.9125\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"by\n    have h := listDecode_encode_list [t]\n    rw [bind_singleton] at h\n    simp only [h, Option.join, head?, List.map, Option.some_bind, id.def]"},{"tailPos":5313,"headPos":5290,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) = max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"refine' le_antisymm _ _"},{"tailPos":5318,"headPos":5316,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"·"},{"tailPos":5331,"headPos":5323,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (Cardinal.sum fun i => #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"mk_sigma"},{"tailPos":5332,"headPos":5331,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (Cardinal.sum fun i => #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (Cardinal.sum fun i => #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"]"},{"tailPos":5332,"headPos":5319,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (Cardinal.sum fun i => #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"rw [mk_sigma]"},{"tailPos":5373,"headPos":5337,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (Cardinal.sum fun i => #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (lift (#ℕ) * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"refine' (sum_le_iSup_lift _).trans _"},{"tailPos":5389,"headPos":5382,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (lift (#ℕ) * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (lift ℵ₀ * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"mk_nat,"},{"tailPos":5402,"headPos":5390,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (lift ℵ₀ * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (ℵ₀ * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"lift_aleph0,"},{"tailPos":5439,"headPos":5403,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (ℵ₀ * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"mul_eq_max_of_aleph0_le_left le_rfl,"},{"tailPos":5451,"headPos":5440,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"max_le_iff,"},{"tailPos":5490,"headPos":5458,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"ciSup_le_iff' (bddAbove_range _)"},{"tailPos":5491,"headPos":5490,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"]"},{"tailPos":5491,"headPos":5378,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (lift (#ℕ) * ⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"rw [mk_nat, lift_aleph0, mul_eq_max_of_aleph0_le_left le_rfl, max_le_iff,\n      ciSup_le_iff' (bddAbove_range _)]"},{"tailPos":5498,"headPos":5496,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"·"},{"tailPos":5554,"headPos":5499,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ max ℵ₀ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩"},{"tailPos":5595,"headPos":5561,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ max ℵ₀ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"content":"refine' max_le (le_max_left _ _) _"},{"tailPos":5628,"headPos":5606,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ ℵ₀ + (#α ⊕ (i : ℕ) × Functions L i)"],"content":"← add_eq_max le_rfl,"},{"tailPos":5636,"headPos":5629,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ ℵ₀ + (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (#α ⊕ Fin i) + lift (#(i : ℕ) × Functions L i) ≤ ℵ₀ + (#α ⊕ (i : ℕ) × Functions L i)"],"content":"mk_sum,"},{"tailPos":5644,"headPos":5637,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (#α ⊕ Fin i) + lift (#(i : ℕ) × Functions L i) ≤ ℵ₀ + (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#α) + lift (#Fin i)) + lift (#(i : ℕ) × Functions L i) ≤ ℵ₀ + (#α ⊕ (i : ℕ) × Functions L i)"],"content":"mk_sum,"},{"tailPos":5652,"headPos":5645,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#α) + lift (#Fin i)) + lift (#(i : ℕ) × Functions L i) ≤ ℵ₀ + (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#α) + lift (#Fin i)) + lift (#(i : ℕ) × Functions L i) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"mk_sum,"},{"tailPos":5684,"headPos":5653,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#α) + lift (#Fin i)) + lift (#(i : ℕ) × Functions L i) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#Fin i) + lift (#α)) + lift (#(i : ℕ) × Functions L i) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"add_comm (Cardinal.lift (#α)),"},{"tailPos":5694,"headPos":5685,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#Fin i) + lift (#α)) + lift (#(i : ℕ) × Functions L i) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#Fin i)) + lift (lift (#α)) + lift (#(i : ℕ) × Functions L i) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"lift_add,"},{"tailPos":5713,"headPos":5703,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#Fin i)) + lift (lift (#α)) + lift (#(i : ℕ) × Functions L i) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#Fin i)) + (lift (lift (#α)) + lift (#(i : ℕ) × Functions L i)) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"add_assoc,"},{"tailPos":5724,"headPos":5714,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (lift (#Fin i)) + (lift (lift (#α)) + lift (#(i : ℕ) × Functions L i)) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (#Fin i) + (lift (lift (#α)) + lift (#(i : ℕ) × Functions L i)) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"lift_lift,"},{"tailPos":5735,"headPos":5725,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (#Fin i) + (lift (lift (#α)) + lift (#(i : ℕ) × Functions L i)) ≤\n    ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (#Fin i) + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"lift_lift,"},{"tailPos":5743,"headPos":5736,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift (#Fin i) + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"mk_fin,"},{"tailPos":5756,"headPos":5744,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ lift ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"lift_natCast"},{"tailPos":5757,"headPos":5756,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"]"},{"tailPos":5757,"headPos":5602,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ (#(α ⊕ Fin i) ⊕ (i : ℕ) × Functions L i) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"content":"rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]"},{"tailPos":5809,"headPos":5764,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ ↑i + (lift (#α) + lift (#(i : ℕ) × Functions L i)) ≤ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))"],"goalsAfter":[],"content":"exact add_le_add_right (nat_lt_aleph0 _).le _"},{"tailPos":5809,"headPos":5499,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":[],"content":"refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _"},{"tailPos":5809,"headPos":5496,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ∧ ∀ (i : ℕ), (#Term L (α ⊕ Fin i)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"· refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _"},{"tailPos":5816,"headPos":5814,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"content":"·"},{"tailPos":5843,"headPos":5821,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ ⨆ (i : ℕ), #Term L (α ⊕ Fin i)"],"content":"← one_le_iff_ne_zero"},{"tailPos":5844,"headPos":5843,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ ⨆ (i : ℕ), #Term L (α ⊕ Fin i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ ⨆ (i : ℕ), #Term L (α ⊕ Fin i)"],"content":"]"},{"tailPos":5844,"headPos":5817,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ ⨆ (i : ℕ), #Term L (α ⊕ Fin i)"],"content":"rw [← one_le_iff_ne_zero]"},{"tailPos":5905,"headPos":5851,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ ⨆ (i : ℕ), #Term L (α ⊕ Fin i)"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ (#Term L (α ⊕ Fin 1))"],"content":"refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)"},{"tailPos":5935,"headPos":5916,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ (#Term L (α ⊕ Fin 1))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#Term L (α ⊕ Fin 1)) ≠ 0"],"content":"one_le_iff_ne_zero,"},{"tailPos":5950,"headPos":5936,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#Term L (α ⊕ Fin 1)) ≠ 0"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (Term L (α ⊕ Fin 1))"],"content":"mk_ne_zero_iff"},{"tailPos":5951,"headPos":5950,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (Term L (α ⊕ Fin 1))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (Term L (α ⊕ Fin 1))"],"content":"]"},{"tailPos":5951,"headPos":5912,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ 1 ≤ (#Term L (α ⊕ Fin 1))"],"goalsAfter":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (Term L (α ⊕ Fin 1))"],"content":"rw [one_le_iff_ne_zero, mk_ne_zero_iff]"},{"tailPos":5985,"headPos":5958,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (Term L (α ⊕ Fin 1))"],"goalsAfter":[],"content":"exact ⟨var (Sum.inr 0)⟩"},{"tailPos":5985,"headPos":5817,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":[],"content":"rw [← one_le_iff_ne_zero]\n      refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩"},{"tailPos":5985,"headPos":5814,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (⨆ (i : ℕ), #Term L (α ⊕ Fin i)) ≠ 0"],"goalsAfter":[],"content":"· rw [← one_le_iff_ne_zero]\n      refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩"},{"tailPos":5985,"headPos":5319,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":[],"content":"rw [mk_sigma]\n    refine' (sum_le_iSup_lift _).trans _\n    rw [mk_nat, lift_aleph0, mul_eq_max_of_aleph0_le_left le_rfl, max_le_iff,\n      ciSup_le_iff' (bddAbove_range _)]\n    · refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _\n    · rw [← one_le_iff_ne_zero]\n      refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩"},{"tailPos":5985,"headPos":5316,"goalsBefore":["case refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) ≤ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)","case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"· rw [mk_sigma]\n    refine' (sum_le_iSup_lift _).trans _\n    rw [mk_nat, lift_aleph0, mul_eq_max_of_aleph0_le_left le_rfl, max_le_iff,\n      ciSup_le_iff' (bddAbove_range _)]\n    · refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _\n    · rw [← one_le_iff_ne_zero]\n      refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩"},{"tailPos":5990,"headPos":5988,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"·"},{"tailPos":6006,"headPos":5995,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ (#(n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"max_le_iff,"},{"tailPos":6023,"headPos":6007,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ ≤ (#(n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Infinite ((n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"← infinite_iff"},{"tailPos":6024,"headPos":6023,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Infinite ((n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Infinite ((n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"]"},{"tailPos":6024,"headPos":5991,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Infinite ((n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"rw [max_le_iff, ← infinite_iff]"},{"tailPos":6123,"headPos":6029,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Infinite ((n : ℕ) × Term L (α ⊕ Fin n)) ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni j : ℕ\nij : (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) i = (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) j\n⊢ i = j","case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"refine' ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => _, _⟩"},{"tailPos":6130,"headPos":6128,"goalsBefore":["case refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni j : ℕ\nij : (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) i = (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) j\n⊢ i = j","case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni j : ℕ\nij : (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) i = (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) j\n⊢ i = j"],"content":"·"},{"tailPos":6139,"headPos":6131,"goalsBefore":["case refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni j : ℕ\nij : (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) i = (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) j\n⊢ i = j"],"goalsAfter":["case refine'_2.refine'_1.refl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ i = i"],"content":"cases ij"},{"tailPos":6149,"headPos":6146,"goalsBefore":["case refine'_2.refine'_1.refl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni : ℕ\n⊢ i = i"],"goalsAfter":[],"content":"rfl"},{"tailPos":6149,"headPos":6131,"goalsBefore":["case refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni j : ℕ\nij : (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) i = (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) j\n⊢ i = j"],"goalsAfter":[],"content":"cases ij\n      rfl"},{"tailPos":6149,"headPos":6128,"goalsBefore":["case refine'_2.refine'_1\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\ni j : ℕ\nij : (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) i = (fun i => { fst := i + 1, snd := var (Sum.inr ↑i) }) j\n⊢ i = j","case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"· cases ij\n      rfl"},{"tailPos":6156,"headPos":6154,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"content":"·"},{"tailPos":6176,"headPos":6161,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (α ⊕ (i : ℕ) × Functions L i ↪ (n : ℕ) × Term L (α ⊕ Fin n))"],"content":"Cardinal.le_def"},{"tailPos":6177,"headPos":6176,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (α ⊕ (i : ℕ) × Functions L i ↪ (n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (α ⊕ (i : ℕ) × Functions L i ↪ (n : ℕ) × Term L (α ⊕ Fin n))"],"content":"]"},{"tailPos":6177,"headPos":6157,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (α ⊕ (i : ℕ) × Functions L i ↪ (n : ℕ) × Term L (α ⊕ Fin n))"],"content":"rw [Cardinal.le_def]"},{"tailPos":6311,"headPos":6184,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Nonempty (α ⊕ (i : ℕ) × Functions L i ↪ (n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Function.Injective\n    (Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) }) fun F =>\n      { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) })"],"content":"refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩"},{"tailPos":6320,"headPos":6318,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Function.Injective\n    (Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) }) fun F =>\n      { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) })"],"goalsAfter":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Function.Injective\n    (Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) }) fun F =>\n      { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) })"],"content":"·"},{"tailPos":6345,"headPos":6321,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Function.Injective\n    (Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) }) fun F =>\n      { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) })"],"goalsAfter":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inl a = Sum.inl b","case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b","case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"content":"rintro (a | a) (b | b) h"},{"tailPos":6356,"headPos":6354,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inl a = Sum.inl b","case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b","case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inl a = Sum.inl b"],"content":"·"},{"tailPos":6463,"headPos":6357,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inl a = Sum.inl b"],"goalsAfter":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh : a = b\n⊢ Sum.inl a = Sum.inl b"],"content":"simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h"},{"tailPos":6479,"headPos":6478,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh : a = b\n⊢ Sum.inl a = Sum.inl b"],"goalsAfter":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh : a = b\n⊢ Sum.inl b = Sum.inl b"],"content":"h"},{"tailPos":6480,"headPos":6479,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh : a = b\n⊢ Sum.inl b = Sum.inl b"],"goalsAfter":[],"content":"]"},{"tailPos":6480,"headPos":6474,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh : a = b\n⊢ Sum.inl a = Sum.inl b"],"goalsAfter":[],"content":"rw [h]"},{"tailPos":6480,"headPos":6357,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inl a = Sum.inl b"],"goalsAfter":[],"content":"simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]"},{"tailPos":6480,"headPos":6354,"goalsBefore":["case refine'_2.refine'_2.inl.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inl a = Sum.inl b","case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b","case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b","case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"content":"· simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]"},{"tailPos":6491,"headPos":6489,"goalsBefore":["case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b","case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b"],"content":"·"},{"tailPos":6564,"headPos":6492,"goalsBefore":["case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b"],"goalsAfter":[],"content":"simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h"},{"tailPos":6564,"headPos":6489,"goalsBefore":["case refine'_2.refine'_2.inl.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : α\nb : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inl a = Sum.inr b","case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"content":"· simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h"},{"tailPos":6575,"headPos":6573,"goalsBefore":["case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b"],"content":"·"},{"tailPos":6648,"headPos":6576,"goalsBefore":["case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b"],"goalsAfter":[],"content":"simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h"},{"tailPos":6648,"headPos":6573,"goalsBefore":["case refine'_2.refine'_2.inr.inl\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na : (i : ℕ) × Functions L i\nb : α\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inl b)\n⊢ Sum.inr a = Sum.inl b","case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"content":"· simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h"},{"tailPos":6659,"headPos":6657,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"content":"·"},{"tailPos":6740,"headPos":6660,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh : a.fst = b.fst ∧ HEq a.snd b.snd ∧ HEq (fun x => var (Sum.inr 0)) fun x => var (Sum.inr 0)\n⊢ Sum.inr a = Sum.inr b"],"content":"simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h"},{"tailPos":6787,"headPos":6755,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh : a.fst = b.fst ∧ HEq a.snd b.snd ∧ HEq (fun x => var (Sum.inr 0)) fun x => var (Sum.inr 0)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh : a.fst = b.fst ∧ HEq a.snd b.snd ∧ HEq (fun x => var (Sum.inr 0)) fun x => var (Sum.inr 0)\n⊢ Sum.inr b = Sum.inr b"],"content":"Sigma.ext_iff.2 ⟨h.1, h.2.1⟩"},{"tailPos":6788,"headPos":6787,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh : a.fst = b.fst ∧ HEq a.snd b.snd ∧ HEq (fun x => var (Sum.inr 0)) fun x => var (Sum.inr 0)\n⊢ Sum.inr b = Sum.inr b"],"goalsAfter":[],"content":"]"},{"tailPos":6788,"headPos":6751,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh : a.fst = b.fst ∧ HEq a.snd b.snd ∧ HEq (fun x => var (Sum.inr 0)) fun x => var (Sum.inr 0)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":[],"content":"rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":6660,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":[],"content":"simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":6657,"goalsBefore":["case refine'_2.refine'_2.inr.inr\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\na b : (i : ℕ) × Functions L i\nh :\n  Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr a) =\n    Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) })\n      (fun F => { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) }) (Sum.inr b)\n⊢ Sum.inr a = Sum.inr b"],"goalsAfter":[],"content":"· simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":6321,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Function.Injective\n    (Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) }) fun F =>\n      { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) })"],"goalsAfter":[],"content":"rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":6318,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ Function.Injective\n    (Sum.elim (fun i => { fst := 0, snd := var (Sum.inl i) }) fun F =>\n      { fst := 1, snd := func F.snd fun x => var (Sum.inr 0) })"],"goalsAfter":[],"content":"· rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":6157,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":[],"content":"rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":6154,"goalsBefore":["case refine'_2.refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":[],"content":"· rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":5991,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":[],"content":"rw [max_le_iff, ← infinite_iff]\n    refine' ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => _, _⟩\n    · cases ij\n      rfl\n    · rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":5988,"goalsBefore":["case refine'_2\nL : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i) ≤ (#(n : ℕ) × Term L (α ⊕ Fin n))"],"goalsAfter":[],"content":"· rw [max_le_iff, ← infinite_iff]\n    refine' ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => _, _⟩\n    · cases ij\n      rfl\n    · rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":6788,"headPos":5290,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) = max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":[],"content":"refine' le_antisymm _ _\n  · rw [mk_sigma]\n    refine' (sum_le_iSup_lift _).trans _\n    rw [mk_nat, lift_aleph0, mul_eq_max_of_aleph0_le_left le_rfl, max_le_iff,\n      ciSup_le_iff' (bddAbove_range _)]\n    · refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _\n    · rw [← one_le_iff_ne_zero]\n      refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩\n  · rw [max_le_iff, ← infinite_iff]\n    refine' ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => _, _⟩\n    · cases ij\n      rfl\n    · rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":5287,"headPos":5285,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) = max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":[],"content":"by"},{"tailPos":6788,"headPos":5285,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.10289\nP : Type ?u.10292\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × Term L (α ⊕ Fin n)) = max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)"],"goalsAfter":[],"content":"by\n  refine' le_antisymm _ _\n  · rw [mk_sigma]\n    refine' (sum_le_iSup_lift _).trans _\n    rw [mk_nat, lift_aleph0, mul_eq_max_of_aleph0_le_left le_rfl, max_le_iff,\n      ciSup_le_iff' (bddAbove_range _)]\n    · refine' ⟨le_max_left _ _, fun i => card_le.trans _⟩\n      refine' max_le (le_max_left _ _) _\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift (#α)), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _\n    · rw [← one_le_iff_ne_zero]\n      refine' _root_.trans _ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩\n  · rw [max_le_iff, ← infinite_iff]\n    refine' ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => _, _⟩\n    · cases ij\n      rfl\n    · rw [Cardinal.le_def]\n      refine' ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, _⟩⟩\n      · rintro (a | a) (b | b) h\n        · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n            at h\n          rw [h]\n        · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and] at h\n        · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n          rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]"},{"tailPos":7055,"headPos":7046,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (listDecode (listEncode t))) = some t"],"content":"simp only"},{"tailPos":7094,"headPos":7064,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (listDecode (listEncode t))) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (listDecode (List.bind [t] listEncode))) = some t"],"content":"← bind_singleton listEncode,"},{"tailPos":7117,"headPos":7095,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (listDecode (List.bind [t] listEncode))) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (List.map some [t])) = some t"],"content":"listDecode_encode_list"},{"tailPos":7118,"headPos":7117,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (List.map some [t])) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (List.map some [t])) = some t"],"content":"]"},{"tailPos":7118,"headPos":7060,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (listDecode (listEncode t))) = some t"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (List.map some [t])) = some t"],"content":"rw [← bind_singleton listEncode, listDecode_encode_list]"},{"tailPos":7189,"headPos":7123,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ Option.join (head? (List.map some [t])) = some t"],"goalsAfter":[],"content":"simp only [Option.join, head?, List.map, Option.some_bind, id.def]"},{"tailPos":7189,"headPos":7046,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"simp only\n    rw [← bind_singleton listEncode, listDecode_encode_list]\n    simp only [Option.join, head?, List.map, Option.some_bind, id.def]"},{"tailPos":7041,"headPos":7039,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"by"},{"tailPos":7189,"headPos":7039,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15104\nP : Type ?u.15107\ninst✝⁴ : Structure L M\ninst✝³ : Structure L N\ninst✝² : Structure L P\nα : Type u'\nβ : Type v'\ninst✝¹ : Encodable α\ninst✝ : Encodable ((i : ℕ) × Functions L i)\nt : Term L α\n⊢ (fun l => Option.join (head? (listDecode l))) (listEncode t) = some t"],"goalsAfter":[],"content":"by\n    simp only\n    rw [← bind_singleton listEncode, listDecode_encode_list]\n    simp only [Option.join, head?, List.map, Option.some_bind, id.def]"},{"tailPos":7349,"headPos":7290,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ Countable (Term L α)"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ ℵ₀ ≤ ℵ₀ ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ ℵ₀"],"content":"refine' mk_le_aleph0_iff.1 (card_le.trans (max_le_iff.2 _))"},{"tailPos":7424,"headPos":7352,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ ℵ₀ ≤ ℵ₀ ∧ (#α ⊕ (i : ℕ) × Functions L i) ≤ ℵ₀"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ (#α) ≤ ℵ₀ ∧ (#(i : ℕ) × Functions L i) ≤ ℵ₀"],"content":"simp only [le_refl, mk_sum, add_le_aleph0, lift_le_aleph0, true_and_iff]"},{"tailPos":7483,"headPos":7427,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ (#α) ≤ ℵ₀ ∧ (#(i : ℕ) × Functions L i) ≤ ℵ₀"],"goalsAfter":[],"content":"exact ⟨Cardinal.mk_le_aleph0, Cardinal.mk_le_aleph0⟩"},{"tailPos":7483,"headPos":7290,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ Countable (Term L α)"],"goalsAfter":[],"content":"refine' mk_le_aleph0_iff.1 (card_le.trans (max_le_iff.2 _))\n  simp only [le_refl, mk_sum, add_le_aleph0, lift_le_aleph0, true_and_iff]\n  exact ⟨Cardinal.mk_le_aleph0, Cardinal.mk_le_aleph0⟩"},{"tailPos":7287,"headPos":7285,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ Countable (Term L α)"],"goalsAfter":[],"content":"by"},{"tailPos":7483,"headPos":7285,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.15706\nP : Type ?u.15709\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh1 : Countable α\nh2 : Countable ((l : ℕ) × Functions L l)\n⊢ Countable (Term L α)"],"goalsAfter":[],"content":"by\n  refine' mk_le_aleph0_iff.1 (card_le.trans (max_le_iff.2 _))\n  simp only [le_refl, mk_sum, add_le_aleph0, lift_le_aleph0, true_and_iff]\n  exact ⟨Cardinal.mk_le_aleph0, Cardinal.mk_le_aleph0⟩"},{"tailPos":9028,"headPos":9027,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.20912\nP : Type ?u.20915\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nm : ℕ\nφ : BoundedFormula L α m\nn : ℕ\nψ : BoundedFormula L α n\nh : m = n\n⊢ BoundedFormula L α n = BoundedFormula L α m"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.20912\nP : Type ?u.20915\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nm : ℕ\nφ : BoundedFormula L α m\nn : ℕ\nψ : BoundedFormula L α n\nh : m = n\n⊢ BoundedFormula L α n = BoundedFormula L α n"],"content":"h"},{"tailPos":9029,"headPos":9028,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.20912\nP : Type ?u.20915\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nm : ℕ\nφ : BoundedFormula L α m\nn : ℕ\nψ : BoundedFormula L α n\nh : m = n\n⊢ BoundedFormula L α n = BoundedFormula L α n"],"goalsAfter":[],"content":"]"},{"tailPos":9029,"headPos":9023,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.20912\nP : Type ?u.20915\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nm : ℕ\nφ : BoundedFormula L α m\nn : ℕ\nψ : BoundedFormula L α n\nh : m = n\n⊢ BoundedFormula L α n = BoundedFormula L α m"],"goalsAfter":[],"content":"rw [h]"},{"tailPos":9022,"headPos":9020,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.20912\nP : Type ?u.20915\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nm : ℕ\nφ : BoundedFormula L α m\nn : ℕ\nψ : BoundedFormula L α n\nh : m = n\n⊢ BoundedFormula L α n = BoundedFormula L α m"],"goalsAfter":[],"content":"by"},{"tailPos":9029,"headPos":9020,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.20912\nP : Type ?u.20915\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nm : ℕ\nφ : BoundedFormula L α m\nn : ℕ\nψ : BoundedFormula L α n\nh : m = n\n⊢ BoundedFormula L α n = BoundedFormula L α m"],"goalsAfter":[],"content":"by rw [h]"},{"tailPos":9710,"headPos":9709,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : n₁ = n₂\n⊢ Term L (α ⊕ Fin n₂) = Term L (α ⊕ Fin n₁)"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : n₁ = n₂\n⊢ Term L (α ⊕ Fin n₂) = Term L (α ⊕ Fin n₂)"],"content":"h"},{"tailPos":9711,"headPos":9710,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : n₁ = n₂\n⊢ Term L (α ⊕ Fin n₂) = Term L (α ⊕ Fin n₂)"],"goalsAfter":[],"content":"]"},{"tailPos":9711,"headPos":9705,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : n₁ = n₂\n⊢ Term L (α ⊕ Fin n₂) = Term L (α ⊕ Fin n₁)"],"goalsAfter":[],"content":"rw [h]"},{"tailPos":9704,"headPos":9702,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : n₁ = n₂\n⊢ Term L (α ⊕ Fin n₂) = Term L (α ⊕ Fin n₁)"],"goalsAfter":[],"content":"by"},{"tailPos":9711,"headPos":9702,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : n₁ = n₂\n⊢ Term L (α ⊕ Fin n₂) = Term L (α ⊕ Fin n₁)"],"goalsAfter":[],"content":"by rw [h]"},{"tailPos":9804,"headPos":9748,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf l ≤ max 1 (SizeOf.sizeOf (Sum.inl { fst := n₁, snd := t₁ } :: Sum.inl { fst := n₂, snd := t₂ } :: l))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ List.rec 1 (fun head tail tail_ih => 1 + Sum._sizeOf_1 head + tail_ih) l ≤\n    max 1\n      (1 + Sum._sizeOf_1 (Sum.inl { fst := n₁, snd := t₁ }) + 1 + Sum._sizeOf_1 (Sum.inl { fst := n₂, snd := t₂ }) +\n        List.rec 1 (fun head tail tail_ih => 1 + Sum._sizeOf_1 head + tail_ih) l)"],"content":"simp only [SizeOf.sizeOf, List._sizeOf_1, ← add_assoc]"},{"tailPos":9847,"headPos":9811,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ List.rec 1 (fun head tail tail_ih => 1 + Sum._sizeOf_1 head + tail_ih) l ≤\n    max 1\n      (1 + Sum._sizeOf_1 (Sum.inl { fst := n₁, snd := t₁ }) + 1 + Sum._sizeOf_1 (Sum.inl { fst := n₂, snd := t₂ }) +\n        List.rec 1 (fun head tail tail_ih => 1 + Sum._sizeOf_1 head + tail_ih) l)"],"goalsAfter":[],"content":"exact le_max_of_le_right le_add_self"},{"tailPos":9847,"headPos":9748,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf l ≤ max 1 (SizeOf.sizeOf (Sum.inl { fst := n₁, snd := t₁ } :: Sum.inl { fst := n₂, snd := t₂ } :: l))"],"goalsAfter":[],"content":"simp only [SizeOf.sizeOf, List._sizeOf_1, ← add_assoc]\n      exact le_max_of_le_right le_add_self"},{"tailPos":9741,"headPos":9739,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf l ≤ max 1 (SizeOf.sizeOf (Sum.inl { fst := n₁, snd := t₁ } :: Sum.inl { fst := n₂, snd := t₂ } :: l))"],"goalsAfter":[],"content":"by"},{"tailPos":9847,"headPos":9739,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn₁ : ℕ\nt₁ : Term L (α ⊕ Fin n₁)\nn₂ : ℕ\nt₂ : Term L (α ⊕ Fin n₂)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf l ≤ max 1 (SizeOf.sizeOf (Sum.inl { fst := n₁, snd := t₁ } :: Sum.inl { fst := n₂, snd := t₂ } :: l))"],"goalsAfter":[],"content":"by\n      simp only [SizeOf.sizeOf, List._sizeOf_1, ← add_assoc]\n      exact le_max_of_le_right le_add_self"},{"tailPos":10105,"headPos":10101,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn : ℕ\nR : Relations L n\nk : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : ∀ (i : Fin n), Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true\nh' :\n  ∀ (i : Fin n),\n    (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n          (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst =\n      k\ni : Fin n\n⊢ Term L\n      (α ⊕\n        Fin\n          (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n              (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst) =\n    Term L (α ⊕ Fin k)"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn : ℕ\nR : Relations L n\nk : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : ∀ (i : Fin n), Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true\nh' :\n  ∀ (i : Fin n),\n    (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n          (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst =\n      k\ni : Fin n\n⊢ Term L (α ⊕ Fin k) = Term L (α ⊕ Fin k)"],"content":"h' i"},{"tailPos":10106,"headPos":10105,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn : ℕ\nR : Relations L n\nk : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : ∀ (i : Fin n), Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true\nh' :\n  ∀ (i : Fin n),\n    (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n          (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst =\n      k\ni : Fin n\n⊢ Term L (α ⊕ Fin k) = Term L (α ⊕ Fin k)"],"goalsAfter":[],"content":"]"},{"tailPos":10106,"headPos":10097,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn : ℕ\nR : Relations L n\nk : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : ∀ (i : Fin n), Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true\nh' :\n  ∀ (i : Fin n),\n    (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n          (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst =\n      k\ni : Fin n\n⊢ Term L\n      (α ⊕\n        Fin\n          (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n              (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst) =\n    Term L (α ⊕ Fin k)"],"goalsAfter":[],"content":"rw [h' i]"},{"tailPos":10096,"headPos":10094,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn : ℕ\nR : Relations L n\nk : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : ∀ (i : Fin n), Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true\nh' :\n  ∀ (i : Fin n),\n    (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n          (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst =\n      k\ni : Fin n\n⊢ Term L\n      (α ⊕\n        Fin\n          (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n              (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst) =\n    Term L (α ⊕ Fin k)"],"goalsAfter":[],"content":"by"},{"tailPos":10106,"headPos":10094,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nn : ℕ\nR : Relations L n\nk : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh : ∀ (i : Fin n), Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true\nh' :\n  ∀ (i : Fin n),\n    (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n          (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst =\n      k\ni : Fin n\n⊢ Term L\n      (α ⊕\n        Fin\n          (Option.get (Option.join (get? (List.map Sum.getLeft l) ↑i))\n              (_ : Option.isSome (Option.join (get? (List.map Sum.getLeft l) ↑i)) = true)).fst) =\n    Term L (α ⊕ Fin k)"],"goalsAfter":[],"content":"by rw [h' i]"},{"tailPos":10565,"headPos":10559,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + (1 + 1)"],"goalsAfter":[],"content":"decide"},{"tailPos":10558,"headPos":10556,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + (1 + 1)"],"goalsAfter":[],"content":"by"},{"tailPos":10565,"headPos":10556,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + (1 + 1)"],"goalsAfter":[],"content":"by decide"},{"tailPos":10568,"headPos":10479,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf ↑(listDecode l).snd < 1 + (1 + 1) + SizeOf.sizeOf l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 1 < 1 + (1 + 1) + SizeOf.sizeOf l"],"content":"refine' lt_of_le_of_lt (listDecode l).2.2 (max_lt _ (Nat.lt_add_of_pos_left (by decide)))"},{"tailPos":10589,"headPos":10579,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 1 < 1 + (1 + 1) + SizeOf.sizeOf l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 1 < 1 + (1 + 1 + SizeOf.sizeOf l)"],"content":"add_assoc,"},{"tailPos":10611,"headPos":10590,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 1 < 1 + (1 + 1 + SizeOf.sizeOf l)"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 + SizeOf.sizeOf l"],"content":"lt_add_iff_pos_right,"},{"tailPos":10623,"headPos":10612,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 + SizeOf.sizeOf l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 ∨ 0 < SizeOf.sizeOf l"],"content":"add_pos_iff"},{"tailPos":10624,"headPos":10623,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 ∨ 0 < SizeOf.sizeOf l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 ∨ 0 < SizeOf.sizeOf l"],"content":"]"},{"tailPos":10624,"headPos":10575,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 1 < 1 + (1 + 1) + SizeOf.sizeOf l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 ∨ 0 < SizeOf.sizeOf l"],"content":"rw [add_assoc, lt_add_iff_pos_right, add_pos_iff]"},{"tailPos":10655,"headPos":10631,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ 0 < 1 + 1 ∨ 0 < SizeOf.sizeOf l"],"goalsAfter":[],"content":"exact Or.inl zero_lt_two"},{"tailPos":10655,"headPos":10479,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf ↑(listDecode l).snd < 1 + (1 + 1) + SizeOf.sizeOf l"],"goalsAfter":[],"content":"refine' lt_of_le_of_lt (listDecode l).2.2 (max_lt _ (Nat.lt_add_of_pos_left (by decide)))\n      rw [add_assoc, lt_add_iff_pos_right, add_pos_iff]\n      exact Or.inl zero_lt_two"},{"tailPos":10472,"headPos":10470,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf ↑(listDecode l).snd < 1 + (1 + 1) + SizeOf.sizeOf l"],"goalsAfter":[],"content":"by"},{"tailPos":10655,"headPos":10470,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.21767\nP : Type ?u.21770\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ SizeOf.sizeOf ↑(listDecode l).snd < 1 + (1 + 1) + SizeOf.sizeOf l"],"goalsAfter":[],"content":"by\n      refine' lt_of_le_of_lt (listDecode l).2.2 (max_lt _ (Nat.lt_add_of_pos_left (by decide)))\n      rw [add_assoc, lt_add_iff_pos_right, add_pos_iff]\n      exact Or.inl zero_lt_two"},{"tailPos":11571,"headPos":11419,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"content":"suffices h : ∀ (φ : Σn, L.BoundedFormula α n) (l),\n      (listDecode (listEncode φ.2 ++ l)).1 = φ ∧ (listDecode (listEncode φ.2 ++ l)).2.1 = l"},{"tailPos":11576,"headPos":11574,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"content":"·"},{"tailPos":11601,"headPos":11577,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []","case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"content":"induction' l with φ l _"},{"tailPos":11608,"headPos":11606,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []","case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []"],"content":"·"},{"tailPos":11626,"headPos":11613,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode []).fst = headI []"],"content":"List.nil_bind"},{"tailPos":11627,"headPos":11626,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode []).fst = headI []"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode []).fst = headI []"],"content":"]"},{"tailPos":11627,"headPos":11609,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []"],"goalsAfter":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode []).fst = headI []"],"content":"rw [List.nil_bind]"},{"tailPos":11651,"headPos":11634,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode []).fst = headI []"],"goalsAfter":[],"content":"simp [listDecode]"},{"tailPos":11651,"headPos":11609,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []"],"goalsAfter":[],"content":"rw [List.nil_bind]\n      simp [listDecode]"},{"tailPos":11651,"headPos":11606,"goalsBefore":["case nil\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind [] fun φ => listEncode φ.snd)).fst = headI []","case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"content":"· rw [List.nil_bind]\n      simp [listDecode]"},{"tailPos":11658,"headPos":11656,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"content":"·"},{"tailPos":11673,"headPos":11663,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (listEncode φ.snd ++ List.bind l fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"content":"cons_bind,"},{"tailPos":11685,"headPos":11674,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (listEncode φ.snd ++ List.bind l fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ φ = headI (φ :: l)"],"content":"(h φ _).1,"},{"tailPos":11696,"headPos":11686,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ φ = headI (φ :: l)"],"goalsAfter":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ φ = φ"],"content":"headI_cons"},{"tailPos":11697,"headPos":11696,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ φ = φ"],"goalsAfter":[],"content":"]"},{"tailPos":11697,"headPos":11659,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":[],"content":"rw [cons_bind, (h φ _).1, headI_cons]"},{"tailPos":11697,"headPos":11656,"goalsBefore":["case cons\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\nφ : (n : ℕ) × BoundedFormula L α n\nl : List ((n : ℕ) × BoundedFormula L α n)\ntail_ih✝ : (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l\n⊢ (listDecode (List.bind (φ :: l) fun φ => listEncode φ.snd)).fst = headI (φ :: l)"],"goalsAfter":[],"content":"· rw [cons_bind, (h φ _).1, headI_cons]"},{"tailPos":11697,"headPos":11577,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"goalsAfter":[],"content":"induction' l with φ l _\n    · rw [List.nil_bind]\n      simp [listDecode]\n    · rw [cons_bind, (h φ _).1, headI_cons]"},{"tailPos":11697,"headPos":11574,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nh :\n  ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"content":"· induction' l with φ l _\n    · rw [List.nil_bind]\n      simp [listDecode]\n    · rw [cons_bind, (h φ _).1, headI_cons]"},{"tailPos":11702,"headPos":11700,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"content":"·"},{"tailPos":11721,"headPos":11703,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"goalsAfter":["case h.mk\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn : ℕ\nφ : BoundedFormula L α n\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n, snd := φ }.snd ++ l)).fst = { fst := n, snd := φ } ∧\n      ↑(listDecode (listEncode { fst := n, snd := φ }.snd ++ l)).snd = l"],"content":"rintro ⟨n, φ⟩"},{"tailPos":11791,"headPos":11726,"goalsBefore":["case h.mk\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn : ℕ\nφ : BoundedFormula L α n\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n, snd := φ }.snd ++ l)).fst = { fst := n, snd := φ } ∧\n      ↑(listDecode (listEncode { fst := n, snd := φ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l","case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n      ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"induction' φ with _ _ _ _ φ_n φ_l φ_R ts _ _ _ ih1 ih2 _ _ ih"},{"tailPos":11795,"headPos":11792,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l","case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n      ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l","case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n      ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"<;>"},{"tailPos":11803,"headPos":11796,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l"],"content":"intro l"},{"tailPos":11803,"headPos":11796,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l"],"content":"intro l"},{"tailPos":11803,"headPos":11796,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n      ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l"],"content":"intro l"},{"tailPos":11803,"headPos":11796,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l"],"content":"intro l"},{"tailPos":11803,"headPos":11796,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"intro l"},{"tailPos":11803,"headPos":11726,"goalsBefore":["case h.mk\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\nn : ℕ\nφ : BoundedFormula L α n\n⊢ ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n, snd := φ }.snd ++ l)).fst = { fst := n, snd := φ } ∧\n      ↑(listDecode (listEncode { fst := n, snd := φ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l","case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"induction' φ with _ _ _ _ φ_n φ_l φ_R ts _ _ _ ih1 ih2 _ _ ih <;> intro l"},{"tailPos":11810,"headPos":11808,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l","case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l"],"content":"·"},{"tailPos":11826,"headPos":11815,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode ([Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2))] ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode ([Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2))] ++ l)).snd = l"],"content":"listEncode,"},{"tailPos":11844,"headPos":11827,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode ([Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2))] ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode ([Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2))] ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l)).snd = l"],"content":"singleton_append,"},{"tailPos":11855,"headPos":11845,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n          { val := l,\n            property :=\n              (_ :\n                SizeOf.sizeOf l ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).fst =\n      { fst := n✝, snd := falsum } ∧\n    ↑({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n            { val := l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf l ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).snd =\n      l"],"content":"listDecode"},{"tailPos":11856,"headPos":11855,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n          { val := l,\n            property :=\n              (_ :\n                SizeOf.sizeOf l ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).fst =\n      { fst := n✝, snd := falsum } ∧\n    ↑({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n            { val := l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf l ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).snd =\n      l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n          { val := l,\n            property :=\n              (_ :\n                SizeOf.sizeOf l ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).fst =\n      { fst := n✝, snd := falsum } ∧\n    ↑({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n            { val := l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf l ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).snd =\n      l"],"content":"]"},{"tailPos":11856,"headPos":11811,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n          { val := l,\n            property :=\n              (_ :\n                SizeOf.sizeOf l ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).fst =\n      { fst := n✝, snd := falsum } ∧\n    ↑({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n            { val := l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf l ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).snd =\n      l"],"content":"rw [listEncode, singleton_append, listDecode]"},{"tailPos":11917,"headPos":11863,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n          { val := l,\n            property :=\n              (_ :\n                SizeOf.sizeOf l ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).fst =\n      { fst := n✝, snd := falsum } ∧\n    ↑({ fst := { fst := n✝, snd := falsum }.fst, snd := falsum },\n            { val := l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf l ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr ({ fst := n✝, snd := falsum }.fst + 2)) :: l))) }).snd =\n      l"],"goalsAfter":[],"content":"simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":11917,"headPos":11811,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l"],"goalsAfter":[],"content":"rw [listEncode, singleton_append, listDecode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":11917,"headPos":11808,"goalsBefore":["case h.mk.falsum\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).fst = { fst := n✝, snd := falsum } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := falsum }.snd ++ l)).snd = l","case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"· rw [listEncode, singleton_append, listDecode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":11924,"headPos":11922,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l"],"content":"·"},{"tailPos":11940,"headPos":11929,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ },\n              Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++\n            l)).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode\n            ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ },\n                Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++\n              l)).snd =\n      l"],"content":"listEncode,"},{"tailPos":11953,"headPos":11941,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ },\n              Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++\n            l)).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode\n            ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ },\n                Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++\n              l)).snd =\n      l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n            ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++ l))).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode\n            (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n              ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++ l))).snd =\n      l"],"content":"cons_append,"},{"tailPos":11966,"headPos":11954,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n            ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++ l))).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode\n            (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n              ([Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ }] ++ l))).snd =\n      l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n            Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l))).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode\n            (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n              Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l))).snd =\n      l"],"content":"cons_append,"},{"tailPos":11978,"headPos":11967,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n            Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l))).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode\n            (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n              Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l))).snd =\n      l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h : { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst then\n            { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) }\n          else default,\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(if h : { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst then\n              { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n                snd :=\n                  equal t₁✝\n                    (Eq.mp\n                      (_ :\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                          Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                      t₂✝) }\n            else default,\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l"],"content":"listDecode,"},{"tailPos":11986,"headPos":11979,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h : { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst then\n            { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) }\n          else default,\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(if h : { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst then\n              { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n                snd :=\n                  equal t₁✝\n                    (Eq.mp\n                      (_ :\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                          Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                      t₂✝) }\n            else default,\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l","case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"content":"dif_pos"},{"tailPos":11987,"headPos":11986,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l","case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l","case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"content":"]"},{"tailPos":11987,"headPos":11925,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l","case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"content":"rw [listEncode, cons_append, cons_append, listDecode, dif_pos]"},{"tailPos":11996,"headPos":11994,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l","case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"goalsAfter":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l"],"content":"·"},{"tailPos":12087,"headPos":11997,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l"],"goalsAfter":[],"content":"simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]"},{"tailPos":12087,"headPos":11994,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n            snd :=\n              equal t₁✝\n                (Eq.mp\n                  (_ :\n                    Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                  t₂✝) },\n          { val := [] ++ l,\n            property :=\n              (_ :\n                SizeOf.sizeOf ([] ++ l) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                        Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } :: ([] ++ l)))) }).fst =\n      { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑({ fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst,\n              snd :=\n                equal t₁✝\n                  (Eq.mp\n                    (_ :\n                      Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst) =\n                        Term L (α ⊕ Fin { fst := n✝, snd := equal t₁✝ t₂✝ }.fst))\n                    t₂✝) },\n            { val := [] ++ l,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ([] ++ l) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₁✝ } ::\n                          Sum.inl { fst := { fst := n✝, snd := equal t₁✝ t₂✝ }.fst, snd := t₂✝ } ::\n                            ([] ++ l)))) }).snd =\n      l","case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"goalsAfter":["case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"content":"· simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]"},{"tailPos":12096,"headPos":12094,"goalsBefore":["case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"goalsAfter":["case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"content":"·"},{"tailPos":12151,"headPos":12097,"goalsBefore":["case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"goalsAfter":[],"content":"simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":12151,"headPos":12094,"goalsBefore":["case h.mk.equal.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := equal t₁✝ t₂✝ }.fst = { fst := n✝, snd := equal t₁✝ t₂✝ }.fst"],"goalsAfter":[],"content":"· simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":12151,"headPos":11925,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l"],"goalsAfter":[],"content":"rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":12151,"headPos":11922,"goalsBefore":["case h.mk.equal\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nt₁✝ t₂✝ : Term L (α ⊕ Fin n✝)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).fst = { fst := n✝, snd := equal t₁✝ t₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := equal t₁✝ t₂✝ }.snd ++ l)).snd = l","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"· rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]"},{"tailPos":12158,"headPos":12156,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l"],"content":"·"},{"tailPos":12174,"headPos":12163,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          ([Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }), Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n              List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                (finRange φ_l) ++\n            l)).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            ([Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }), Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n              l)).snd =\n      l"],"content":"listEncode,"},{"tailPos":12187,"headPos":12175,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          ([Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }), Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n              List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                (finRange φ_l) ++\n            l)).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            ([Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }), Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n              l)).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l)) ++\n            l)).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                  List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l)) ++\n              l)).snd =\n      l"],"content":"cons_append,"},{"tailPos":12200,"headPos":12188,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l)) ++\n            l)).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                  List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l)) ++\n              l)).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n            ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n              l))).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                  List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                l))).snd =\n      l"],"content":"cons_append,"},{"tailPos":12218,"headPos":12201,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n            ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n              l))).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              ([Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst)] ++\n                  List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                l))).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n            (Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n              l))).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              (Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                  List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                l))).snd =\n      l"],"content":"singleton_append,"},{"tailPos":12231,"headPos":12219,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n            (Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n              l))).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              (Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                  List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                l))).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n            Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))).snd =\n      l"],"content":"cons_append,"},{"tailPos":12242,"headPos":12232,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode\n          (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n            Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode\n            (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n              Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"listDecode"},{"tailPos":12243,"headPos":12242,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"]"},{"tailPos":12243,"headPos":12159,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]"},{"tailPos":12252,"headPos":12250,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"·"},{"tailPos":12552,"headPos":12545,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ Option.join\n      (get?\n        (List.map Sum.getLeft\n          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n            l))\n        ↑i) =\n    some { fst := φ_n, snd := ts i }"],"content":"intro i"},{"tailPos":12723,"headPos":12563,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ Option.join\n      (get?\n        (List.map Sum.getLeft\n          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n            l))\n        ↑i) =\n    some { fst := φ_n, snd := ts i }"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ∃ h,\n    List.get\n        (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ List.map Sum.getLeft l)\n        { val := ↑i,\n          isLt :=\n            (_ :\n              ↑i <\n                length\n                  (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++\n                    List.map Sum.getLeft l)) } =\n      some { fst := φ_n, snd := ts i }"],"content":"simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]"},{"tailPos":12781,"headPos":12734,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ∃ h,\n    List.get\n        (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ List.map Sum.getLeft l)\n        { val := ↑i,\n          isLt :=\n            (_ :\n              ↑i <\n                length\n                  (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++\n                    List.map Sum.getLeft l)) } =\n      some { fst := φ_n, snd := ts i }"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ List.get\n      (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ List.map Sum.getLeft l)\n      { val := ↑i,\n        isLt :=\n          (_ :\n            ↑i <\n              length\n                (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++\n                  List.map Sum.getLeft l)) } =\n    some { fst := φ_n, snd := ts i }"],"content":"refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩"},{"tailPos":12807,"headPos":12796,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ List.get\n      (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ List.map Sum.getLeft l)\n      { val := ↑i,\n        isLt :=\n          (_ :\n            ↑i <\n              length\n                (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++\n                  List.map Sum.getLeft l)) } =\n    some { fst := φ_n, snd := ts i }"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ List.get (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))\n      { val := ↑i, isLt := ?h } =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"content":"get_append,"},{"tailPos":12815,"headPos":12808,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ List.get (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))\n      { val := ↑i, isLt := ?h } =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"content":"get_map"},{"tailPos":12816,"headPos":12815,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"content":"]"},{"tailPos":12816,"headPos":12792,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ List.get\n      (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ List.map Sum.getLeft l)\n      { val := ↑i,\n        isLt :=\n          (_ :\n            ↑i <\n              length\n                (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++\n                  List.map Sum.getLeft l)) } =\n    some { fst := φ_n, snd := ts i }"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"content":"rw [get_append, get_map]"},{"tailPos":12829,"headPos":12827,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }"],"content":"·"},{"tailPos":12955,"headPos":12830,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }"],"goalsAfter":[],"content":"simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]"},{"tailPos":12955,"headPos":12827,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i })\n      (List.get (finRange φ_l)\n        { val := ↑{ val := ↑i, isLt := ?h }, isLt := (_ : ↑{ val := ↑i, isLt := ?h } < length (finRange φ_l)) }) =\n    some { fst := φ_n, snd := ts i }","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"content":"· simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]"},{"tailPos":12968,"headPos":12966,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"content":"·"},{"tailPos":13015,"headPos":12969,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":[],"content":"simp only [length_map, length_finRange, is_lt]"},{"tailPos":13015,"headPos":12966,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))","case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\ni : Fin φ_l\n⊢ ↑i < length (List.map (Sum.getLeft ∘ fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))"],"goalsAfter":[],"content":"· simp only [length_map, length_finRange, is_lt]"},{"tailPos":13015,"headPos":12545,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }"],"goalsAfter":[],"content":"intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]"},{"tailPos":12534,"headPos":12532,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }"],"goalsAfter":[],"content":"by"},{"tailPos":13015,"headPos":12532,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }"],"goalsAfter":[],"content":"by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]"},{"tailPos":13015,"headPos":12253,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]"},{"tailPos":13035,"headPos":13028,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"content":"dif_pos"},{"tailPos":13036,"headPos":13035,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"content":"]"},{"tailPos":13036,"headPos":13024,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"content":"rw [dif_pos]"},{"tailPos":13049,"headPos":13045,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"goalsAfter":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"swap"},{"tailPos":13060,"headPos":13058,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"content":"·"},{"tailPos":13127,"headPos":13061,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true"],"goalsAfter":[],"content":"exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩"},{"tailPos":13127,"headPos":13058,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    Option.isSome\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i)) =\n      true","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"· exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩"},{"tailPos":13147,"headPos":13140,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"dif_pos"},{"tailPos":13148,"headPos":13147,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"]"},{"tailPos":13148,"headPos":13136,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (if h' :\n              ∀ (i : Fin φ_l),\n                (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).fst =\n                  { fst := φ_n, snd := rel φ_R ts }.fst then\n            { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd }\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"rw [dif_pos]"},{"tailPos":13161,"headPos":13157,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l","case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"swap"},{"tailPos":13172,"headPos":13170,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"·"},{"tailPos":13180,"headPos":13173,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ (Option.get\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft\n                    (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                        (finRange φ_l) ++\n                      l))\n                  ↑i)) =\n            true)).fst =\n    { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"intro i"},{"tailPos":13247,"headPos":13191,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ (Option.get\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft\n                    (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                        (finRange φ_l) ++\n                      l))\n                  ↑i)) =\n            true)).fst =\n    { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":["case h.mk.rel.hc.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ (Option.get\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft\n                    (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                        (finRange φ_l) ++\n                      l))\n                  ↑i)) =\n            true)).fst =\n    { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)"},{"tailPos":13264,"headPos":13262,"goalsBefore":["case h.mk.rel.hc.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ (Option.get\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft\n                    (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                        (finRange φ_l) ++\n                      l))\n                  ↑i)) =\n            true)).fst =\n    { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":["case h.mk.rel.hc.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ { fst := φ_n, snd := ts i }.fst = { fst := φ_n, snd := rel φ_R ts }.fst"],"content":"h2"},{"tailPos":13265,"headPos":13264,"goalsBefore":["case h.mk.rel.hc.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ { fst := φ_n, snd := ts i }.fst = { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":[],"content":"]"},{"tailPos":13265,"headPos":13258,"goalsBefore":["case h.mk.rel.hc.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ (Option.get\n        (Option.join\n          (get?\n            (List.map Sum.getLeft\n              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                  (finRange φ_l) ++\n                l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft\n                    (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                        (finRange φ_l) ++\n                      l))\n                  ↑i)) =\n            true)).fst =\n    { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":[],"content":"rw [h2]"},{"tailPos":13265,"headPos":13173,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst"],"goalsAfter":[],"content":"intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]"},{"tailPos":13265,"headPos":13170,"goalsBefore":["case h.mk.rel.hc\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ∀ (i : Fin φ_l),\n    (Option.get\n          (Option.join\n            (get?\n              (List.map Sum.getLeft\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l))\n                    ↑i)) =\n              true)).fst =\n      { fst := φ_n, snd := rel φ_R ts }.fst","case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"content":"· intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]"},{"tailPos":13334,"headPos":13274,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ ({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n            snd :=\n              rel φ_R fun i =>\n                Eq.mp\n                  (_ :\n                    Term L\n                        (α ⊕\n                          Fin\n                            (Option.get\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i))\n                                (_ :\n                                  Option.isSome\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i)) =\n                                    true)).fst) =\n                      Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                  (Option.get\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i))\n                      (_ :\n                        Option.isSome\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i)) =\n                          true)).snd },\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑({ fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n              snd :=\n                rel φ_R fun i =>\n                  Eq.mp\n                    (_ :\n                      Term L\n                          (α ⊕\n                            Fin\n                              (Option.get\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i))\n                                  (_ :\n                                    Option.isSome\n                                        (Option.join\n                                          (get?\n                                            (List.map Sum.getLeft\n                                              (List.map\n                                                  (fun i =>\n                                                    Sum.inl\n                                                      { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                  (finRange φ_l) ++\n                                                l))\n                                            ↑i)) =\n                                      true)).fst) =\n                        Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).snd },\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (fun i =>\n        Eq.mp\n          (_ :\n            Term L\n                (α ⊕\n                  Fin\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst) =\n              Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n          (Option.get\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                        ↑i)) =\n                  true)).snd) =\n      ts ∧\n    drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"content":"simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]"},{"tailPos":13377,"headPos":13343,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ (fun i =>\n        Eq.mp\n          (_ :\n            Term L\n                (α ⊕\n                  Fin\n                    (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst) =\n              Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n          (Option.get\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i))\n              (_ :\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                        ↑i)) =\n                  true)).snd) =\n      ts ∧\n    drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"goalsAfter":["case h.mk.rel.refine'_1\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"content":"refine' ⟨funext fun i => _, _⟩"},{"tailPos":13388,"headPos":13386,"goalsBefore":["case h.mk.rel.refine'_1\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"goalsAfter":["case h.mk.rel.refine'_1\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"content":"·"},{"tailPos":13445,"headPos":13389,"goalsBefore":["case h.mk.rel.refine'_1\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"goalsAfter":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"content":"obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)"},{"tailPos":13474,"headPos":13460,"goalsBefore":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"goalsAfter":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ _root_.cast\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"content":"eq_mp_eq_cast,"},{"tailPos":13490,"headPos":13475,"goalsBefore":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ _root_.cast\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"goalsAfter":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ HEq\n    (Option.get\n        (Option.join\n          (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i)) =\n            true)).snd\n    (ts i)"],"content":"cast_eq_iff_heq"},{"tailPos":13491,"headPos":13490,"goalsBefore":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ HEq\n    (Option.get\n        (Option.join\n          (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i)) =\n            true)).snd\n    (ts i)"],"goalsAfter":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ HEq\n    (Option.get\n        (Option.join\n          (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i)) =\n            true)).snd\n    (ts i)"],"content":"]"},{"tailPos":13491,"headPos":13456,"goalsBefore":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"goalsAfter":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ HEq\n    (Option.get\n        (Option.join\n          (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i)) =\n            true)).snd\n    (ts i)"],"content":"rw [eq_mp_eq_cast, cast_eq_iff_heq]"},{"tailPos":13568,"headPos":13502,"goalsBefore":["case h.mk.rel.refine'_1.intro\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\nh1 :\n  Option.isSome\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i)) =\n    true\nh2 :\n  Option.get\n      (Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i))\n      h1 =\n    { fst := φ_n, snd := ts i }\n⊢ HEq\n    (Option.get\n        (Option.join\n          (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n            ↑i))\n        (_ :\n          Option.isSome\n              (Option.join\n                (get?\n                  (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                  ↑i)) =\n            true)).snd\n    (ts i)"],"goalsAfter":[],"content":"exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2"},{"tailPos":13568,"headPos":13389,"goalsBefore":["case h.mk.rel.refine'_1\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i"],"goalsAfter":[],"content":"obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2"},{"tailPos":13568,"headPos":13386,"goalsBefore":["case h.mk.rel.refine'_1\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\ni : Fin φ_l\n⊢ Eq.mp\n      (_ :\n        Term L\n            (α ⊕\n              Fin\n                (Option.get\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i))\n                    (_ :\n                      Option.isSome\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i)) =\n                        true)).fst) =\n          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n      (Option.get\n          (Option.join\n            (get? (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n              ↑i))\n          (_ :\n            Option.isSome\n                (Option.join\n                  (get?\n                    (List.map Sum.getLeft (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l))\n                    ↑i)) =\n              true)).snd =\n    ts i","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"content":"· obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2"},{"tailPos":13613,"headPos":13581,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++\n      drop (φ_l - length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))) l =\n    l"],"content":"List.drop_append_eq_append_drop,"},{"tailPos":13625,"headPos":13614,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++\n      drop (φ_l - length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l))) l =\n    l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++\n      drop (φ_l - length (finRange φ_l)) l =\n    l"],"content":"length_map,"},{"tailPos":13642,"headPos":13626,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++\n      drop (φ_l - length (finRange φ_l)) l =\n    l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++ drop (φ_l - φ_l) l = l"],"content":"length_finRange,"},{"tailPos":13656,"headPos":13643,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++ drop (φ_l - φ_l) l = l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++ drop 0 l = l"],"content":"Nat.sub_self,"},{"tailPos":13662,"headPos":13657,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++ drop 0 l = l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++ l = l"],"content":"drop,"},{"tailPos":13691,"headPos":13673,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ++ l = l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ [] ++ l = l","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"content":"drop_eq_nil_of_le,"},{"tailPos":13702,"headPos":13692,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ [] ++ l = l","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ l = l","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"content":"nil_append"},{"tailPos":13703,"headPos":13702,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ l = l","case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"content":"]"},{"tailPos":13703,"headPos":13577,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ drop φ_l (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l) ++ l) = l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"content":"rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]"},{"tailPos":13727,"headPos":13716,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (finRange φ_l) ≤ φ_l"],"content":"length_map,"},{"tailPos":13743,"headPos":13728,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (finRange φ_l) ≤ φ_l"],"goalsAfter":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ φ_l ≤ φ_l"],"content":"length_finRange"},{"tailPos":13744,"headPos":13743,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ φ_l ≤ φ_l"],"goalsAfter":[],"content":"]"},{"tailPos":13744,"headPos":13712,"goalsBefore":["case h.mk.rel.refine'_2\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\nh :\n  ∀ (i : Fin φ_l),\n    Option.join\n        (get?\n          (List.map Sum.getLeft\n            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i }) (finRange φ_l) ++\n              l))\n          ↑i) =\n      some { fst := φ_n, snd := ts i }\n⊢ length (List.map (fun i => Sum.inl { fst := φ_n, snd := ts i }) (finRange φ_l)) ≤ φ_l"],"goalsAfter":[],"content":"rw [length_map, length_finRange]"},{"tailPos":13744,"headPos":12253,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":[],"content":"have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]"},{"tailPos":13744,"headPos":12250,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (if h :\n              ∀ (i : Fin φ_l),\n                Option.isSome\n                    (Option.join\n                      (get?\n                        (List.map Sum.getLeft\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l))\n                        ↑i)) =\n                  true then\n            if h' :\n                ∀ (i : Fin φ_l),\n                  (Option.get\n                        (Option.join\n                          (get?\n                            (List.map Sum.getLeft\n                              (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                  (finRange φ_l) ++\n                                l))\n                            ↑i))\n                        (_ :\n                          Option.isSome\n                              (Option.join\n                                (get?\n                                  (List.map Sum.getLeft\n                                    (List.map\n                                        (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                        (finRange φ_l) ++\n                                      l))\n                                  ↑i)) =\n                            true)).fst =\n                    { fst := φ_n, snd := rel φ_R ts }.fst then\n              { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                snd :=\n                  rel φ_R fun i =>\n                    Eq.mp\n                      (_ :\n                        Term L\n                            (α ⊕\n                              Fin\n                                (Option.get\n                                    (Option.join\n                                      (get?\n                                        (List.map Sum.getLeft\n                                          (List.map\n                                              (fun i =>\n                                                Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                              (finRange φ_l) ++\n                                            l))\n                                        ↑i))\n                                    (_ :\n                                      Option.isSome\n                                          (Option.join\n                                            (get?\n                                              (List.map Sum.getLeft\n                                                (List.map\n                                                    (fun i =>\n                                                      Sum.inl\n                                                        { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                    (finRange φ_l) ++\n                                                  l))\n                                              ↑i)) =\n                                        true)).fst) =\n                          Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                      (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).snd }\n            else default\n          else default,\n          {\n            val :=\n              drop φ_l\n                (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                    (finRange φ_l) ++\n                  l),\n            property :=\n              (_ :\n                SizeOf.sizeOf\n                    (drop φ_l\n                      (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                          (finRange φ_l) ++\n                        l)) ≤\n                  max 1\n                    (SizeOf.sizeOf\n                      (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                        Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                          (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                              (finRange φ_l) ++\n                            l)))) }).fst =\n      { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(if h :\n                ∀ (i : Fin φ_l),\n                  Option.isSome\n                      (Option.join\n                        (get?\n                          (List.map Sum.getLeft\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l))\n                          ↑i)) =\n                    true then\n              if h' :\n                  ∀ (i : Fin φ_l),\n                    (Option.get\n                          (Option.join\n                            (get?\n                              (List.map Sum.getLeft\n                                (List.map\n                                    (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                    (finRange φ_l) ++\n                                  l))\n                              ↑i))\n                          (_ :\n                            Option.isSome\n                                (Option.join\n                                  (get?\n                                    (List.map Sum.getLeft\n                                      (List.map\n                                          (fun i =>\n                                            Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                          (finRange φ_l) ++\n                                        l))\n                                    ↑i)) =\n                              true)).fst =\n                      { fst := φ_n, snd := rel φ_R ts }.fst then\n                { fst := { fst := φ_n, snd := rel φ_R ts }.fst,\n                  snd :=\n                    rel φ_R fun i =>\n                      Eq.mp\n                        (_ :\n                          Term L\n                              (α ⊕\n                                Fin\n                                  (Option.get\n                                      (Option.join\n                                        (get?\n                                          (List.map Sum.getLeft\n                                            (List.map\n                                                (fun i =>\n                                                  Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                (finRange φ_l) ++\n                                              l))\n                                          ↑i))\n                                      (_ :\n                                        Option.isSome\n                                            (Option.join\n                                              (get?\n                                                (List.map Sum.getLeft\n                                                  (List.map\n                                                      (fun i =>\n                                                        Sum.inl\n                                                          { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                                      (finRange φ_l) ++\n                                                    l))\n                                                ↑i)) =\n                                          true)).fst) =\n                            Term L (α ⊕ Fin { fst := φ_n, snd := rel φ_R ts }.fst))\n                        (Option.get\n                            (Option.join\n                              (get?\n                                (List.map Sum.getLeft\n                                  (List.map\n                                      (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                      (finRange φ_l) ++\n                                    l))\n                                ↑i))\n                            (_ :\n                              Option.isSome\n                                  (Option.join\n                                    (get?\n                                      (List.map Sum.getLeft\n                                        (List.map\n                                            (fun i =>\n                                              Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                            (finRange φ_l) ++\n                                          l))\n                                      ↑i)) =\n                                true)).snd }\n              else default\n            else default,\n            {\n              val :=\n                drop φ_l\n                  (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                      (finRange φ_l) ++\n                    l),\n              property :=\n                (_ :\n                  SizeOf.sizeOf\n                      (drop φ_l\n                        (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                            (finRange φ_l) ++\n                          l)) ≤\n                    max 1\n                      (SizeOf.sizeOf\n                        (Sum.inr (Sum.inl { fst := φ_l, snd := φ_R }) ::\n                          Sum.inr (Sum.inr { fst := φ_n, snd := rel φ_R ts }.fst) ::\n                            (List.map (fun i => Sum.inl { fst := { fst := φ_n, snd := rel φ_R ts }.fst, snd := ts i })\n                                (finRange φ_l) ++\n                              l)))) }).snd =\n      l"],"goalsAfter":[],"content":"· have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]"},{"tailPos":13744,"headPos":12159,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l"],"goalsAfter":[],"content":"rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n      · have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]"},{"tailPos":13744,"headPos":12156,"goalsBefore":["case h.mk.rel\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn φ_n φ_l : ℕ\nφ_R : Relations L φ_l\nts : Fin φ_l → Term L (α ⊕ Fin φ_n)\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).fst = { fst := φ_n, snd := rel φ_R ts } ∧\n    ↑(listDecode (listEncode { fst := φ_n, snd := rel φ_R ts }.snd ++ l)).snd = l","case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"· rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n      · have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]"},{"tailPos":13751,"headPos":13749,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l"],"content":"·"},{"tailPos":13767,"headPos":13756,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ listEncode f₂✝ ++ l)).snd = l"],"content":"listEncode,"},{"tailPos":13786,"headPos":13768,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ listEncode f₂✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd = l"],"content":"List.append_assoc,"},{"tailPos":13799,"headPos":13787,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 0) :: listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd = l"],"content":"cons_append,"},{"tailPos":13810,"headPos":13800,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ((fun this =>\n            (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n              { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                property :=\n                  (_ :\n                    SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                      max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n          (_ :\n            SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n              1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑((fun this =>\n              (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                  (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n                { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                  property :=\n                    (_ :\n                      SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                        max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n            (_ :\n              SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n                1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd =\n      l"],"content":"listDecode"},{"tailPos":13811,"headPos":13810,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ((fun this =>\n            (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n              { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                property :=\n                  (_ :\n                    SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                      max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n          (_ :\n            SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n              1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑((fun this =>\n              (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                  (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n                { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                  property :=\n                    (_ :\n                      SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                        max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n            (_ :\n              SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n                1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd =\n      l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ((fun this =>\n            (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n              { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                property :=\n                  (_ :\n                    SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                      max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n          (_ :\n            SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n              1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑((fun this =>\n              (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                  (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n                { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                  property :=\n                    (_ :\n                      SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                        max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n            (_ :\n              SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n                1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd =\n      l"],"content":"]"},{"tailPos":13811,"headPos":13752,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ((fun this =>\n            (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n              { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                property :=\n                  (_ :\n                    SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                      max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n          (_ :\n            SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n              1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑((fun this =>\n              (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                  (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n                { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                  property :=\n                    (_ :\n                      SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                        max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n            (_ :\n              SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n                1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd =\n      l"],"content":"rw [listEncode, List.append_assoc, cons_append, listDecode]"},{"tailPos":13835,"headPos":13818,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ ((fun this =>\n            (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n              { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                property :=\n                  (_ :\n                    SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                      max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n          (_ :\n            SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n              1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑((fun this =>\n              (sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n                  (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst,\n                { val := ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd,\n                  property :=\n                    (_ :\n                      SizeOf.sizeOf ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd ≤\n                        max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 0) :: (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))))) }))\n            (_ :\n              SizeOf.sizeOf ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd <\n                1 + (1 + 1) + SizeOf.sizeOf (listEncode f₁✝ ++ (listEncode f₂✝ ++ l)))).snd =\n      l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n        (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd = l"],"content":"simp only [] at *"},{"tailPos":13856,"headPos":13846,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n        (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd = l"],"content":"(ih1 _).1,"},{"tailPos":13867,"headPos":13857,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode f₂✝ ++ l)).snd = l"],"content":"(ih1 _).2,"},{"tailPos":13878,"headPos":13868,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode f₂✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } { fst := n✝, snd := f₂✝ } = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode f₂✝ ++ l)).snd = l"],"content":"(ih2 _).1,"},{"tailPos":13889,"headPos":13879,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } { fst := n✝, snd := f₂✝ } = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode f₂✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } { fst := n✝, snd := f₂✝ } = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧ l = l"],"content":"(ih2 _).2,"},{"tailPos":13898,"headPos":13890,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp { fst := n✝, snd := f₁✝ } { fst := n✝, snd := f₂✝ } = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧ l = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝, snd := f₁✝ }, { fst := n✝, snd := f₂✝ } with\n      | { fst := m, snd := φ }, { fst := n, snd := ψ } =>\n        if h : m = n then { fst := m, snd := φ ⟹ Eq.mp (_ : BoundedFormula L α n = BoundedFormula L α m) ψ }\n        else default) =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    l = l"],"content":"sigmaImp"},{"tailPos":13899,"headPos":13898,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝, snd := f₁✝ }, { fst := n✝, snd := f₂✝ } with\n      | { fst := m, snd := φ }, { fst := n, snd := ψ } =>\n        if h : m = n then { fst := m, snd := φ ⟹ Eq.mp (_ : BoundedFormula L α n = BoundedFormula L α m) ψ }\n        else default) =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    l = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝, snd := f₁✝ }, { fst := n✝, snd := f₂✝ } with\n      | { fst := m, snd := φ }, { fst := n, snd := ψ } =>\n        if h : m = n then { fst := m, snd := φ ⟹ Eq.mp (_ : BoundedFormula L α n = BoundedFormula L α m) ψ }\n        else default) =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    l = l"],"content":"]"},{"tailPos":13899,"headPos":13842,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaImp (listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).fst\n        (listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).fst =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode ↑(listDecode (listEncode f₁✝ ++ (listEncode f₂✝ ++ l))).snd).snd = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝, snd := f₁✝ }, { fst := n✝, snd := f₂✝ } with\n      | { fst := m, snd := φ }, { fst := n, snd := ψ } =>\n        if h : m = n then { fst := m, snd := φ ⟹ Eq.mp (_ : BoundedFormula L α n = BoundedFormula L α m) ψ }\n        else default) =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    l = l"],"content":"rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]"},{"tailPos":13927,"headPos":13906,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝, snd := f₁✝ }, { fst := n✝, snd := f₂✝ } with\n      | { fst := m, snd := φ }, { fst := n, snd := ψ } =>\n        if h : m = n then { fst := m, snd := φ ⟹ Eq.mp (_ : BoundedFormula L α n = BoundedFormula L α m) ψ }\n        else default) =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    l = l"],"goalsAfter":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := f₁✝ ⟹ Eq.mp (_ : BoundedFormula L α n✝ = BoundedFormula L α n✝) f₂✝ } =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    True"],"content":"simp only [dite_true]"},{"tailPos":13958,"headPos":13934,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₁✝ ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧ ↑(listDecode (listEncode f₁✝ ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f₂✝ ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧ ↑(listDecode (listEncode f₂✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ { fst := n✝, snd := f₁✝ ⟹ Eq.mp (_ : BoundedFormula L α n✝ = BoundedFormula L α n✝) f₂✝ } =\n      { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    True"],"goalsAfter":[],"content":"exact ⟨rfl, trivial⟩"},{"tailPos":13958,"headPos":13752,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l"],"goalsAfter":[],"content":"rw [listEncode, List.append_assoc, cons_append, listDecode]\n      simp only [] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]\n      simp only [dite_true]\n      exact ⟨rfl, trivial⟩"},{"tailPos":13958,"headPos":13749,"goalsBefore":["case h.mk.imp\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf₁✝ f₂✝ : BoundedFormula L α n✝\nih1 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ }.snd ++ l)).snd = l\nih2 :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₂✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝, snd := f₂✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).fst = { fst := n✝, snd := f₁✝ ⟹ f₂✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := f₁✝ ⟹ f₂✝ }.snd ++ l)).snd = l","case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"· rw [listEncode, List.append_assoc, cons_append, listDecode]\n      simp only [] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]\n      simp only [dite_true]\n      exact ⟨rfl, trivial⟩"},{"tailPos":13965,"headPos":13963,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"content":"·"},{"tailPos":13981,"headPos":13970,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 1) :: listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 1) :: listEncode f✝ ++ l)).snd = l"],"content":"listEncode,"},{"tailPos":13994,"headPos":13982,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 1) :: listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 1) :: listEncode f✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l))).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l))).snd = l"],"content":"cons_append,"},{"tailPos":14005,"headPos":13995,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l))).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l))).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n          { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n            property :=\n              (_ :\n                SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).fst =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n            { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).snd =\n      l"],"content":"listDecode"},{"tailPos":14006,"headPos":14005,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n          { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n            property :=\n              (_ :\n                SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).fst =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n            { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n          { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n            property :=\n              (_ :\n                SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).fst =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n            { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).snd =\n      l"],"content":"]"},{"tailPos":14006,"headPos":13966,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n          { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n            property :=\n              (_ :\n                SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).fst =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n            { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).snd =\n      l"],"content":"rw [listEncode, cons_append, listDecode]"},{"tailPos":14022,"headPos":14013,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n          { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n            property :=\n              (_ :\n                SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                  max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).fst =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(sigmaAll (listDecode (listEncode f✝ ++ l)).fst,\n            { val := ↑(listDecode (listEncode f✝ ++ l)).snd,\n              property :=\n                (_ :\n                  SizeOf.sizeOf ↑(listDecode (listEncode f✝ ++ l)).snd ≤\n                    max 1 (SizeOf.sizeOf (Sum.inr (Sum.inr 1) :: (listEncode f✝ ++ l)))) }).snd =\n      l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"content":"simp only"},{"tailPos":14046,"headPos":14029,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"content":"simp only [] at *"},{"tailPos":14066,"headPos":14057,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll { fst := n✝ + 1, snd := f✝ } = { fst := n✝, snd := ∀'f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"content":"(ih _).1,"},{"tailPos":14076,"headPos":14067,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll { fst := n✝ + 1, snd := f✝ } = { fst := n✝, snd := ∀'f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll { fst := n✝ + 1, snd := f✝ } = { fst := n✝, snd := ∀'f✝ } ∧ l = l"],"content":"(ih _).2,"},{"tailPos":14085,"headPos":14077,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll { fst := n✝ + 1, snd := f✝ } = { fst := n✝, snd := ∀'f✝ } ∧ l = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝ + 1, snd := f✝ } with\n      | { fst := Nat.succ n, snd := φ } => { fst := n, snd := ∀'φ }\n      | x => default) =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    l = l"],"content":"sigmaAll"},{"tailPos":14086,"headPos":14085,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝ + 1, snd := f✝ } with\n      | { fst := Nat.succ n, snd := φ } => { fst := n, snd := ∀'φ }\n      | x => default) =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    l = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝ + 1, snd := f✝ } with\n      | { fst := Nat.succ n, snd := φ } => { fst := n, snd := ∀'φ }\n      | x => default) =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    l = l"],"content":"]"},{"tailPos":14086,"headPos":14053,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ sigmaAll (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode f✝ ++ l)).snd = l"],"goalsAfter":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝ + 1, snd := f✝ } with\n      | { fst := Nat.succ n, snd := φ } => { fst := n, snd := ∀'φ }\n      | x => default) =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    l = l"],"content":"rw [(ih _).1, (ih _).2, sigmaAll]"},{"tailPos":14113,"headPos":14093,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode f✝ ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧ ↑(listDecode (listEncode f✝ ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (match { fst := n✝ + 1, snd := f✝ } with\n      | { fst := Nat.succ n, snd := φ } => { fst := n, snd := ∀'φ }\n      | x => default) =\n      { fst := n✝, snd := ∀'f✝ } ∧\n    l = l"],"goalsAfter":[],"content":"exact ⟨rfl, rfl⟩"},{"tailPos":14113,"headPos":13966,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":[],"content":"rw [listEncode, cons_append, listDecode]\n      simp only\n      simp only [] at *\n      rw [(ih _).1, (ih _).2, sigmaAll]\n      exact ⟨rfl, rfl⟩"},{"tailPos":14113,"headPos":13963,"goalsBefore":["case h.mk.all\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl✝ : List ((n : ℕ) × BoundedFormula L α n)\nn n✝ : ℕ\nf✝ : BoundedFormula L α (n✝ + 1)\nih :\n  ∀ (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).fst = { fst := n✝ + 1, snd := f✝ } ∧\n      ↑(listDecode (listEncode { fst := n✝ + 1, snd := f✝ }.snd ++ l)).snd = l\nl : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)\n⊢ (listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).fst = { fst := n✝, snd := ∀'f✝ } ∧\n    ↑(listDecode (listEncode { fst := n✝, snd := ∀'f✝ }.snd ++ l)).snd = l"],"goalsAfter":[],"content":"· rw [listEncode, cons_append, listDecode]\n      simp only\n      simp only [] at *\n      rw [(ih _).1, (ih _).2, sigmaAll]\n      exact ⟨rfl, rfl⟩"},{"tailPos":14113,"headPos":11703,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"goalsAfter":[],"content":"rintro ⟨n, φ⟩\n    induction' φ with _ _ _ _ φ_n φ_l φ_R ts _ _ _ ih1 ih2 _ _ ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n      · have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]\n    · rw [listEncode, List.append_assoc, cons_append, listDecode]\n      simp only [] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]\n      simp only [dite_true]\n      exact ⟨rfl, trivial⟩\n    · rw [listEncode, cons_append, listDecode]\n      simp only\n      simp only [] at *\n      rw [(ih _).1, (ih _).2, sigmaAll]\n      exact ⟨rfl, rfl⟩"},{"tailPos":14113,"headPos":11700,"goalsBefore":["case h\nL : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ ∀ (φ : (n : ℕ) × BoundedFormula L α n) (l : List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)),\n    (listDecode (listEncode φ.snd ++ l)).fst = φ ∧ ↑(listDecode (listEncode φ.snd ++ l)).snd = l"],"goalsAfter":[],"content":"· rintro ⟨n, φ⟩\n    induction' φ with _ _ _ _ φ_n φ_l φ_R ts _ _ _ ih1 ih2 _ _ ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n      · have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]\n    · rw [listEncode, List.append_assoc, cons_append, listDecode]\n      simp only [] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]\n      simp only [dite_true]\n      exact ⟨rfl, trivial⟩\n    · rw [listEncode, cons_append, listDecode]\n      simp only\n      simp only [] at *\n      rw [(ih _).1, (ih _).2, sigmaAll]\n      exact ⟨rfl, rfl⟩"},{"tailPos":14113,"headPos":11419,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"goalsAfter":[],"content":"suffices h : ∀ (φ : Σn, L.BoundedFormula α n) (l),\n      (listDecode (listEncode φ.2 ++ l)).1 = φ ∧ (listDecode (listEncode φ.2 ++ l)).2.1 = l\n  · induction' l with φ l _\n    · rw [List.nil_bind]\n      simp [listDecode]\n    · rw [cons_bind, (h φ _).1, headI_cons]\n  · rintro ⟨n, φ⟩\n    induction' φ with _ _ _ _ φ_n φ_l φ_R ts _ _ _ ih1 ih2 _ _ ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n      · have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]\n    · rw [listEncode, List.append_assoc, cons_append, listDecode]\n      simp only [] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]\n      simp only [dite_true]\n      exact ⟨rfl, trivial⟩\n    · rw [listEncode, cons_append, listDecode]\n      simp only\n      simp only [] at *\n      rw [(ih _).1, (ih _).2, sigmaAll]\n      exact ⟨rfl, rfl⟩"},{"tailPos":11416,"headPos":11414,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"goalsAfter":[],"content":"by"},{"tailPos":14113,"headPos":11414,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.139469\nP : Type ?u.139472\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nl : List ((n : ℕ) × BoundedFormula L α n)\n⊢ (listDecode (List.bind l fun φ => listEncode φ.snd)).fst = headI l"],"goalsAfter":[],"content":"by\n  suffices h : ∀ (φ : Σn, L.BoundedFormula α n) (l),\n      (listDecode (listEncode φ.2 ++ l)).1 = φ ∧ (listDecode (listEncode φ.2 ++ l)).2.1 = l\n  · induction' l with φ l _\n    · rw [List.nil_bind]\n      simp [listDecode]\n    · rw [cons_bind, (h φ _).1, headI_cons]\n  · rintro ⟨n, φ⟩\n    induction' φ with _ _ _ _ φ_n φ_l φ_R ts _ _ _ ih1 ih2 _ _ ih <;> intro l\n    · rw [listEncode, singleton_append, listDecode]\n      simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n      · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n      · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n    · rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n      · have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft (List.map (fun i : Fin φ_l =>\n          Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n            Σn, L.Term (Sum α (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n          intro i\n          simp only [Option.join, map_append, map_map, Option.bind_eq_some, id.def, exists_eq_right,\n            get?_eq_some, length_append, length_map, length_finRange]\n          refine' ⟨lt_of_lt_of_le i.2 le_self_add, _⟩\n          rw [get_append, get_map]\n          · simp only [Sum.getLeft, get_finRange, Fin.eta, Function.comp_apply, eq_self_iff_true,\n              heq_iff_eq, and_self_iff]\n          · simp only [length_map, length_finRange, is_lt]\n        rw [dif_pos]\n        swap\n        · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n        rw [dif_pos]\n        swap\n        · intro i\n          obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [h2]\n        simp only [Sigma.mk.inj_iff, heq_eq_eq, rel.injEq, true_and]\n        refine' ⟨funext fun i => _, _⟩\n        · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n          rw [eq_mp_eq_cast, cast_eq_iff_heq]\n          exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n        rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n          drop_eq_nil_of_le, nil_append]\n        rw [length_map, length_finRange]\n    · rw [listEncode, List.append_assoc, cons_append, listDecode]\n      simp only [] at *\n      rw [(ih1 _).1, (ih1 _).2, (ih2 _).1, (ih2 _).2, sigmaImp]\n      simp only [dite_true]\n      exact ⟨rfl, trivial⟩\n    · rw [listEncode, cons_append, listDecode]\n      simp only\n      simp only [] at *\n      rw [(ih _).1, (ih _).2, sigmaAll]\n      exact ⟨rfl, rfl⟩"},{"tailPos":14570,"headPos":14533,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (List.bind [φ] fun φ => listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"content":"have h := listDecode_encode_list [φ]"},{"tailPos":14593,"headPos":14579,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (List.bind [φ] fun φ => listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"content":"bind_singleton"},{"tailPos":14594,"headPos":14593,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"content":"]"},{"tailPos":14599,"headPos":14575,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (List.bind [φ] fun φ => listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"content":"rw [bind_singleton] at h"},{"tailPos":14613,"headPos":14604,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (listDecode (listEncode φ.snd)).fst = some φ"],"content":"simp only"},{"tailPos":14623,"headPos":14622,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (listDecode (listEncode φ.snd)).fst = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (headI [φ]) = some φ"],"content":"h"},{"tailPos":14624,"headPos":14623,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (headI [φ]) = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (headI [φ]) = some φ"],"content":"]"},{"tailPos":14624,"headPos":14618,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (listDecode (listEncode φ.snd)).fst = some φ"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (headI [φ]) = some φ"],"content":"rw [h]"},{"tailPos":14632,"headPos":14629,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\nh : (listDecode (listEncode φ.snd)).fst = headI [φ]\n⊢ some (headI [φ]) = some φ"],"goalsAfter":[],"content":"rfl"},{"tailPos":14632,"headPos":14533,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":[],"content":"have h := listDecode_encode_list [φ]\n    rw [bind_singleton] at h\n    simp only\n    rw [h]\n    rfl"},{"tailPos":14528,"headPos":14526,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":[],"content":"by"},{"tailPos":14632,"headPos":14526,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.157173\nP : Type ?u.157176\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\nφ : (n : ℕ) × BoundedFormula L α n\n⊢ (fun l => some (listDecode l).fst) ((fun φ => listEncode φ.snd) φ) = some φ"],"goalsAfter":[],"content":"by\n    have h := listDecode_encode_list [φ]\n    rw [bind_singleton] at h\n    simp only\n    rw [h]\n    rfl"},{"tailPos":15231,"headPos":15162,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × BoundedFormula L α n) ≤ max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#List BoundedFormula.encoding.Γ) ≤ lift (max ℵ₀ (lift (#α) + lift (card L)))"],"content":"refine' lift_le.1 (BoundedFormula.encoding.card_le_card_list.trans _)"},{"tailPos":15250,"headPos":15238,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#List BoundedFormula.encoding.Γ) ≤ lift (max ℵ₀ (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ≤ lift (max ℵ₀ (lift (#α) + lift (card L)))"],"content":"encoding_Γ,"},{"tailPos":15276,"headPos":15251,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#List ((k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ≤ lift (max ℵ₀ (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (max (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ℵ₀) ≤\n    lift (max ℵ₀ (lift (#α) + lift (card L)))"],"content":"mk_list_eq_max_mk_aleph0,"},{"tailPos":15286,"headPos":15277,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (max (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ℵ₀) ≤\n    lift (max ℵ₀ (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) (lift ℵ₀) ≤\n    lift (max ℵ₀ (lift (#α) + lift (card L)))"],"content":"lift_max,"},{"tailPos":15299,"headPos":15287,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) (lift ℵ₀) ≤\n    lift (max ℵ₀ (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ℵ₀ ≤\n    lift (max ℵ₀ (lift (#α) + lift (card L)))"],"content":"lift_aleph0,"},{"tailPos":15309,"headPos":15300,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ℵ₀ ≤\n    lift (max ℵ₀ (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ℵ₀ ≤\n    max (lift ℵ₀) (lift (lift (#α) + lift (card L)))"],"content":"lift_max,"},{"tailPos":15322,"headPos":15310,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ℵ₀ ≤\n    max (lift ℵ₀) (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ℵ₀ ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"lift_aleph0,"},{"tailPos":15337,"headPos":15327,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max (lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ)) ℵ₀ ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L))) ∧\n    ℵ₀ ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"max_le_iff"},{"tailPos":15338,"headPos":15337,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L))) ∧\n    ℵ₀ ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L))) ∧\n    ℵ₀ ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"]"},{"tailPos":15338,"headPos":15234,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#List BoundedFormula.encoding.Γ) ≤ lift (max ℵ₀ (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L))) ∧\n    ℵ₀ ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"rw [encoding_Γ, mk_list_eq_max_mk_aleph0, lift_max, lift_aleph0, lift_max, lift_aleph0,\n    max_le_iff]"},{"tailPos":15373,"headPos":15341,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L))) ∧\n    ℵ₀ ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"refine' ⟨_, le_max_left _ _⟩"},{"tailPos":15387,"headPos":15380,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (#(k : ℕ) × Term L (α ⊕ Fin k)) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"mk_sum,"},{"tailPos":15404,"headPos":15388,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (#(k : ℕ) × Term L (α ⊕ Fin k)) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"Term.card_sigma,"},{"tailPos":15412,"headPos":15405,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (max ℵ₀ (#α ⊕ (i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (max ℵ₀ (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"mk_sum,"},{"tailPos":15435,"headPos":15413,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (max ℵ₀ (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"← add_eq_max le_rfl,"},{"tailPos":15443,"headPos":15436,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (#(n : ℕ) × Relations L n ⊕ ℕ)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift\n      (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift (#ℕ))) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"mk_sum,"},{"tailPos":15450,"headPos":15444,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift\n      (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift (#ℕ))) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift ℵ₀)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"mk_nat"},{"tailPos":15451,"headPos":15450,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift ℵ₀)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift ℵ₀)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"]"},{"tailPos":15451,"headPos":15376,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (#(k : ℕ) × Term L (α ⊕ Fin k) ⊕ (n : ℕ) × Relations L n ⊕ ℕ) ≤ max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift ℵ₀)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"content":"rw [mk_sum, Term.card_sigma, mk_sum, ← add_eq_max le_rfl, mk_sum, mk_nat]"},{"tailPos":15498,"headPos":15454,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ lift (lift (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (lift (#(n : ℕ) × Relations L n) + lift ℵ₀)) ≤\n    max ℵ₀ (lift (lift (#α) + lift (card L)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + (lift (#(n : ℕ) × Relations L n) + ℵ₀) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"simp only [lift_add, lift_lift, lift_aleph0]"},{"tailPos":15519,"headPos":15505,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + (lift (#(n : ℕ) × Relations L n) + ℵ₀) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n) + ℵ₀ ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"← add_assoc,"},{"tailPos":15529,"headPos":15520,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n) + ℵ₀ ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n)) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"add_comm,"},{"tailPos":15544,"headPos":15530,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n)) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (#(n : ℕ) × Relations L n) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"← add_assoc,"},{"tailPos":15559,"headPos":15545,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i))) + lift (#(n : ℕ) × Relations L n) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"← add_assoc,"},{"tailPos":15578,"headPos":15560,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"aleph0_add_aleph0,"},{"tailPos":15589,"headPos":15579,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + lift (#(n : ℕ) × Relations L n) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n)) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"add_assoc,"},{"tailPos":15612,"headPos":15594,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n)) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n)) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"add_eq_max le_rfl,"},{"tailPos":15623,"headPos":15613,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n)) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"content":"add_assoc,"},{"tailPos":15629,"headPos":15624,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (#Symbols L))"],"content":"card,"},{"tailPos":15638,"headPos":15630,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (#Symbols L))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (#(l : ℕ) × Functions L l ⊕ (l : ℕ) × Relations L l))"],"content":"Symbols,"},{"tailPos":15646,"headPos":15639,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (#(l : ℕ) × Functions L l ⊕ (l : ℕ) × Relations L l))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (lift (#(l : ℕ) × Functions L l) + lift (#(l : ℕ) × Relations L l)))"],"content":"mk_sum,"},{"tailPos":15656,"headPos":15647,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + lift (lift (#(l : ℕ) × Functions L l) + lift (#(l : ℕ) × Relations L l)))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + (lift (lift (#(l : ℕ) × Functions L l)) + lift (lift (#(l : ℕ) × Relations L l))))"],"content":"lift_add,"},{"tailPos":15667,"headPos":15657,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + (lift (lift (#(l : ℕ) × Functions L l)) + lift (lift (#(l : ℕ) × Relations L l))))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + (lift (#(l : ℕ) × Functions L l) + lift (lift (#(l : ℕ) × Relations L l))))"],"content":"lift_lift,"},{"tailPos":15677,"headPos":15668,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + (lift (#(l : ℕ) × Functions L l) + lift (lift (#(l : ℕ) × Relations L l))))"],"goalsAfter":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + (lift (#(l : ℕ) × Functions L l) + lift (#(l : ℕ) × Relations L l)))"],"content":"lift_lift"},{"tailPos":15678,"headPos":15677,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ max ℵ₀ (lift (#α) + (lift (#(i : ℕ) × Functions L i) + lift (#(n : ℕ) × Relations L n))) ≤\n    max ℵ₀ (lift (#α) + (lift (#(l : ℕ) × Functions L l) + lift (#(l : ℕ) × Relations L l)))"],"goalsAfter":[],"content":"]"},{"tailPos":15678,"headPos":15501,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ ℵ₀ + (lift (#α) + lift (#(i : ℕ) × Functions L i)) + (lift (#(n : ℕ) × Relations L n) + ℵ₀) ≤\n    max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":[],"content":"rw [← add_assoc, add_comm, ← add_assoc, ← add_assoc, aleph0_add_aleph0, add_assoc,\n    add_eq_max le_rfl, add_assoc, card, Symbols, mk_sum, lift_add, lift_lift, lift_lift]"},{"tailPos":15678,"headPos":15162,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × BoundedFormula L α n) ≤ max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":[],"content":"refine' lift_le.1 (BoundedFormula.encoding.card_le_card_list.trans _)\n  rw [encoding_Γ, mk_list_eq_max_mk_aleph0, lift_max, lift_aleph0, lift_max, lift_aleph0,\n    max_le_iff]\n  refine' ⟨_, le_max_left _ _⟩\n  rw [mk_sum, Term.card_sigma, mk_sum, ← add_eq_max le_rfl, mk_sum, mk_nat]\n  simp only [lift_add, lift_lift, lift_aleph0]\n  rw [← add_assoc, add_comm, ← add_assoc, ← add_assoc, aleph0_add_aleph0, add_assoc,\n    add_eq_max le_rfl, add_assoc, card, Symbols, mk_sum, lift_add, lift_lift, lift_lift]"},{"tailPos":15159,"headPos":15157,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × BoundedFormula L α n) ≤ max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":[],"content":"by"},{"tailPos":15678,"headPos":15157,"goalsBefore":["L : Language\nM : Type w\nN : Type ?u.158067\nP : Type ?u.158070\ninst✝² : Structure L M\ninst✝¹ : Structure L N\ninst✝ : Structure L P\nα : Type u'\nβ : Type v'\n⊢ (#(n : ℕ) × BoundedFormula L α n) ≤ max ℵ₀ (lift (#α) + lift (card L))"],"goalsAfter":[],"content":"by\n  refine' lift_le.1 (BoundedFormula.encoding.card_le_card_list.trans _)\n  rw [encoding_Γ, mk_list_eq_max_mk_aleph0, lift_max, lift_aleph0, lift_max, lift_aleph0,\n    max_le_iff]\n  refine' ⟨_, le_max_left _ _⟩\n  rw [mk_sum, Term.card_sigma, mk_sum, ← add_eq_max le_rfl, mk_sum, mk_nat]\n  simp only [lift_add, lift_lift, lift_aleph0]\n  rw [← add_assoc, add_comm, ← add_assoc, ← add_assoc, aleph0_add_aleph0, add_assoc,\n    add_eq_max le_rfl, add_assoc, card, Symbols, mk_sum, lift_add, lift_lift, lift_lift]"}]
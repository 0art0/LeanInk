[{"tailPos":2214,"headPos":2205,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"content":"simp_rw ["},{"tailPos":2255,"headPos":2214,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"content":"simp only [isBridge_iff_adj_and_forall_cycle_not_mem]"},{"tailPos":2256,"headPos":2205,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"content":"simp_rw [isBridge_iff_adj_and_forall_cycle_not_mem]"},{"tailPos":2270,"headPos":2259,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G →\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p","case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"content":"constructor"},{"tailPos":2275,"headPos":2273,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G →\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p","case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G →\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"content":"·"},{"tailPos":2292,"headPos":2276,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G →\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\nha : IsAcyclic G\nv w : V\nhvw : Adj G v w\n⊢ Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"content":"intro ha v w hvw"},{"tailPos":2316,"headPos":2297,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\nha : IsAcyclic G\nv w : V\nhvw : Adj G v w\n⊢ Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\nha : IsAcyclic G\nv w : V\nhvw : Adj G v w\n⊢ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"content":"apply And.intro hvw"},{"tailPos":2333,"headPos":2321,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\nha : IsAcyclic G\nv w : V\nhvw : Adj G v w\n⊢ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\nha : IsAcyclic G\nv w : V\nhvw : Adj G v w\nu : V\np : Walk G u u\nhp : Walk.IsCycle p\n⊢ ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"content":"intro u p hp"},{"tailPos":2351,"headPos":2338,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\nha : IsAcyclic G\nv w : V\nhvw : Adj G v w\nu : V\np : Walk G u u\nhp : Walk.IsCycle p\n⊢ ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"goalsAfter":[],"content":"cases ha p hp"},{"tailPos":2351,"headPos":2276,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G →\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p"],"goalsAfter":[],"content":"intro ha v w hvw\n    apply And.intro hvw\n    intro u p hp\n    cases ha p hp"},{"tailPos":2351,"headPos":2273,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G →\n    ∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p","case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"goalsAfter":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"content":"· intro ha v w hvw\n    apply And.intro hvw\n    intro u p hp\n    cases ha p hp"},{"tailPos":2356,"headPos":2354,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"goalsAfter":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"content":"·"},{"tailPos":2389,"headPos":2357,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"goalsAfter":["case mpr.nil\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv : V\nhp : Walk.IsCycle Walk.nil\n⊢ False","case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"content":"rintro hb v (_ | ⟨ha, p⟩) hp"},{"tailPos":2396,"headPos":2394,"goalsBefore":["case mpr.nil\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv : V\nhp : Walk.IsCycle Walk.nil\n⊢ False","case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"goalsAfter":["case mpr.nil\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv : V\nhp : Walk.IsCycle Walk.nil\n⊢ False"],"content":"·"},{"tailPos":2416,"headPos":2397,"goalsBefore":["case mpr.nil\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv : V\nhp : Walk.IsCycle Walk.nil\n⊢ False"],"goalsAfter":[],"content":"exact hp.not_of_nil"},{"tailPos":2416,"headPos":2394,"goalsBefore":["case mpr.nil\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv : V\nhp : Walk.IsCycle Walk.nil\n⊢ False","case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"goalsAfter":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"content":"· exact hp.not_of_nil"},{"tailPos":2423,"headPos":2421,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"goalsAfter":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"content":"·"},{"tailPos":2444,"headPos":2424,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"goalsAfter":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges (Walk.cons ha p)"],"content":"apply (hb ha).2 _ hp"},{"tailPos":2470,"headPos":2455,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges (Walk.cons ha p)"],"goalsAfter":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) :: Walk.edges p"],"content":"Walk.edges_cons"},{"tailPos":2471,"headPos":2470,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) :: Walk.edges p"],"goalsAfter":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) :: Walk.edges p"],"content":"]"},{"tailPos":2471,"headPos":2451,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges (Walk.cons ha p)"],"goalsAfter":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) :: Walk.edges p"],"content":"rw [Walk.edges_cons]"},{"tailPos":2502,"headPos":2478,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Quotient.mk (Sym2.Rel.setoid V) (v, v✝) :: Walk.edges p"],"goalsAfter":[],"content":"apply List.mem_cons_self"},{"tailPos":2502,"headPos":2424,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"goalsAfter":[],"content":"apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self"},{"tailPos":2502,"headPos":2421,"goalsBefore":["case mpr.cons\nV : Type u\nG : SimpleGraph V\nhb :\n  ∀ ⦃v w : V⦄,\n    Adj G v w →\n      Adj G v w ∧ ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p\nv v✝ : V\nha : Adj G v v✝\np : Walk G v✝ v\nhp : Walk.IsCycle (Walk.cons ha p)\n⊢ False"],"goalsAfter":[],"content":"· apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self"},{"tailPos":2502,"headPos":2357,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"goalsAfter":[],"content":"rintro hb v (_ | ⟨ha, p⟩) hp\n    · exact hp.not_of_nil\n    · apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self"},{"tailPos":2502,"headPos":2354,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (∀ ⦃v w : V⦄,\n      Adj G v w →\n        Adj G v w ∧\n          ∀ ⦃u : V⦄ (p : Walk G u u), Walk.IsCycle p → ¬Quotient.mk (Sym2.Rel.setoid V) (v, w) ∈ Walk.edges p) →\n    IsAcyclic G"],"goalsAfter":[],"content":"· rintro hb v (_ | ⟨ha, p⟩) hp\n    · exact hp.not_of_nil\n    · apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self"},{"tailPos":2502,"headPos":2205,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"goalsAfter":[],"content":"simp_rw [isBridge_iff_adj_and_forall_cycle_not_mem]\n  constructor\n  · intro ha v w hvw\n    apply And.intro hvw\n    intro u p hp\n    cases ha p hp\n  · rintro hb v (_ | ⟨ha, p⟩) hp\n    · exact hp.not_of_nil\n    · apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self"},{"tailPos":2202,"headPos":2200,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"goalsAfter":[],"content":"by"},{"tailPos":2502,"headPos":2200,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))"],"goalsAfter":[],"content":"by\n  simp_rw [isBridge_iff_adj_and_forall_cycle_not_mem]\n  constructor\n  · intro ha v w hvw\n    apply And.intro hvw\n    intro u p hp\n    cases ha p hp\n  · rintro hb v (_ | ⟨ha, p⟩) hp\n    · exact hp.not_of_nil\n    · apply (hb ha).2 _ hp\n      rw [Walk.edges_cons]\n      apply List.mem_cons_self"},{"tailPos":2780,"headPos":2727,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃e : Sym2 V⦄, e ∈ edgeSet G → IsBridge G e"],"goalsAfter":[],"content":"simp [isAcyclic_iff_forall_adj_isBridge, Sym2.forall]"},{"tailPos":2724,"headPos":2722,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃e : Sym2 V⦄, e ∈ edgeSet G → IsBridge G e"],"goalsAfter":[],"content":"by"},{"tailPos":2780,"headPos":2722,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsAcyclic G ↔ ∀ ⦃e : Sym2 V⦄, e ∈ edgeSet G → IsBridge G e"],"goalsAfter":[],"content":"by\n  simp [isAcyclic_iff_forall_adj_isBridge, Sym2.forall]"},{"tailPos":3026,"headPos":3003,"goalsBefore":["V : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np q : Path G v w\n⊢ p = q"],"goalsAfter":["case mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\nq : Path G v w\np : Walk G v w\nhp : Walk.IsPath p\n⊢ { val := p, property := hp } = q"],"content":"obtain ⟨p, hp⟩ := p"},{"tailPos":3052,"headPos":3029,"goalsBefore":["case mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\nq : Path G v w\np : Walk G v w\nhp : Walk.IsPath p\n⊢ { val := p, property := hp } = q"],"goalsAfter":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ { val := p, property := hp } = { val := q, property := hq }"],"content":"obtain ⟨q, hq⟩ := q"},{"tailPos":3075,"headPos":3059,"goalsBefore":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ { val := p, property := hp } = { val := q, property := hq }"],"goalsAfter":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ p = q"],"content":"Subtype.mk.injEq"},{"tailPos":3076,"headPos":3075,"goalsBefore":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ p = q"],"goalsAfter":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ p = q"],"content":"]"},{"tailPos":3076,"headPos":3055,"goalsBefore":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ { val := p, property := hp } = { val := q, property := hq }"],"goalsAfter":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ p = q"],"content":"rw [Subtype.mk.injEq]"},{"tailPos":3149,"headPos":3111,"goalsBefore":["case mk.mk.nil\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ : V\nhp : Walk.IsPath Walk.nil\nq : Walk G u✝ u✝\nhq : Walk.IsPath q\n⊢ Walk.nil = q"],"goalsAfter":["case mk.mk.nil.refl\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ : V\nhp hq : Walk.IsPath Walk.nil\n⊢ Walk.nil = Walk.nil"],"content":"cases (Walk.isPath_iff_eq_nil _).mp hq"},{"tailPos":3157,"headPos":3154,"goalsBefore":["case mk.mk.nil.refl\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ : V\nhp hq : Walk.IsPath Walk.nil\n⊢ Walk.nil = Walk.nil"],"goalsAfter":[],"content":"rfl"},{"tailPos":3157,"headPos":3111,"goalsBefore":["case mk.mk.nil\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ : V\nhp : Walk.IsPath Walk.nil\nq : Walk G u✝ u✝\nhq : Walk.IsPath q\n⊢ Walk.nil = q"],"goalsAfter":[],"content":"cases (Walk.isPath_iff_eq_nil _).mp hq\n    rfl"},{"tailPos":3157,"headPos":3098,"goalsBefore":["case mk.mk.nil\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ : V\nhp : Walk.IsPath Walk.nil\nq : Walk G u✝ u✝\nhq : Walk.IsPath q\n⊢ Walk.nil = q"],"goalsAfter":[],"content":"| nil =>\n    cases (Walk.isPath_iff_eq_nil _).mp hq\n    rfl"},{"tailPos":3219,"headPos":3186,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"content":"isAcyclic_iff_forall_adj_isBridge"},{"tailPos":3220,"headPos":3219,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"content":"]"},{"tailPos":3225,"headPos":3182,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"content":"rw [isAcyclic_iff_forall_adj_isBridge] at h"},{"tailPos":3245,"headPos":3230,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : ∀ ⦃v w : V⦄, Adj G v w → IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (v, w))\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝))\n⊢ Walk.cons ph p = q"],"content":"specialize h ph"},{"tailPos":3296,"headPos":3254,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝))\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Adj G u✝ v✝ ∧ ∀ (p : Walk G u✝ v✝), Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"isBridge_iff_adj_and_forall_walk_mem_edges"},{"tailPos":3297,"headPos":3296,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Adj G u✝ v✝ ∧ ∀ (p : Walk G u✝ v✝), Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Adj G u✝ v✝ ∧ ∀ (p : Walk G u✝ v✝), Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"]"},{"tailPos":3302,"headPos":3250,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : IsBridge G (Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝))\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Adj G u✝ v✝ ∧ ∀ (p : Walk G u✝ v✝), Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h"},{"tailPos":3344,"headPos":3307,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Adj G u✝ v✝ ∧ ∀ (p : Walk G u✝ v✝), Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges (Walk.append q (Walk.reverse p))\n⊢ Walk.cons ph p = q"],"content":"replace h := h.2 (q.append p.reverse)"},{"tailPos":3439,"headPos":3349,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges (Walk.append q (Walk.reverse p))\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q ∨ Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse'] at h"},{"tailPos":3461,"headPos":3444,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q ∨ Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q\n⊢ Walk.cons ph p = q","case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"cases' h with h h"},{"tailPos":3468,"headPos":3466,"goalsBefore":["case mk.mk.cons.inl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q\n⊢ Walk.cons ph p = q","case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q\n⊢ Walk.cons ph p = q"],"content":"·"},{"tailPos":3525,"headPos":3497,"goalsBefore":["case mk.mk.cons.inl.nil\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ u✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ u✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nhq : Walk.IsPath Walk.nil\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges Walk.nil\n⊢ Walk.cons ph p = Walk.nil"],"goalsAfter":[],"content":"simp [Walk.isPath_def] at hp"},{"tailPos":3525,"headPos":3488,"goalsBefore":["case mk.mk.cons.inl.nil\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ u✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ u✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nhq : Walk.IsPath Walk.nil\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges Walk.nil\n⊢ Walk.cons ph p = Walk.nil"],"goalsAfter":[],"content":"| nil => simp [Walk.isPath_def] at hp"},{"tailPos":3578,"headPos":3558,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath (Walk.cons h✝ q)\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"Walk.cons_isPath_iff"},{"tailPos":3579,"headPos":3578,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"]"},{"tailPos":3588,"headPos":3554,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath (Walk.cons h✝ q)\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"rw [Walk.cons_isPath_iff] at hp hq"},{"tailPos":3667,"headPos":3597,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : (v✝¹ = v✝ ∨ u✝ = v✝ ∧ v✝¹ = u✝) ∨ Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h"},{"tailPos":3725,"headPos":3676,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : (v✝¹ = v✝ ∨ u✝ = v✝ ∧ v✝¹ = u✝) ∨ Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inl.inl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h"},{"tailPos":3736,"headPos":3734,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inl.inl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"·"},{"tailPos":3757,"headPos":3737,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inl.inl.refl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nhq : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\n⊢ Walk.cons ph p = Walk.cons h✝ p"],"content":"cases ih hp.1 q hq.1"},{"tailPos":3771,"headPos":3768,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inl.refl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nhq : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\n⊢ Walk.cons ph p = Walk.cons h✝ p"],"goalsAfter":[],"content":"rfl"},{"tailPos":3771,"headPos":3737,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":[],"content":"cases ih hp.1 q hq.1\n          rfl"},{"tailPos":3771,"headPos":3734,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inl.refl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"· cases ih hp.1 q hq.1\n          rfl"},{"tailPos":3782,"headPos":3780,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"·"},{"tailPos":3793,"headPos":3783,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":[],"content":"simp at hq"},{"tailPos":3793,"headPos":3780,"goalsBefore":["case mk.mk.cons.inl.cons.inl.inr.intro\nV : Type u\nG✝ G : SimpleGraph V\nv w v✝ w✝ : V\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nph : Adj G v✝ v✝\nhp : Walk.IsPath p ∧ ¬v✝ ∈ Walk.support p\nh✝ : Adj G v✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬v✝ ∈ Walk.support q\n⊢ Walk.cons ph p = Walk.cons h✝ q","case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"· simp at hq"},{"tailPos":3804,"headPos":3802,"goalsBefore":["case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":["case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"content":"·"},{"tailPos":3862,"headPos":3805,"goalsBefore":["case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":[],"content":"exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2"},{"tailPos":3862,"headPos":3802,"goalsBefore":["case mk.mk.cons.inl.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath q ∧ ¬u✝ ∈ Walk.support q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges q\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":[],"content":"· exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2"},{"tailPos":3862,"headPos":3554,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath (Walk.cons h✝ q)\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":[],"content":"rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2"},{"tailPos":3862,"headPos":3532,"goalsBefore":["case mk.mk.cons.inl.cons\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝¹ w✝ : V\nph : Adj G u✝ v✝¹\np : Walk G v✝¹ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝¹ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nv✝ : V\nh✝ : Adj G u✝ v✝\nq : Walk G v✝ w✝\nhq : Walk.IsPath (Walk.cons h✝ q)\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝¹) ∈ Walk.edges (Walk.cons h✝ q)\n⊢ Walk.cons ph p = Walk.cons h✝ q"],"goalsAfter":[],"content":"| cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2"},{"tailPos":3862,"headPos":3469,"goalsBefore":["case mk.mk.cons.inl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q\n⊢ Walk.cons ph p = q"],"content":"cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2"},{"tailPos":3862,"headPos":3466,"goalsBefore":["case mk.mk.cons.inl\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges q\n⊢ Walk.cons ph p = q","case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"· cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2"},{"tailPos":3869,"headPos":3867,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"·"},{"tailPos":3894,"headPos":3874,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"Walk.cons_isPath_iff"},{"tailPos":3895,"headPos":3894,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"]"},{"tailPos":3901,"headPos":3870,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"content":"rw [Walk.cons_isPath_iff] at hp"},{"tailPos":3965,"headPos":3908,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath p ∧ ¬u✝ ∈ Walk.support p\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":[],"content":"exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3965,"headPos":3870,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":[],"content":"rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3965,"headPos":3867,"goalsBefore":["case mk.mk.cons.inr\nV : Type u\nG✝ G : SimpleGraph V\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\nh : Quotient.mk (Sym2.Rel.setoid V) (u✝, v✝) ∈ Walk.edges p\n⊢ Walk.cons ph p = q"],"goalsAfter":[],"content":"· rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3965,"headPos":3182,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"goalsAfter":[],"content":"rw [isAcyclic_iff_forall_adj_isBridge] at h\n    specialize h ph\n    rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse'] at h\n    cases' h with h h\n    · cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3965,"headPos":3160,"goalsBefore":["case mk.mk.cons\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w u✝ v✝ w✝ : V\nph : Adj G u✝ v✝\np : Walk G v✝ w✝\nih : Walk.IsPath p → ∀ (q : Walk G v✝ w✝), Walk.IsPath q → p = q\nhp : Walk.IsPath (Walk.cons ph p)\nq : Walk G u✝ w✝\nhq : Walk.IsPath q\n⊢ Walk.cons ph p = q"],"goalsAfter":[],"content":"| cons ph p ih =>\n    rw [isAcyclic_iff_forall_adj_isBridge] at h\n    specialize h ph\n    rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse'] at h\n    cases' h with h h\n    · cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3965,"headPos":3079,"goalsBefore":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ p = q"],"goalsAfter":["case mk.mk\nV : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ p = q"],"content":"induction p with\n  | nil =>\n    cases (Walk.isPath_iff_eq_nil _).mp hq\n    rfl\n  | cons ph p ih =>\n    rw [isAcyclic_iff_forall_adj_isBridge] at h\n    specialize h ph\n    rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse'] at h\n    cases' h with h h\n    · cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3965,"headPos":3003,"goalsBefore":["V : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np q : Path G v w\n⊢ p = q"],"goalsAfter":[],"content":"obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  rw [Subtype.mk.injEq]\n  induction p with\n  | nil =>\n    cases (Walk.isPath_iff_eq_nil _).mp hq\n    rfl\n  | cons ph p ih =>\n    rw [isAcyclic_iff_forall_adj_isBridge] at h\n    specialize h ph\n    rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse'] at h\n    cases' h with h h\n    · cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":3000,"headPos":2998,"goalsBefore":["V : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np q : Path G v w\n⊢ p = q"],"goalsAfter":[],"content":"by"},{"tailPos":3965,"headPos":2998,"goalsBefore":["V : Type u\nG✝ G : SimpleGraph V\nh : IsAcyclic G\nv w : V\np q : Path G v w\n⊢ p = q"],"goalsAfter":[],"content":"by\n  obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  rw [Subtype.mk.injEq]\n  induction p with\n  | nil =>\n    cases (Walk.isPath_iff_eq_nil _).mp hq\n    rfl\n  | cons ph p ih =>\n    rw [isAcyclic_iff_forall_adj_isBridge] at h\n    specialize h ph\n    rw [isBridge_iff_adj_and_forall_walk_mem_edges] at h\n    replace h := h.2 (q.append p.reverse)\n    simp only [Walk.edges_append, Walk.edges_reverse, List.mem_append, List.mem_reverse'] at h\n    cases' h with h h\n    · cases q with\n      | nil => simp [Walk.isPath_def] at hp\n      | cons _ q =>\n        rw [Walk.cons_isPath_iff] at hp hq\n        simp only [Walk.edges_cons, List.mem_cons, Sym2.eq_iff, true_and] at h\n        rcases h with (⟨h, rfl⟩ | ⟨rfl, rfl⟩) | h\n        · cases ih hp.1 q hq.1\n          rfl\n        · simp at hq\n        · exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hq.2\n    · rw [Walk.cons_isPath_iff] at hp\n      exact absurd (Walk.fst_mem_support_of_mem_edges _ h) hp.2"},{"tailPos":4157,"headPos":4145,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\n⊢ IsAcyclic G"],"goalsAfter":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nc : Walk G v v\nhc : Walk.IsCycle c\n⊢ False"],"content":"intro v c hc"},{"tailPos":4202,"headPos":4160,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nc : Walk G v v\nhc : Walk.IsCycle c\n⊢ False"],"goalsAfter":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nc : Walk G v v\nhc : Walk.IsTrail c ∧ ¬c = Walk.nil ∧ List.Nodup (List.tail (Walk.support c))\n⊢ False"],"content":"simp only [Walk.isCycle_def, Ne.def] at hc"},{"tailPos":4245,"headPos":4229,"goalsBefore":["case nil\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nhc : Walk.IsTrail Walk.nil ∧ ¬Walk.nil = Walk.nil ∧ List.Nodup (List.tail (Walk.support Walk.nil))\n⊢ False"],"goalsAfter":[],"content":"cases hc.2.1 rfl"},{"tailPos":4245,"headPos":4220,"goalsBefore":["case nil\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nhc : Walk.IsTrail Walk.nil ∧ ¬Walk.nil = Walk.nil ∧ List.Nodup (List.tail (Walk.support Walk.nil))\n⊢ False"],"goalsAfter":[],"content":"| nil => cases hc.2.1 rfl"},{"tailPos":4356,"headPos":4268,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc :\n  Walk.IsTrail (Walk.cons ha c') ∧ ¬Walk.cons ha c' = Walk.nil ∧ List.Nodup (List.tail (Walk.support (Walk.cons ha c')))\n⊢ False"],"goalsAfter":["case cons\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\n⊢ False"],"content":"simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons, true_and_iff] at hc"},{"tailPos":4421,"headPos":4388,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\n⊢ Walk.IsPath c'"],"goalsAfter":[],"content":"simp only [Walk.isPath_def, hc.2]"},{"tailPos":4387,"headPos":4385,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\n⊢ Walk.IsPath c'"],"goalsAfter":[],"content":"by"},{"tailPos":4421,"headPos":4385,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\n⊢ Walk.IsPath c'"],"goalsAfter":[],"content":"by simp only [Walk.isPath_def, hc.2]"},{"tailPos":4449,"headPos":4361,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\n⊢ False"],"goalsAfter":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : { val := c', property := (_ : Walk.IsPath c') } = Path.singleton (_ : Adj G v✝ v)\n⊢ False"],"content":"specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)"},{"tailPos":4473,"headPos":4458,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : { val := c', property := (_ : Walk.IsPath c') } = Path.singleton (_ : Adj G v✝ v)\n⊢ False"],"goalsAfter":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh :\n  { val := c', property := (_ : Walk.IsPath c') } =\n    { val := Walk.cons (_ : Adj G v✝ v) Walk.nil, property := (_ : Walk.IsPath (Walk.cons (_ : Adj G v✝ v) Walk.nil)) }\n⊢ False"],"content":"Path.singleton,"},{"tailPos":4490,"headPos":4474,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh :\n  { val := c', property := (_ : Walk.IsPath c') } =\n    { val := Walk.cons (_ : Adj G v✝ v) Walk.nil, property := (_ : Walk.IsPath (Walk.cons (_ : Adj G v✝ v) Walk.nil)) }\n⊢ False"],"goalsAfter":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : c' = Walk.cons (_ : Adj G v✝ v) Walk.nil\n⊢ False"],"content":"Subtype.mk.injEq"},{"tailPos":4491,"headPos":4490,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : c' = Walk.cons (_ : Adj G v✝ v) Walk.nil\n⊢ False"],"goalsAfter":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : c' = Walk.cons (_ : Adj G v✝ v) Walk.nil\n⊢ False"],"content":"]"},{"tailPos":4496,"headPos":4454,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : { val := c', property := (_ : Walk.IsPath c') } = Path.singleton (_ : Adj G v✝ v)\n⊢ False"],"goalsAfter":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : c' = Walk.cons (_ : Adj G v✝ v) Walk.nil\n⊢ False"],"content":"rw [Path.singleton, Subtype.mk.injEq] at h"},{"tailPos":4515,"headPos":4501,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc : (Walk.IsTrail c' ∧ ¬Quotient.mk (Sym2.Rel.setoid V) (v, v✝) ∈ Walk.edges c') ∧ List.Nodup (Walk.support c')\nh : c' = Walk.cons (_ : Adj G v✝ v) Walk.nil\n⊢ False"],"goalsAfter":[],"content":"simp [h] at hc"},{"tailPos":4515,"headPos":4268,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc :\n  Walk.IsTrail (Walk.cons ha c') ∧ ¬Walk.cons ha c' = Walk.nil ∧ List.Nodup (List.tail (Walk.support (Walk.cons ha c')))\n⊢ False"],"goalsAfter":[],"content":"simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons, true_and_iff] at hc\n    specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)\n    rw [Path.singleton, Subtype.mk.injEq] at h\n    simp [h] at hc"},{"tailPos":4515,"headPos":4248,"goalsBefore":["case cons\nV : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv v✝ : V\nha : Adj G v v✝\nc' : Walk G v✝ v\nhc :\n  Walk.IsTrail (Walk.cons ha c') ∧ ¬Walk.cons ha c' = Walk.nil ∧ List.Nodup (List.tail (Walk.support (Walk.cons ha c')))\n⊢ False"],"goalsAfter":[],"content":"| cons ha c' =>\n    simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons, true_and_iff] at hc\n    specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)\n    rw [Path.singleton, Subtype.mk.injEq] at h\n    simp [h] at hc"},{"tailPos":4515,"headPos":4205,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nc : Walk G v v\nhc : Walk.IsTrail c ∧ ¬c = Walk.nil ∧ List.Nodup (List.tail (Walk.support c))\n⊢ False"],"goalsAfter":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\nv : V\nc : Walk G v v\nhc : Walk.IsTrail c ∧ ¬c = Walk.nil ∧ List.Nodup (List.tail (Walk.support c))\n⊢ False"],"content":"cases c with\n  | nil => cases hc.2.1 rfl\n  | cons ha c' =>\n    simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons, true_and_iff] at hc\n    specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)\n    rw [Path.singleton, Subtype.mk.injEq] at h\n    simp [h] at hc"},{"tailPos":4515,"headPos":4145,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\n⊢ IsAcyclic G"],"goalsAfter":[],"content":"intro v c hc\n  simp only [Walk.isCycle_def, Ne.def] at hc\n  cases c with\n  | nil => cases hc.2.1 rfl\n  | cons ha c' =>\n    simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons, true_and_iff] at hc\n    specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)\n    rw [Path.singleton, Subtype.mk.injEq] at h\n    simp [h] at hc"},{"tailPos":4142,"headPos":4140,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\n⊢ IsAcyclic G"],"goalsAfter":[],"content":"by"},{"tailPos":4515,"headPos":4140,"goalsBefore":["V : Type u\nG : SimpleGraph V\nh : ∀ (v w : V) (p q : Path G v w), p = q\n⊢ IsAcyclic G"],"goalsAfter":[],"content":"by\n  intro v c hc\n  simp only [Walk.isCycle_def, Ne.def] at hc\n  cases c with\n  | nil => cases hc.2.1 rfl\n  | cons ha c' =>\n    simp only [Walk.cons_isTrail_iff, Walk.support_cons, List.tail_cons, true_and_iff] at hc\n    specialize h _ _ ⟨c', by simp only [Walk.isPath_def, hc.2]⟩ (Path.singleton ha.symm)\n    rw [Path.singleton, Subtype.mk.injEq] at h\n    simp [h] at hc"},{"tailPos":4990,"headPos":4979,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsTree G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ Connected G ∧ IsAcyclic G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"IsTree_iff,"},{"tailPos":5016,"headPos":4991,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ Connected G ∧ IsAcyclic G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"isAcyclic_iff_path_unique"},{"tailPos":5017,"headPos":5016,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"]"},{"tailPos":5017,"headPos":4975,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsTree G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["V : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"rw [IsTree_iff, isAcyclic_iff_path_unique]"},{"tailPos":5031,"headPos":5020,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) → Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p","case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"constructor"},{"tailPos":5036,"headPos":5034,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) → Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p","case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) → Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"·"},{"tailPos":5056,"headPos":5037,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) → Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\n⊢ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"rintro ⟨hc, hu⟩"},{"tailPos":5089,"headPos":5061,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\n⊢ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\n⊢ ∀ (v w : V), ∃! p, Walk.IsPath p"],"content":"refine ⟨hc.nonempty, ?_⟩"},{"tailPos":5103,"headPos":5094,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\n⊢ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\n⊢ ∃! p, Walk.IsPath p"],"content":"intro v w"},{"tailPos":5137,"headPos":5108,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\n⊢ ∃! p, Walk.IsPath p"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\n⊢ ∃! p, Walk.IsPath p"],"content":"let q := (hc v w).some.toPath"},{"tailPos":5147,"headPos":5142,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\n⊢ ∃! p, Walk.IsPath p"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\n⊢ (fun p => Walk.IsPath p) ↑q ∧ ∀ (y : Walk G v w), (fun p => Walk.IsPath p) y → y = ↑q"],"content":"use q"},{"tailPos":5189,"headPos":5152,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\n⊢ (fun p => Walk.IsPath p) ↑q ∧ ∀ (y : Walk G v w), (fun p => Walk.IsPath p) y → y = ↑q"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\n⊢ ∀ (y : Walk G v w), Walk.IsPath y → y = ↑(Walk.toPath (Nonempty.some (_ : Reachable G v w)))"],"content":"simp only [true_and_iff, Path.isPath]"},{"tailPos":5204,"headPos":5194,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\n⊢ ∀ (y : Walk G v w), Walk.IsPath y → y = ↑(Walk.toPath (Nonempty.some (_ : Reachable G v w)))"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\np : Walk G v w\nhp : Walk.IsPath p\n⊢ p = ↑(Walk.toPath (Nonempty.some (_ : Reachable G v w)))"],"content":"intro p hp"},{"tailPos":5236,"headPos":5209,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nhu : ∀ ⦃v w : V⦄ (p q : Path G v w), p = q\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\np : Walk G v w\nhp : Walk.IsPath p\n⊢ p = ↑(Walk.toPath (Nonempty.some (_ : Reachable G v w)))"],"goalsAfter":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\np : Walk G v w\nhp : Walk.IsPath p\nhu : { val := p, property := hp } = q\n⊢ p = ↑(Walk.toPath (Nonempty.some (_ : Reachable G v w)))"],"content":"specialize hu ⟨p, hp⟩ q"},{"tailPos":5268,"headPos":5241,"goalsBefore":["case mp.intro\nV : Type u\nG : SimpleGraph V\nhc : Connected G\nv w : V\nq : Path G v w := Walk.toPath (Nonempty.some (_ : Reachable G v w))\np : Walk G v w\nhp : Walk.IsPath p\nhu : { val := p, property := hp } = q\n⊢ p = ↑(Walk.toPath (Nonempty.some (_ : Reachable G v w)))"],"goalsAfter":[],"content":"exact Subtype.ext_iff.mp hu"},{"tailPos":5268,"headPos":5037,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) → Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":[],"content":"rintro ⟨hc, hu⟩\n    refine ⟨hc.nonempty, ?_⟩\n    intro v w\n    let q := (hc v w).some.toPath\n    use q\n    simp only [true_and_iff, Path.isPath]\n    intro p hp\n    specialize hu ⟨p, hp⟩ q\n    exact Subtype.ext_iff.mp hu"},{"tailPos":5268,"headPos":5034,"goalsBefore":["case mp\nV : Type u\nG : SimpleGraph V\n⊢ (Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q) → Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p","case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"· rintro ⟨hc, hu⟩\n    refine ⟨hc.nonempty, ?_⟩\n    intro v w\n    let q := (hc v w).some.toPath\n    use q\n    simp only [true_and_iff, Path.isPath]\n    intro p hp\n    specialize hu ⟨p, hp⟩ q\n    exact Subtype.ext_iff.mp hu"},{"tailPos":5273,"headPos":5271,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"·"},{"tailPos":5292,"headPos":5274,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr.intro\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"rintro ⟨hV, h⟩"},{"tailPos":5329,"headPos":5297,"goalsBefore":["case mpr.intro\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Preconnected G","case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"refine ⟨Connected.mk ?_, ?_⟩"},{"tailPos":5336,"headPos":5334,"goalsBefore":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Preconnected G","case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Preconnected G"],"content":"·"},{"tailPos":5346,"headPos":5337,"goalsBefore":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Preconnected G"],"goalsAfter":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\nv w : V\n⊢ Reachable G v w"],"content":"intro v w"},{"tailPos":5379,"headPos":5353,"goalsBefore":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\nv w : V\n⊢ Reachable G v w"],"goalsAfter":["case mpr.intro.refine_1.intro\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\nv w : V\np : Walk G v w\nh✝ : (fun p => Walk.IsPath p) p ∧ ∀ (y : Walk G v w), (fun p => Walk.IsPath p) y → y = p\n⊢ Reachable G v w"],"content":"obtain ⟨p, _⟩ := h v w"},{"tailPos":5403,"headPos":5386,"goalsBefore":["case mpr.intro.refine_1.intro\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\nv w : V\np : Walk G v w\nh✝ : (fun p => Walk.IsPath p) p ∧ ∀ (y : Walk G v w), (fun p => Walk.IsPath p) y → y = p\n⊢ Reachable G v w"],"goalsAfter":[],"content":"exact p.reachable"},{"tailPos":5403,"headPos":5337,"goalsBefore":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Preconnected G"],"goalsAfter":[],"content":"intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable"},{"tailPos":5403,"headPos":5334,"goalsBefore":["case mpr.intro.refine_1\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ Preconnected G","case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"· intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable"},{"tailPos":5410,"headPos":5408,"goalsBefore":["case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"content":"·"},{"tailPos":5445,"headPos":5411,"goalsBefore":["case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":["case mpr.intro.refine_2.mk.mk\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ { val := p, property := hp } = { val := q, property := hq }"],"content":"rintro v w ⟨p, hp⟩ ⟨q, hq⟩"},{"tailPos":5497,"headPos":5452,"goalsBefore":["case mpr.intro.refine_2.mk.mk\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\nv w : V\np : Walk G v w\nhp : Walk.IsPath p\nq : Walk G v w\nhq : Walk.IsPath q\n⊢ { val := p, property := hp } = { val := q, property := hq }"],"goalsAfter":[],"content":"simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":5497,"headPos":5411,"goalsBefore":["case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":[],"content":"rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":5497,"headPos":5408,"goalsBefore":["case mpr.intro.refine_2\nV : Type u\nG : SimpleGraph V\nhV : Nonempty V\nh : ∀ (v w : V), ∃! p, Walk.IsPath p\n⊢ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":[],"content":"· rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":5497,"headPos":5274,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":[],"content":"rintro ⟨hV, h⟩\n    refine ⟨Connected.mk ?_, ?_⟩\n    · intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable\n    · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":5497,"headPos":5271,"goalsBefore":["case mpr\nV : Type u\nG : SimpleGraph V\n⊢ (Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p) → Connected G ∧ ∀ ⦃v w : V⦄ (p q : Path G v w), p = q"],"goalsAfter":[],"content":"· rintro ⟨hV, h⟩\n    refine ⟨Connected.mk ?_, ?_⟩\n    · intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable\n    · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":5497,"headPos":4975,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsTree G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":[],"content":"rw [IsTree_iff, isAcyclic_iff_path_unique]\n  constructor\n  · rintro ⟨hc, hu⟩\n    refine ⟨hc.nonempty, ?_⟩\n    intro v w\n    let q := (hc v w).some.toPath\n    use q\n    simp only [true_and_iff, Path.isPath]\n    intro p hp\n    specialize hu ⟨p, hp⟩ q\n    exact Subtype.ext_iff.mp hu\n  · rintro ⟨hV, h⟩\n    refine ⟨Connected.mk ?_, ?_⟩\n    · intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable\n    · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":5497,"headPos":4963,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsTree G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":[],"content":"classical\n  rw [IsTree_iff, isAcyclic_iff_path_unique]\n  constructor\n  · rintro ⟨hc, hu⟩\n    refine ⟨hc.nonempty, ?_⟩\n    intro v w\n    let q := (hc v w).some.toPath\n    use q\n    simp only [true_and_iff, Path.isPath]\n    intro p hp\n    specialize hu ⟨p, hp⟩ q\n    exact Subtype.ext_iff.mp hu\n  · rintro ⟨hV, h⟩\n    refine ⟨Connected.mk ?_, ?_⟩\n    · intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable\n    · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"},{"tailPos":4960,"headPos":4958,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsTree G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":[],"content":"by"},{"tailPos":5497,"headPos":4958,"goalsBefore":["V : Type u\nG : SimpleGraph V\n⊢ IsTree G ↔ Nonempty V ∧ ∀ (v w : V), ∃! p, Walk.IsPath p"],"goalsAfter":[],"content":"by\n  classical\n  rw [IsTree_iff, isAcyclic_iff_path_unique]\n  constructor\n  · rintro ⟨hc, hu⟩\n    refine ⟨hc.nonempty, ?_⟩\n    intro v w\n    let q := (hc v w).some.toPath\n    use q\n    simp only [true_and_iff, Path.isPath]\n    intro p hp\n    specialize hu ⟨p, hp⟩ q\n    exact Subtype.ext_iff.mp hu\n  · rintro ⟨hV, h⟩\n    refine ⟨Connected.mk ?_, ?_⟩\n    · intro v w\n      obtain ⟨p, _⟩ := h v w\n      exact p.reachable\n    · rintro v w ⟨p, hp⟩ ⟨q, hq⟩\n      simp only [ExistsUnique.unique (h v w) hp hq]"}]
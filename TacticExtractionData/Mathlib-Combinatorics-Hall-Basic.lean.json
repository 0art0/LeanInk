[{"tailPos":3216,"headPos":3163,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\n⊢ ↑(hallMatchingsOn t ι')"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\n⊢ (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) ∈ hallMatchingsOn t ι'"],"content":"refine' ⟨fun i => f.val ⟨i, h i.property⟩, _⟩"},{"tailPos":3249,"headPos":3219,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\n⊢ (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) ∈ hallMatchingsOn t ι'"],"goalsAfter":["case intro\nι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\nhinj : Function.Injective ↑f\nhc : ∀ (x : { x // x ∈ ι'' }), ↑f x ∈ t ↑x\n⊢ (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) ∈ hallMatchingsOn t ι'"],"content":"cases' f.property with hinj hc"},{"tailPos":3302,"headPos":3252,"goalsBefore":["case intro\nι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\nhinj : Function.Injective ↑f\nhc : ∀ (x : { x // x ∈ ι'' }), ↑f x ∈ t ↑x\n⊢ (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) ∈ hallMatchingsOn t ι'"],"goalsAfter":["case intro\nι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\nhinj : Function.Injective ↑f\nhc : ∀ (x : { x // x ∈ ι'' }), ↑f x ∈ t ↑x\n⊢ Function.Injective fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }"],"content":"refine' ⟨_, fun i => hc ⟨i, h i.property⟩⟩"},{"tailPos":3338,"headPos":3305,"goalsBefore":["case intro\nι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\nhinj : Function.Injective ↑f\nhc : ∀ (x : { x // x ∈ ι'' }), ↑f x ∈ t ↑x\n⊢ Function.Injective fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }"],"goalsAfter":["case intro.mk.mk\nι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\nhinj : Function.Injective ↑f\nhc : ∀ (x : { x // x ∈ ι'' }), ↑f x ∈ t ↑x\ni : ι\nhi : i ∈ ι'\nj : ι\nhj : j ∈ ι'\nhh :\n  (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) { val := i, property := hi } =\n    (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) { val := j, property := hj }\n⊢ { val := i, property := hi } = { val := j, property := hj }"],"content":"rintro ⟨i, hi⟩ ⟨j, hj⟩ hh"},{"tailPos":3384,"headPos":3341,"goalsBefore":["case intro.mk.mk\nι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\nhinj : Function.Injective ↑f\nhc : ∀ (x : { x // x ∈ ι'' }), ↑f x ∈ t ↑x\ni : ι\nhi : i ∈ ι'\nj : ι\nhj : j ∈ ι'\nhh :\n  (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) { val := i, property := hi } =\n    (fun i => ↑f { val := ↑i, property := (_ : ↑i ∈ ι'') }) { val := j, property := hj }\n⊢ { val := i, property := hi } = { val := j, property := hj }"],"goalsAfter":[],"content":"simpa only [Subtype.mk_eq_mk] using hinj hh"},{"tailPos":3384,"headPos":3163,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\n⊢ ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"refine' ⟨fun i => f.val ⟨i, h i.property⟩, _⟩\n  cases' f.property with hinj hc\n  refine' ⟨_, fun i => hc ⟨i, h i.property⟩⟩\n  rintro ⟨i, hi⟩ ⟨j, hj⟩ hh\n  simpa only [Subtype.mk_eq_mk] using hinj hh"},{"tailPos":3160,"headPos":3158,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\n⊢ ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"by"},{"tailPos":3384,"headPos":3158,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' ι'' : Finset ι\nh : ι' ⊆ ι''\nf : ↑(hallMatchingsOn t ι'')\n⊢ ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"by\n  refine' ⟨fun i => f.val ⟨i, h i.property⟩, _⟩\n  cases' f.property with hinj hc\n  refine' ⟨_, fun i => hc ⟨i, h i.property⟩⟩\n  rintro ⟨i, hi⟩ ⟨j, hj⟩ hh\n  simpa only [Subtype.mk_eq_mk] using hinj hh"},{"tailPos":3922,"headPos":3873,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ Nonempty ↑(hallMatchingsOn t ι')"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ ∃ x, x ∈ hallMatchingsOn t ι'"],"content":"refine' ⟨Classical.indefiniteDescription _ _⟩"},{"tailPos":4002,"headPos":3927,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ ∃ x, x ∈ hallMatchingsOn t ι'"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ ∀ (s : Finset { x // x ∈ ι' }), card s ≤ card (Finset.biUnion s fun i => t ↑i)"],"content":"apply (all_card_le_biUnion_card_iff_existsInjective' fun i : ι' => t i).mp"},{"tailPos":4015,"headPos":4007,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ ∀ (s : Finset { x // x ∈ ι' }), card s ≤ card (Finset.biUnion s fun i => t ↑i)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card s' ≤ card (Finset.biUnion s' fun i => t ↑i)"],"content":"intro s'"},{"tailPos":4054,"headPos":4020,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card s' ≤ card (Finset.biUnion s' fun i => t ↑i)"],"goalsAfter":["case h.e'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card s' = card (image Subtype.val s')","case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion (image Subtype.val s') t)"],"content":"convert h (s'.image (↑)) using 1"},{"tailPos":4119,"headPos":4059,"goalsBefore":["case h.e'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card s' = card (image Subtype.val s')","case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion (image Subtype.val s') t)"],"goalsAfter":["case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion (image Subtype.val s') t)"],"content":"simp only [card_image_of_injective s' Subtype.coe_injective]"},{"tailPos":4141,"headPos":4128,"goalsBefore":["case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion (image Subtype.val s') t)"],"goalsAfter":["case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion s' fun a => t ↑a)"],"content":"image_biUnion"},{"tailPos":4142,"headPos":4141,"goalsBefore":["case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion s' fun a => t ↑a)"],"goalsAfter":[],"content":"]"},{"tailPos":4142,"headPos":4124,"goalsBefore":["case h.e'_4\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\ns' : Finset { x // x ∈ ι' }\n⊢ card (Finset.biUnion s' fun i => t ↑i) = card (Finset.biUnion (image Subtype.val s') t)"],"goalsAfter":[],"content":"rw [image_biUnion]"},{"tailPos":4142,"headPos":3873,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ Nonempty ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"refine' ⟨Classical.indefiniteDescription _ _⟩\n    apply (all_card_le_biUnion_card_iff_existsInjective' fun i : ι' => t i).mp\n    intro s'\n    convert h (s'.image (↑)) using 1\n    simp only [card_image_of_injective s' Subtype.coe_injective]\n    rw [image_biUnion]"},{"tailPos":4142,"headPos":3859,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ Nonempty ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"classical\n    refine' ⟨Classical.indefiniteDescription _ _⟩\n    apply (all_card_le_biUnion_card_iff_existsInjective' fun i : ι' => t i).mp\n    intro s'\n    convert h (s'.image (↑)) using 1\n    simp only [card_image_of_injective s' Subtype.coe_injective]\n    rw [image_biUnion]"},{"tailPos":3856,"headPos":3854,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ Nonempty ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"by"},{"tailPos":4142,"headPos":3854,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nι' : Finset ι\n⊢ Nonempty ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"by\n  classical\n    refine' ⟨Classical.indefiniteDescription _ _⟩\n    apply (all_card_le_biUnion_card_iff_existsInjective' fun i : ι' => t i).mp\n    intro s'\n    convert h (s'.image (↑)) using 1\n    simp only [card_image_of_injective s' Subtype.coe_injective]\n    rw [image_biUnion]"},{"tailPos":4758,"headPos":4743,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"content":"hallMatchingsOn"},{"tailPos":4759,"headPos":4758,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"content":"]"},{"tailPos":4759,"headPos":4739,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"content":"rw [hallMatchingsOn]"},{"tailPos":4842,"headPos":4832,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t }"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ { x // x ∈ Finset.biUnion ι' t }"],"content":"rintro f i"},{"tailPos":4873,"headPos":4849,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ { x // x ∈ Finset.biUnion ι' t }"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ↑f i ∈ Finset.biUnion ι' t"],"content":"refine' ⟨f.val i, _⟩"},{"tailPos":4895,"headPos":4884,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ↑f i ∈ Finset.biUnion ι' t"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ∃ a, a ∈ ι' ∧ ↑f i ∈ t a"],"content":"mem_biUnion"},{"tailPos":4896,"headPos":4895,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ∃ a, a ∈ ι' ∧ ↑f i ∈ t a"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ∃ a, a ∈ ι' ∧ ↑f i ∈ t a"],"content":"]"},{"tailPos":4896,"headPos":4880,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ↑f i ∈ Finset.biUnion ι' t"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ∃ a, a ∈ ι' ∧ ↑f i ∈ t a"],"content":"rw [mem_biUnion]"},{"tailPos":4944,"headPos":4903,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\nf : ↑(hallMatchingsOn t ι')\ni : { x // x ∈ ι' }\n⊢ ∃ a, a ∈ ι' ∧ ↑f i ∈ t a"],"goalsAfter":[],"content":"exact ⟨i, i.property, f.property.2 i⟩"},{"tailPos":4944,"headPos":4832,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t }"],"goalsAfter":[],"content":"rintro f i\n      refine' ⟨f.val i, _⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩"},{"tailPos":4825,"headPos":4823,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t }"],"goalsAfter":[],"content":"by"},{"tailPos":4944,"headPos":4823,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t }"],"goalsAfter":[],"content":"by\n      rintro f i\n      refine' ⟨f.val i, _⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩"},{"tailPos":4944,"headPos":4764,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"content":"let g : hallMatchingsOn t ι' → ι' → ι'.biUnion t := by\n      rintro f i\n      refine' ⟨f.val i, _⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩"},{"tailPos":4976,"headPos":4949,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\n⊢ Finite ↑{f | Function.Injective f ∧ ∀ (x : { x // x ∈ ι' }), f x ∈ t ↑x}"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\n⊢ Function.Injective g"],"content":"apply Finite.of_injective g"},{"tailPos":4993,"headPos":4981,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\n⊢ Function.Injective g"],"goalsAfter":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : g f = g f'\n⊢ f = f'"],"content":"intro f f' h"},{"tailPos":5003,"headPos":4998,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : g f = g f'\n⊢ f = f'"],"goalsAfter":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : g f = g f'\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"content":"ext a"},{"tailPos":5031,"headPos":5012,"goalsBefore":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : g f = g f'\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"goalsAfter":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : ∀ (a : { x // x ∈ ι' }), g f a = g f' a\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"content":"Function.funext_iff"},{"tailPos":5032,"headPos":5031,"goalsBefore":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : ∀ (a : { x // x ∈ ι' }), g f a = g f' a\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"goalsAfter":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : ∀ (a : { x // x ∈ ι' }), g f a = g f' a\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"content":"]"},{"tailPos":5037,"headPos":5008,"goalsBefore":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : g f = g f'\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"goalsAfter":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : ∀ (a : { x // x ∈ ι' }), g f a = g f' a\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"content":"rw [Function.funext_iff] at h"},{"tailPos":5057,"headPos":5042,"goalsBefore":["case a.h\nι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\ng : ↑(hallMatchingsOn t ι') → { x // x ∈ ι' } → { x // x ∈ Finset.biUnion ι' t } :=\n  fun f i => { val := ↑f i, property := (_ : ↑f i ∈ Finset.biUnion ι' t) }\nf f' : ↑(hallMatchingsOn t ι')\nh : ∀ (a : { x // x ∈ ι' }), g f a = g f' a\na : { x // x ∈ ι' }\n⊢ ↑f a = ↑f' a"],"goalsAfter":[],"content":"simpa only [Subtype.mk.injEq] using h a"},{"tailPos":5057,"headPos":4739,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"rw [hallMatchingsOn]\n    let g : hallMatchingsOn t ι' → ι' → ι'.biUnion t := by\n      rintro f i\n      refine' ⟨f.val i, _⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩\n    apply Finite.of_injective g\n    intro f f' h\n    ext a\n    rw [Function.funext_iff] at h\n    simpa using h a"},{"tailPos":5057,"headPos":4725,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"classical\n    rw [hallMatchingsOn]\n    let g : hallMatchingsOn t ι' → ι' → ι'.biUnion t := by\n      rintro f i\n      refine' ⟨f.val i, _⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩\n    apply Finite.of_injective g\n    intro f f' h\n    ext a\n    rw [Function.funext_iff] at h\n    simpa using h a"},{"tailPos":4722,"headPos":4720,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"by"},{"tailPos":5057,"headPos":4720,"goalsBefore":["ι : Type u\nα : Type v\nt : ι → Finset α\nι' : Finset ι\n⊢ Finite ↑(hallMatchingsOn t ι')"],"goalsAfter":[],"content":"by\n  classical\n    rw [hallMatchingsOn]\n    let g : hallMatchingsOn t ι' → ι' → ι'.biUnion t := by\n      rintro f i\n      refine' ⟨f.val i, _⟩\n      rw [mem_biUnion]\n      exact ⟨i, i.property, f.property.2 i⟩\n    apply Finite.of_injective g\n    intro f f' h\n    ext a\n    rw [Function.funext_iff] at h\n    simpa using h a"},{"tailPos":5885,"headPos":5874,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"content":"constructor"},{"tailPos":5890,"headPos":5888,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"·"},{"tailPos":5898,"headPos":5891,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"intro h"},{"tailPos":6067,"headPos":5929,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"haveI : ∀ ι' : (Finset ι)ᵒᵖ, Nonempty ((hallMatchingsFunctor t).obj ι') := fun ι' =>\n      hallMatchingsOn.nonempty t h ι'.unop"},{"tailPos":6190,"headPos":6181,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite ((hallMatchingsFunctor t).obj ι')"],"content":"intro ι'"},{"tailPos":6223,"headPos":6203,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite ((hallMatchingsFunctor t).obj ι')"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite\n    ((CategoryTheory.Functor.mk\n          { obj := fun ι' => ↑(hallMatchingsOn t ι'.unop),\n            map := fun {ι' ι''} g f => hallMatchingsOn.restrict t (_ : ι''.unop ≤ ι'.unop) f }).obj\n      ι')"],"content":"hallMatchingsFunctor"},{"tailPos":6224,"headPos":6223,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite\n    ((CategoryTheory.Functor.mk\n          { obj := fun ι' => ↑(hallMatchingsOn t ι'.unop),\n            map := fun {ι' ι''} g f => hallMatchingsOn.restrict t (_ : ι''.unop ≤ ι'.unop) f }).obj\n      ι')"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite\n    ((CategoryTheory.Functor.mk\n          { obj := fun ι' => ↑(hallMatchingsOn t ι'.unop),\n            map := fun {ι' ι''} g f => hallMatchingsOn.restrict t (_ : ι''.unop ≤ ι'.unop) f }).obj\n      ι')"],"content":"]"},{"tailPos":6224,"headPos":6199,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite ((hallMatchingsFunctor t).obj ι')"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite\n    ((CategoryTheory.Functor.mk\n          { obj := fun ι' => ↑(hallMatchingsOn t ι'.unop),\n            map := fun {ι' ι''} g f => hallMatchingsOn.restrict t (_ : ι''.unop ≤ ι'.unop) f }).obj\n      ι')"],"content":"rw [hallMatchingsFunctor]"},{"tailPos":6247,"headPos":6233,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nι' : (Finset ι)ᵒᵖ\n⊢ Finite\n    ((CategoryTheory.Functor.mk\n          { obj := fun ι' => ↑(hallMatchingsOn t ι'.unop),\n            map := fun {ι' ι''} g f => hallMatchingsOn.restrict t (_ : ι''.unop ≤ ι'.unop) f }).obj\n      ι')"],"goalsAfter":[],"content":"infer_instance"},{"tailPos":6247,"headPos":6181,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')"],"goalsAfter":[],"content":"intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance"},{"tailPos":6172,"headPos":6170,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')"],"goalsAfter":[],"content":"by"},{"tailPos":6247,"headPos":6170,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')"],"goalsAfter":[],"content":"by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance"},{"tailPos":6247,"headPos":6088,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance"},{"tailPos":6383,"headPos":6294,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)"},{"tailPos":6473,"headPos":6452,"goalsBefore":["case mp.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp.intro.refine'_1\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ι → α","case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective ?mp.intro.refine'_1","case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ?mp.intro.refine'_1 x ∈ t x"],"content":"refine' ⟨_, _, _⟩"},{"tailPos":6482,"headPos":6480,"goalsBefore":["case mp.intro.refine'_1\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ι → α","case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective ?mp.intro.refine'_1","case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ?mp.intro.refine'_1 x ∈ t x"],"goalsAfter":["case mp.intro.refine'_1\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ι → α"],"content":"·"},{"tailPos":6655,"headPos":6612,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni : ι\n⊢ i ∈ {i}.op.unop"],"goalsAfter":[],"content":"simp only [Opposite.unop_op, mem_singleton]"},{"tailPos":6611,"headPos":6609,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni : ι\n⊢ i ∈ {i}.op.unop"],"goalsAfter":[],"content":"by"},{"tailPos":6655,"headPos":6609,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni : ι\n⊢ i ∈ {i}.op.unop"],"goalsAfter":[],"content":"by simp only [Opposite.unop_op, mem_singleton]"},{"tailPos":6658,"headPos":6538,"goalsBefore":["case mp.intro.refine'_1\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ι → α"],"goalsAfter":[],"content":"exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩"},{"tailPos":6658,"headPos":6480,"goalsBefore":["case mp.intro.refine'_1\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ι → α","case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective ?mp.intro.refine'_1","case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ?mp.intro.refine'_1 x ∈ t x"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }","case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"content":"·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩"},{"tailPos":6667,"headPos":6665,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }","case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }"],"content":"·"},{"tailPos":6715,"headPos":6705,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"content":"intro i i'"},{"tailPos":6776,"headPos":6772,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\n⊢ {i} ⊆ {i, i'}"],"goalsAfter":[],"content":"simp only [mem_singleton, singleton_subset_iff, mem_insert, true_or]"},{"tailPos":6771,"headPos":6769,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\n⊢ {i} ⊆ {i, i'}"],"goalsAfter":[],"content":"by"},{"tailPos":6776,"headPos":6769,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\n⊢ {i} ⊆ {i, i'}"],"goalsAfter":[],"content":"by simp"},{"tailPos":6776,"headPos":6724,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"content":"have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp"},{"tailPos":6839,"headPos":6835,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\n⊢ {i'} ⊆ {i, i'}"],"goalsAfter":[],"content":"simp only [mem_singleton, singleton_subset_iff, mem_insert, or_true]"},{"tailPos":6834,"headPos":6832,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\n⊢ {i'} ⊆ {i, i'}"],"goalsAfter":[],"content":"by"},{"tailPos":6839,"headPos":6832,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\n⊢ {i'} ⊆ {i, i'}"],"goalsAfter":[],"content":"by simp"},{"tailPos":6839,"headPos":6785,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\nsubi' : {i'} ⊆ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"content":"have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp"},{"tailPos":6876,"headPos":6852,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\nsubi' : {i'} ⊆ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"content":"← Finset.le_iff_subset"},{"tailPos":6877,"headPos":6876,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"content":"]"},{"tailPos":6891,"headPos":6848,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ⊆ {i, i'}\nsubi' : {i'} ⊆ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"content":"rw [← Finset.le_iff_subset] at subi subi'"},{"tailPos":6909,"headPos":6900,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i =\n      (fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }) i' →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) } = ↑(u {i'}.op) { val := i', property := (_ : i' ∈ {i'}) } → i = i'"],"content":"simp only"},{"tailPos":6962,"headPos":6922,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) } = ↑(u {i'}.op) { val := i', property := (_ : i' ∈ {i'}) } → i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑(u {i'}.op) { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"content":"← hu (CategoryTheory.homOfLE subi).op,"},{"tailPos":7003,"headPos":6963,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑(u {i'}.op) { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"content":"← hu (CategoryTheory.homOfLE subi').op"},{"tailPos":7004,"headPos":7003,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"content":"]"},{"tailPos":7004,"headPos":6918,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) } = ↑(u {i'}.op) { val := i', property := (_ : i' ∈ {i'}) } → i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"content":"rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]"},{"tailPos":7062,"headPos":7013,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"goalsAfter":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\nuii' : (hallMatchingsFunctor t).obj {i, i'}.op := u {i, i'}.op\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"content":"let uii' := u (Opposite.op ({i, i'} : Finset ι))"},{"tailPos":7125,"headPos":7071,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni i' : ι\nsubi : {i} ≤ {i, i'}\nsubi' : {i'} ≤ {i, i'}\nuii' : (hallMatchingsFunctor t).obj {i, i'}.op := u {i, i'}.op\n⊢ ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi).op (u {i, i'}.op))\n        { val := i, property := (_ : i ∈ {i}) } =\n      ↑((hallMatchingsFunctor t).map (CategoryTheory.homOfLE subi').op (u {i, i'}.op))\n        { val := i', property := (_ : i' ∈ {i'}) } →\n    i = i'"],"goalsAfter":[],"content":"exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)"},{"tailPos":7125,"headPos":6705,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }"],"goalsAfter":[],"content":"intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)"},{"tailPos":7125,"headPos":6665,"goalsBefore":["case mp.intro.refine'_2\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ Function.Injective fun i => ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) }","case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"goalsAfter":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"content":"· -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)"},{"tailPos":7134,"headPos":7132,"goalsBefore":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"goalsAfter":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"content":"·"},{"tailPos":7214,"headPos":7207,"goalsBefore":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"goalsAfter":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni : ι\n⊢ ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) } ∈ t i"],"content":"intro i"},{"tailPos":7275,"headPos":7223,"goalsBefore":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\ni : ι\n⊢ ↑(u {i}.op) { val := i, property := (_ : i ∈ {i}) } ∈ t i"],"goalsAfter":[],"content":"apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7275,"headPos":7207,"goalsBefore":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"goalsAfter":[],"content":"intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7275,"headPos":7132,"goalsBefore":["case mp.intro.refine'_3\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis✝ : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Finite ((hallMatchingsFunctor t).obj ι')\nu : (j : (Finset ι)ᵒᵖ) → (hallMatchingsFunctor t).obj j\nhu : u ∈ CategoryTheory.Functor.sections (hallMatchingsFunctor t)\n⊢ ∀ (x : ι), ↑(u {x}.op) { val := x, property := (_ : x ∈ {x}) } ∈ t x"],"goalsAfter":[],"content":"· -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7275,"headPos":6088,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7275,"headPos":6072,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nh : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nthis : ∀ (ι' : (Finset ι)ᵒᵖ), Nonempty ((hallMatchingsFunctor t).obj ι')\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"classical\n      haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7275,"headPos":5891,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"intro h\n    -- Set up the functor\n    haveI : ∀ ι' : (Finset ι)ᵒᵖ, Nonempty ((hallMatchingsFunctor t).obj ι') := fun ι' =>\n      hallMatchingsOn.nonempty t h ι'.unop\n    classical\n      haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7275,"headPos":5888,"goalsBefore":["case mp\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"content":"· intro h\n    -- Set up the functor\n    haveI : ∀ ι' : (Finset ι)ᵒᵖ, Nonempty ((hallMatchingsFunctor t).obj ι') := fun ι' =>\n      hallMatchingsOn.nonempty t h ι'.unop\n    classical\n      haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2"},{"tailPos":7280,"headPos":7278,"goalsBefore":["case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"content":"·"},{"tailPos":7382,"headPos":7352,"goalsBefore":["case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card s ≤ card (Finset.biUnion s t)"],"content":"rintro ⟨f, hf₁, hf₂⟩ s"},{"tailPos":7433,"headPos":7391,"goalsBefore":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"content":"← Finset.card_image_of_injective s hf₁"},{"tailPos":7434,"headPos":7433,"goalsBefore":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"content":"]"},{"tailPos":7434,"headPos":7387,"goalsBefore":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"content":"rw [← Finset.card_image_of_injective s hf₁]"},{"tailPos":7469,"headPos":7439,"goalsBefore":["case mpr.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ image f s ⊆ Finset.biUnion s t"],"content":"apply Finset.card_le_of_subset"},{"tailPos":7479,"headPos":7474,"goalsBefore":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ image f s ⊆ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ a✝ ∈ image f s → a✝ ∈ Finset.biUnion s t"],"content":"intro"},{"tailPos":7505,"headPos":7488,"goalsBefore":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ a✝ ∈ image f s → a✝ ∈ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → a✝ ∈ Finset.biUnion s t"],"content":"Finset.mem_image,"},{"tailPos":7524,"headPos":7506,"goalsBefore":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → a✝ ∈ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"content":"Finset.mem_biUnion"},{"tailPos":7525,"headPos":7524,"goalsBefore":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"content":"]"},{"tailPos":7525,"headPos":7484,"goalsBefore":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ a✝ ∈ image f s → a✝ ∈ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"content":"rw [Finset.mem_image, Finset.mem_biUnion]"},{"tailPos":7553,"headPos":7530,"goalsBefore":["case mpr.intro.intro.a\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"goalsAfter":["case mpr.intro.intro.a.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\nx : ι\nhx : x ∈ s\n⊢ ∃ a, a ∈ s ∧ f x ∈ t a"],"content":"rintro ⟨x, hx, rfl⟩"},{"tailPos":7584,"headPos":7558,"goalsBefore":["case mpr.intro.intro.a.intro.intro\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\nx : ι\nhx : x ∈ s\n⊢ ∃ a, a ∈ s ∧ f x ∈ t a"],"goalsAfter":[],"content":"exact ⟨x, hx, hf₂ x⟩"},{"tailPos":7584,"headPos":7352,"goalsBefore":["case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":[],"content":"rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← Finset.card_image_of_injective s hf₁]\n    apply Finset.card_le_of_subset\n    intro\n    rw [Finset.mem_image, Finset.mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":7584,"headPos":7278,"goalsBefore":["case mpr\nι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":[],"content":"· -- The reverse direction is a straightforward cardinality argument\n    rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← Finset.card_image_of_injective s hf₁]\n    apply Finset.card_le_of_subset\n    intro\n    rw [Finset.mem_image, Finset.mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":7584,"headPos":5874,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"constructor\n  · intro h\n    -- Set up the functor\n    haveI : ∀ ι' : (Finset ι)ᵒᵖ, Nonempty ((hallMatchingsFunctor t).obj ι') := fun ι' =>\n      hallMatchingsOn.nonempty t h ι'.unop\n    classical\n      haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2\n  · -- The reverse direction is a straightforward cardinality argument\n    rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← Finset.card_image_of_injective s hf₁]\n    apply Finset.card_le_of_subset\n    intro\n    rw [Finset.mem_image, Finset.mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":5871,"headPos":5869,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by"},{"tailPos":7584,"headPos":5869,"goalsBefore":["ι : Type u\nα : Type v\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by\n  constructor\n  · intro h\n    -- Set up the functor\n    haveI : ∀ ι' : (Finset ι)ᵒᵖ, Nonempty ((hallMatchingsFunctor t).obj ι') := fun ι' =>\n      hallMatchingsOn.nonempty t h ι'.unop\n    classical\n      haveI : ∀ ι' : (Finset ι)ᵒᵖ, Finite ((hallMatchingsFunctor t).obj ι') := by\n        intro ι'\n        rw [hallMatchingsFunctor]\n        infer_instance\n      -- Apply the compactness argument\n      obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)\n      -- Interpret the resulting section of the inverse limit\n      refine' ⟨_, _, _⟩\n      ·-- Build the matching function from the section\n        exact fun i =>\n          (u (Opposite.op ({i} : Finset ι))).val ⟨i, by simp only [Opposite.unop_op, mem_singleton]⟩\n      · -- Show that it is injective\n        intro i i'\n        have subi : ({i} : Finset ι) ⊆ {i, i'} := by simp\n        have subi' : ({i'} : Finset ι) ⊆ {i, i'} := by simp\n        rw [← Finset.le_iff_subset] at subi subi'\n        simp only\n        rw [← hu (CategoryTheory.homOfLE subi).op, ← hu (CategoryTheory.homOfLE subi').op]\n        let uii' := u (Opposite.op ({i, i'} : Finset ι))\n        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)\n      · -- Show that it maps each index to the corresponding finite set\n        intro i\n        apply (u (Opposite.op ({i} : Finset ι))).property.2\n  · -- The reverse direction is a straightforward cardinality argument\n    rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← Finset.card_image_of_injective s hf₁]\n    apply Finset.card_le_of_subset\n    intro\n    rw [Finset.mem_image, Finset.mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":8090,"headPos":8087,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":["case h\nα : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nx✝ : β\n⊢ x✝ ∈ Rel.image r ↑A ↔ x✝ ∈ ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"content":"ext"},{"tailPos":8177,"headPos":8141,"goalsBefore":["case h\nα : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nx✝ : β\n⊢ x✝ ∈ Rel.image r ↑A ↔ x✝ ∈ ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":[],"content":"simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":8177,"headPos":8087,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":[],"content":"ext\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":8082,"headPos":8080,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":[],"content":"by"},{"tailPos":8177,"headPos":8080,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":[],"content":"by\n    ext\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":8177,"headPos":7995,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Fintype ↑(Rel.image r ↑A)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑(Rel.image r ↑A)"],"content":"have h : Rel.image r A = (A.biUnion fun a => (Rel.image r {a}).toFinset : Set β) := by\n    ext\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":8185,"headPos":8184,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑(Rel.image r ↑A)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"content":"h"},{"tailPos":8186,"headPos":8185,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"content":"]"},{"tailPos":8186,"headPos":8180,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑(Rel.image r ↑A)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"content":"rw [h]"},{"tailPos":8212,"headPos":8189,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\nh : Rel.image r ↑A = ↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))\n⊢ Fintype ↑↑(Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))"],"goalsAfter":[],"content":"apply FinsetCoe.fintype"},{"tailPos":8212,"headPos":7995,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Fintype ↑(Rel.image r ↑A)"],"goalsAfter":[],"content":"have h : Rel.image r A = (A.biUnion fun a => (Rel.image r {a}).toFinset : Set β) := by\n    ext\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]\n  rw [h]\n  apply FinsetCoe.fintype"},{"tailPos":7992,"headPos":7990,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Fintype ↑(Rel.image r ↑A)"],"goalsAfter":[],"content":"by"},{"tailPos":8212,"headPos":7990,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nA : Finset α\n⊢ Fintype ↑(Rel.image r ↑A)"],"goalsAfter":[],"content":"by\n  have h : Rel.image r A = (A.biUnion fun a => (Rel.image r {a}).toFinset : Set β) := by\n    ext\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]\n  rw [h]\n  apply FinsetCoe.fintype"},{"tailPos":9148,"headPos":9110,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"let r' a := (Rel.image r {a}).toFinset"},{"tailPos":9247,"headPos":9240,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\n⊢ ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"content":"intro A"},{"tailPos":9277,"headPos":9256,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Finset.card (Set.toFinset (Rel.image r ↑A)) = Finset.card (Finset.biUnion A r')"],"content":"← Set.toFinset_card"},{"tailPos":9278,"headPos":9277,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Finset.card (Set.toFinset (Rel.image r ↑A)) = Finset.card (Finset.biUnion A r')"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Finset.card (Set.toFinset (Rel.image r ↑A)) = Finset.card (Finset.biUnion A r')"],"content":"]"},{"tailPos":9278,"headPos":9252,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Finset.card (Set.toFinset (Rel.image r ↑A)) = Finset.card (Finset.biUnion A r')"],"content":"rw [← Set.toFinset_card]"},{"tailPos":9298,"headPos":9283,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Finset.card (Set.toFinset (Rel.image r ↑A)) = Finset.card (Finset.biUnion A r')"],"goalsAfter":["case h\nα : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Set.toFinset (Rel.image r ↑A) = Finset.biUnion A r'"],"content":"apply congr_arg"},{"tailPos":9308,"headPos":9303,"goalsBefore":["case h\nα : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\n⊢ Set.toFinset (Rel.image r ↑A) = Finset.biUnion A r'"],"goalsAfter":["case h.a\nα : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\nb : β\n⊢ b ∈ Set.toFinset (Rel.image r ↑A) ↔ b ∈ Finset.biUnion A r'"],"content":"ext b"},{"tailPos":9395,"headPos":9359,"goalsBefore":["case h.a\nα : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nA : Finset α\nb : β\n⊢ b ∈ Set.toFinset (Rel.image r ↑A) ↔ b ∈ Finset.biUnion A r'"],"goalsAfter":[],"content":"simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9395,"headPos":9240,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\n⊢ ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"goalsAfter":[],"content":"intro A\n    rw [← Set.toFinset_card]\n    apply congr_arg\n    ext b\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9235,"headPos":9233,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\n⊢ ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"goalsAfter":[],"content":"by"},{"tailPos":9395,"headPos":9233,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\n⊢ ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')"],"goalsAfter":[],"content":"by\n    intro A\n    rw [← Set.toFinset_card]\n    apply congr_arg\n    ext b\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9395,"headPos":9151,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"have h : ∀ A : Finset α, Fintype.card (Rel.image r A) = (A.biUnion r').card := by\n    intro A\n    rw [← Set.toFinset_card]\n    apply congr_arg\n    ext b\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9546,"headPos":9510,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\n⊢ ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x"],"goalsAfter":[],"content":"simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9509,"headPos":9507,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\n⊢ ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x"],"goalsAfter":[],"content":"by"},{"tailPos":9546,"headPos":9507,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\n⊢ ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x"],"goalsAfter":[],"content":"by simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9546,"headPos":9442,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp [Rel.image, (Set.mem_toFinset)]"},{"tailPos":9566,"headPos":9549,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), f x ∈ Set.toFinset (Rel.image r {x})"],"content":"simp only [h, h']"},{"tailPos":9627,"headPos":9569,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\nr' : α → Finset β := fun a => Set.toFinset (Rel.image r {a})\nh : ∀ (A : Finset α), card ↑(Rel.image r ↑A) = Finset.card (Finset.biUnion A r')\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => Set.toFinset (Rel.image r {a}))) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), f x ∈ Set.toFinset (Rel.image r {x})"],"goalsAfter":[],"content":"apply Finset.all_card_le_biUnion_card_iff_exists_injective"},{"tailPos":9627,"headPos":9110,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":[],"content":"let r' a := (Rel.image r {a}).toFinset\n  have h : ∀ A : Finset α, Fintype.card (Rel.image r A) = (A.biUnion r').card := by\n    intro A\n    rw [← Set.toFinset_card]\n    apply congr_arg\n    ext b\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]\n  -- Porting note: added `Set.mem_toFinset`\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp [Rel.image, (Set.mem_toFinset)]\n  simp only [h, h']\n  apply Finset.all_card_le_biUnion_card_iff_exists_injective"},{"tailPos":9107,"headPos":9105,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":[],"content":"by"},{"tailPos":9627,"headPos":9105,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : DecidableEq β\nr : α → β → Prop\ninst✝ : (a : α) → Fintype ↑(Rel.image r {a})\n⊢ (∀ (A : Finset α), Finset.card A ≤ card ↑(Rel.image r ↑A)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":[],"content":"by\n  let r' a := (Rel.image r {a}).toFinset\n  have h : ∀ A : Finset α, Fintype.card (Rel.image r A) = (A.biUnion r').card := by\n    intro A\n    rw [← Set.toFinset_card]\n    apply congr_arg\n    ext b\n    -- Porting note: added `Set.mem_toFinset`\n    simp [Rel.image, (Set.mem_toFinset)]\n  -- Porting note: added `Set.mem_toFinset`\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp [Rel.image, (Set.mem_toFinset)]\n  simp only [h, h']\n  apply Finset.all_card_le_biUnion_card_iff_exists_injective"},{"tailPos":10615,"headPos":10588,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"haveI := Classical.decEq β"},{"tailPos":10656,"headPos":10618,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"let r' a := univ.filter fun b => r a b"},{"tailPos":10766,"headPos":10759,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\n⊢ ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nA : Finset α\n⊢ filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'"],"content":"intro A"},{"tailPos":10776,"headPos":10771,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nA : Finset α\n⊢ filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'"],"goalsAfter":["case a\nα : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nA : Finset α\nb : β\n⊢ b ∈ filter (fun b => ∃ a, a ∈ A ∧ r a b) univ ↔ b ∈ Finset.biUnion A r'"],"content":"ext b"},{"tailPos":10785,"headPos":10781,"goalsBefore":["case a\nα : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nA : Finset α\nb : β\n⊢ b ∈ filter (fun b => ∃ a, a ∈ A ∧ r a b) univ ↔ b ∈ Finset.biUnion A r'"],"goalsAfter":[],"content":"simp only [mem_univ, forall_true_left, mem_filter, true_and, mem_biUnion]"},{"tailPos":10785,"headPos":10759,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\n⊢ ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'"],"goalsAfter":[],"content":"intro A\n    ext b\n    simp"},{"tailPos":10754,"headPos":10752,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\n⊢ ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'"],"goalsAfter":[],"content":"by"},{"tailPos":10785,"headPos":10752,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\n⊢ ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'"],"goalsAfter":[],"content":"by\n    intro A\n    ext b\n    simp"},{"tailPos":10785,"headPos":10659,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"have h : ∀ A : Finset α, (univ.filter fun b : β => ∃ a ∈ A, r a b) = A.biUnion r' := by\n    intro A\n    ext b\n    simp"},{"tailPos":10860,"headPos":10856,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\n⊢ ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x"],"goalsAfter":[],"content":"simp only [mem_univ, forall_true_left, mem_filter, true_and, implies_true]"},{"tailPos":10855,"headPos":10853,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\n⊢ ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x"],"goalsAfter":[],"content":"by"},{"tailPos":10860,"headPos":10853,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\n⊢ ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x"],"goalsAfter":[],"content":"by simp"},{"tailPos":10860,"headPos":10788,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp"},{"tailPos":10872,"headPos":10863,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"simp_rw ["},{"tailPos":10874,"headPos":10872,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => filter (fun b => r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"content":"h,"},{"tailPos":10877,"headPos":10875,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => filter (fun b => r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => filter (fun b => r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), f x ∈ filter (fun b => r x b) univ"],"content":"simp only [h']"},{"tailPos":10878,"headPos":10863,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => filter (fun b => r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), f x ∈ filter (fun b => r x b) univ"],"content":"simp_rw [h, h']"},{"tailPos":10939,"headPos":10881,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\nthis : DecidableEq β\nr' : α → Finset β := fun a => filter (fun b => r a b) univ\nh : ∀ (A : Finset α), filter (fun b => ∃ a, a ∈ A ∧ r a b) univ = Finset.biUnion A r'\nh' : ∀ (f : α → β) (x : α), r x (f x) ↔ f x ∈ r' x\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (Finset.biUnion A fun a => filter (fun b => r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), f x ∈ filter (fun b => r x b) univ"],"goalsAfter":[],"content":"apply Finset.all_card_le_biUnion_card_iff_exists_injective"},{"tailPos":10939,"headPos":10588,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":[],"content":"haveI := Classical.decEq β\n  let r' a := univ.filter fun b => r a b\n  have h : ∀ A : Finset α, (univ.filter fun b : β => ∃ a ∈ A, r a b) = A.biUnion r' := by\n    intro A\n    ext b\n    simp\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp\n  simp_rw [h, h']\n  apply Finset.all_card_le_biUnion_card_iff_exists_injective"},{"tailPos":10585,"headPos":10583,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":[],"content":"by"},{"tailPos":10939,"headPos":10583,"goalsBefore":["α : Type u\nβ : Type v\ninst✝¹ : Fintype β\nr : α → β → Prop\ninst✝ : (a : α) → DecidablePred (r a)\n⊢ (∀ (A : Finset α), Finset.card A ≤ Finset.card (filter (fun b => ∃ a, a ∈ A ∧ r a b) univ)) ↔\n    ∃ f, Function.Injective f ∧ ∀ (x : α), r x (f x)"],"goalsAfter":[],"content":"by\n  haveI := Classical.decEq β\n  let r' a := univ.filter fun b => r a b\n  have h : ∀ A : Finset α, (univ.filter fun b : β => ∃ a ∈ A, r a b) = A.biUnion r' := by\n    intro A\n    ext b\n    simp\n  have h' : ∀ (f : α → β) (x), r x (f x) ↔ f x ∈ r' x := by simp\n  simp_rw [h, h']\n  apply Finset.all_card_le_biUnion_card_iff_exists_injective"}]
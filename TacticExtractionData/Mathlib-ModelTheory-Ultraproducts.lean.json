[{"tailPos":1619,"headPos":1564,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ funMap f x ≈ funMap f y"],"goalsAfter":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\na : α\nha : a ∈ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}\n⊢ a ∈ {x_1 | (fun a => funMap f x a = funMap f y a) x_1}"],"content":"refine' mem_of_superset (iInter_mem.2 xy) fun a ha => _"},{"tailPos":1676,"headPos":1626,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\na : α\nha : a ∈ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}\n⊢ a ∈ {x_1 | (fun a => funMap f x a = funMap f y a) x_1}"],"goalsAfter":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\na : α\nha : ∀ (i : Fin n), x i a = y i a\n⊢ a ∈ {x_1 | (fun a => funMap f x a = funMap f y a) x_1}"],"content":"simp only [Set.mem_iInter, Set.mem_setOf_eq] at ha"},{"tailPos":1715,"headPos":1683,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\na : α\nha : ∀ (i : Fin n), x i a = y i a\n⊢ a ∈ {x_1 | (fun a => funMap f x a = funMap f y a) x_1}"],"goalsAfter":[],"content":"simp only [Set.mem_setOf_eq, ha]"},{"tailPos":1715,"headPos":1564,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ funMap f x ≈ funMap f y"],"goalsAfter":[],"content":"refine' mem_of_superset (iInter_mem.2 xy) fun a ha => _\n      simp only [Set.mem_iInter, Set.mem_setOf_eq] at ha\n      simp only [Set.mem_setOf_eq, ha]"},{"tailPos":1557,"headPos":1555,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ funMap f x ≈ funMap f y"],"goalsAfter":[],"content":"by"},{"tailPos":1715,"headPos":1555,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nf : Functions L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ funMap f x ≈ funMap f y"],"goalsAfter":[],"content":"by\n      refine' mem_of_superset (iInter_mem.2 xy) fun a ha => _\n      simp only [Set.mem_iInter, Set.mem_setOf_eq] at ha\n      simp only [Set.mem_setOf_eq, ha]"},{"tailPos":1779,"headPos":1766,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x = RelMap r y"],"goalsAfter":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x ↔ RelMap r y"],"content":"← iff_eq_eq"},{"tailPos":1780,"headPos":1779,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x ↔ RelMap r y"],"goalsAfter":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x ↔ RelMap r y"],"content":"]"},{"tailPos":1780,"headPos":1762,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x = RelMap r y"],"goalsAfter":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x ↔ RelMap r y"],"content":"rw [← iff_eq_eq]"},{"tailPos":1825,"headPos":1787,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x ↔ RelMap r y"],"goalsAfter":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ RelMap r y","case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"content":"refine' ⟨fun hx => _, fun hy => _⟩"},{"tailPos":1834,"headPos":1832,"goalsBefore":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ RelMap r y","case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"goalsAfter":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ RelMap r y"],"content":"·"},{"tailPos":1893,"headPos":1835,"goalsBefore":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ RelMap r y"],"goalsAfter":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ ({x_1 | (fun a => RelMap r fun i => x i a) x_1} ∩ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}) ⊆\n    {x | (fun a => RelMap r fun i => y i a) x}"],"content":"refine' mem_of_superset (inter_mem hx (iInter_mem.2 xy)) _"},{"tailPos":1925,"headPos":1902,"goalsBefore":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ ({x_1 | (fun a => RelMap r fun i => x i a) x_1} ∩ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}) ⊆\n    {x | (fun a => RelMap r fun i => y i a) x}"],"goalsAfter":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\na : α\nha1 : a ∈ {x_1 | (fun a => RelMap r fun i => x i a) x_1}\nha2 : a ∈ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}\n⊢ a ∈ {x | (fun a => RelMap r fun i => y i a) x}"],"content":"rintro a ⟨ha1, ha2⟩"},{"tailPos":1983,"headPos":1934,"goalsBefore":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\na : α\nha1 : a ∈ {x_1 | (fun a => RelMap r fun i => x i a) x_1}\nha2 : a ∈ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}\n⊢ a ∈ {x | (fun a => RelMap r fun i => y i a) x}"],"goalsAfter":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun i => y i a"],"content":"simp only [Set.mem_iInter, Set.mem_setOf_eq] at *"},{"tailPos":2010,"headPos":1996,"goalsBefore":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun i => y i a"],"goalsAfter":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x_1 => x x_1 a"],"content":"← funext ha2"},{"tailPos":2011,"headPos":2010,"goalsBefore":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x_1 => x x_1 a"],"goalsAfter":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x_1 => x x_1 a"],"content":"]"},{"tailPos":2011,"headPos":1992,"goalsBefore":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun i => y i a"],"goalsAfter":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x_1 => x x_1 a"],"content":"rw [← funext ha2]"},{"tailPos":2029,"headPos":2020,"goalsBefore":["case refine'_1.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : ∀ᶠ (a : α) in ↑u, RelMap r fun i => x i a\na : α\nha1 : RelMap r fun i => x i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x_1 => x x_1 a"],"goalsAfter":[],"content":"exact ha1"},{"tailPos":2029,"headPos":1835,"goalsBefore":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ RelMap r y"],"goalsAfter":[],"content":"refine' mem_of_superset (inter_mem hx (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [← funext ha2]\n        exact ha1"},{"tailPos":2029,"headPos":1832,"goalsBefore":["case refine'_1\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhx : RelMap r x\n⊢ RelMap r y","case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"goalsAfter":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"content":"· refine' mem_of_superset (inter_mem hx (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [← funext ha2]\n        exact ha1"},{"tailPos":2038,"headPos":2036,"goalsBefore":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"goalsAfter":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"content":"·"},{"tailPos":2097,"headPos":2039,"goalsBefore":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"goalsAfter":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ ({x | (fun a => RelMap r fun i => y i a) x} ∩ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}) ⊆\n    {x_1 | (fun a => RelMap r fun i => x i a) x_1}"],"content":"refine' mem_of_superset (inter_mem hy (iInter_mem.2 xy)) _"},{"tailPos":2129,"headPos":2106,"goalsBefore":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ ({x | (fun a => RelMap r fun i => y i a) x} ∩ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}) ⊆\n    {x_1 | (fun a => RelMap r fun i => x i a) x_1}"],"goalsAfter":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\na : α\nha1 : a ∈ {x | (fun a => RelMap r fun i => y i a) x}\nha2 : a ∈ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}\n⊢ a ∈ {x_1 | (fun a => RelMap r fun i => x i a) x_1}"],"content":"rintro a ⟨ha1, ha2⟩"},{"tailPos":2187,"headPos":2138,"goalsBefore":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\na : α\nha1 : a ∈ {x | (fun a => RelMap r fun i => y i a) x}\nha2 : a ∈ ⋂ (i : Fin n), {x_1 | (fun a => x i a = y i a) x_1}\n⊢ a ∈ {x_1 | (fun a => RelMap r fun i => x i a) x_1}"],"goalsAfter":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun i => x i a"],"content":"simp only [Set.mem_iInter, Set.mem_setOf_eq] at *"},{"tailPos":2210,"headPos":2200,"goalsBefore":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun i => x i a"],"goalsAfter":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x => y x a"],"content":"funext ha2"},{"tailPos":2211,"headPos":2210,"goalsBefore":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x => y x a"],"goalsAfter":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x => y x a"],"content":"]"},{"tailPos":2211,"headPos":2196,"goalsBefore":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun i => x i a"],"goalsAfter":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x => y x a"],"content":"rw [funext ha2]"},{"tailPos":2229,"headPos":2220,"goalsBefore":["case refine'_2.intro\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : ∀ᶠ (a : α) in ↑u, RelMap r fun i => y i a\na : α\nha1 : RelMap r fun i => y i a\nha2 : ∀ (i : Fin n), x i a = y i a\n⊢ RelMap r fun x => y x a"],"goalsAfter":[],"content":"exact ha1"},{"tailPos":2229,"headPos":2039,"goalsBefore":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"goalsAfter":[],"content":"refine' mem_of_superset (inter_mem hy (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [funext ha2]\n        exact ha1"},{"tailPos":2229,"headPos":2036,"goalsBefore":["case refine'_2\nα : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\nhy : RelMap r y\n⊢ RelMap r x"],"goalsAfter":[],"content":"· refine' mem_of_superset (inter_mem hy (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [funext ha2]\n        exact ha1"},{"tailPos":2229,"headPos":1762,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x = RelMap r y"],"goalsAfter":[],"content":"rw [← iff_eq_eq]\n      refine' ⟨fun hx => _, fun hy => _⟩\n      · refine' mem_of_superset (inter_mem hx (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [← funext ha2]\n        exact ha1\n      · refine' mem_of_superset (inter_mem hy (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [funext ha2]\n        exact ha1"},{"tailPos":1755,"headPos":1753,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x = RelMap r y"],"goalsAfter":[],"content":"by"},{"tailPos":2229,"headPos":1753,"goalsBefore":["α : Type ?u.38\nM : α → Type ?u.43\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nsrc✝ : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn : ℕ\nr : Relations L n\nx y : Fin n → (a : α) → M a\nxy : x ≈ y\n⊢ RelMap r x = RelMap r y"],"goalsAfter":[],"content":"by\n      rw [← iff_eq_eq]\n      refine' ⟨fun hx => _, fun hy => _⟩\n      · refine' mem_of_superset (inter_mem hx (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [← funext ha2]\n        exact ha1\n      · refine' mem_of_superset (inter_mem hy (iInter_mem.2 xy)) _\n        rintro a ⟨ha1, ha2⟩\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [funext ha2]\n        exact ha1"},{"tailPos":2839,"headPos":2814,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nn : ℕ\nf : Functions L n\nx : Fin n → (a : α) → M a\n⊢ (funMap f fun i => Quotient.mk' (x i)) = Quotient.mk' fun a => funMap f fun i => x i a"],"goalsAfter":[],"content":"apply funMap_quotient_mk'"},{"tailPos":2811,"headPos":2809,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nn : ℕ\nf : Functions L n\nx : Fin n → (a : α) → M a\n⊢ (funMap f fun i => Quotient.mk' (x i)) = Quotient.mk' fun a => funMap f fun i => x i a"],"goalsAfter":[],"content":"by"},{"tailPos":2839,"headPos":2809,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nn : ℕ\nf : Functions L n\nx : Fin n → (a : α) → M a\n⊢ (funMap f fun i => Quotient.mk' (x i)) = Quotient.mk' fun a => funMap f fun i => x i a"],"goalsAfter":[],"content":"by\n  apply funMap_quotient_mk'"},{"tailPos":3291,"headPos":3161,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\n⊢ Term.realize (fun i => Quotient.mk' (x i)) t = Quotient.mk' fun a => Term.realize (fun i => x i a) t"],"goalsAfter":["case h.e'_3.h.e'_3\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\n⊢ (fun a => Term.realize (fun i => x i a) t) = Term.realize x t"],"content":"convert @Term.realize_quotient_mk' L _ ((u : Filter α).productSetoid M)\n      (Ultraproduct.setoidPrestructure M u) _ t x using 2"},{"tailPos":3299,"headPos":3294,"goalsBefore":["case h.e'_3.h.e'_3\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\n⊢ (fun a => Term.realize (fun i => x i a) t) = Term.realize x t"],"goalsAfter":["case h.e'_3.h.e'_3.h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\na : α\n⊢ Term.realize (fun i => x i a) t = Term.realize x t a"],"content":"ext a"},{"tailPos":3313,"headPos":3302,"goalsBefore":["case h.e'_3.h.e'_3.h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\na : α\n⊢ Term.realize (fun i => x i a) t = Term.realize x t a"],"goalsAfter":["case h.e'_3.h.e'_3.h.var\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\n_a✝ : β\n⊢ Term.realize (fun i => x i a) (var _a✝) = Term.realize x (var _a✝) a","case h.e'_3.h.e'_3.h.func\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\nl✝ : ℕ\n_f✝ : Functions L l✝\n_ts✝ : Fin l✝ → Term L β\n_ts_ih✝ : ∀ (a_1 : Fin l✝), Term.realize (fun i => x i a) (_ts✝ a_1) = Term.realize x (_ts✝ a_1) a\n⊢ Term.realize (fun i => x i a) (func _f✝ _ts✝) = Term.realize x (func _f✝ _ts✝) a"],"content":"induction t"},{"tailPos":3335,"headPos":3332,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\n_a✝ : β\n⊢ Term.realize (fun i => x i a) (var _a✝) = Term.realize x (var _a✝) a"],"goalsAfter":[],"content":"rfl"},{"tailPos":3335,"headPos":3316,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\n_a✝ : β\n⊢ Term.realize (fun i => x i a) (var _a✝) = Term.realize x (var _a✝) a"],"goalsAfter":[],"content":"case var =>\n    rfl"},{"tailPos":3396,"headPos":3366,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\nl✝ : ℕ\n_f✝ : Functions L l✝\n_ts✝ : Fin l✝ → Term L β\nt_ih : ∀ (a_1 : Fin l✝), Term.realize (fun i => x i a) (_ts✝ a_1) = Term.realize x (_ts✝ a_1) a\n⊢ Term.realize (fun i => x i a) (func _f✝ _ts✝) = Term.realize x (func _f✝ _ts✝) a"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\nl✝ : ℕ\n_f✝ : Functions L l✝\n_ts✝ : Fin l✝ → Term L β\nt_ih : ∀ (a_1 : Fin l✝), Term.realize (fun i => x i a) (_ts✝ a_1) = Term.realize x (_ts✝ a_1) a\n⊢ (funMap _f✝ fun i => Term.realize x (_ts✝ i) a) = funMap _f✝ (fun i => Term.realize x (_ts✝ i)) a"],"content":"simp only [Term.realize, t_ih]"},{"tailPos":3404,"headPos":3401,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\nl✝ : ℕ\n_f✝ : Functions L l✝\n_ts✝ : Fin l✝ → Term L β\nt_ih : ∀ (a_1 : Fin l✝), Term.realize (fun i => x i a) (_ts✝ a_1) = Term.realize x (_ts✝ a_1) a\n⊢ (funMap _f✝ fun i => Term.realize x (_ts✝ i) a) = funMap _f✝ (fun i => Term.realize x (_ts✝ i)) a"],"goalsAfter":[],"content":"rfl"},{"tailPos":3404,"headPos":3366,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\nl✝ : ℕ\n_f✝ : Functions L l✝\n_ts✝ : Fin l✝ → Term L β\nt_ih : ∀ (a_1 : Fin l✝), Term.realize (fun i => x i a) (_ts✝ a_1) = Term.realize x (_ts✝ a_1) a\n⊢ Term.realize (fun i => x i a) (func _f✝ _ts✝) = Term.realize x (func _f✝ _ts✝) a"],"goalsAfter":[],"content":"simp only [Term.realize, t_ih]\n    rfl"},{"tailPos":3404,"headPos":3338,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\na : α\nl✝ : ℕ\n_f✝ : Functions L l✝\n_ts✝ : Fin l✝ → Term L β\nt_ih : ∀ (a_1 : Fin l✝), Term.realize (fun i => x i a) (_ts✝ a_1) = Term.realize x (_ts✝ a_1) a\n⊢ Term.realize (fun i => x i a) (func _f✝ _ts✝) = Term.realize x (func _f✝ _ts✝) a"],"goalsAfter":[],"content":"case func _ _ _ t_ih =>\n    simp only [Term.realize, t_ih]\n    rfl"},{"tailPos":3404,"headPos":3161,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\n⊢ Term.realize (fun i => Quotient.mk' (x i)) t = Quotient.mk' fun a => Term.realize (fun i => x i a) t"],"goalsAfter":[],"content":"convert @Term.realize_quotient_mk' L _ ((u : Filter α).productSetoid M)\n      (Ultraproduct.setoidPrestructure M u) _ t x using 2\n  ext a\n  induction t\n  case var =>\n    rfl\n  case func _ _ _ t_ih =>\n    simp only [Term.realize, t_ih]\n    rfl"},{"tailPos":3158,"headPos":3156,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\n⊢ Term.realize (fun i => Quotient.mk' (x i)) t = Quotient.mk' fun a => Term.realize (fun i => x i a) t"],"goalsAfter":[],"content":"by"},{"tailPos":3404,"headPos":3156,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝ : (a : α) → Structure L (M a)\nβ : Type u_1\nx : β → (a : α) → M a\nt : Term L β\n⊢ Term.realize (fun i => Quotient.mk' (x i)) t = Quotient.mk' fun a => Term.realize (fun i => x i a) t"],"goalsAfter":[],"content":"by\n  convert @Term.realize_quotient_mk' L _ ((u : Filter α).productSetoid M)\n      (Ultraproduct.setoidPrestructure M u) _ t x using 2\n  ext a\n  induction t\n  case var =>\n    rfl\n  case func _ _ _ t_ih =>\n    simp only [Term.realize, t_ih]\n    rfl"},{"tailPos":3946,"headPos":3907,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nφ : BoundedFormula L β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\n⊢ (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nφ : BoundedFormula L β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\n⊢ (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a"],"content":"letI := (u : Filter α).productSetoid M"},{"tailPos":4004,"headPos":3949,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nφ : BoundedFormula L β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\n⊢ (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a"],"goalsAfter":["case falsum\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize BoundedFormula.falsum (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize BoundedFormula.falsum (fun i => x i a) fun i => v i a","case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a","case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"content":"induction' φ with _ _ _ _ _ _ _ _ m _ _ ih ih' k φ ih"},{"tailPos":4009,"headPos":4007,"goalsBefore":["case falsum\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize BoundedFormula.falsum (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize BoundedFormula.falsum (fun i => x i a) fun i => v i a","case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a","case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case falsum\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize BoundedFormula.falsum (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize BoundedFormula.falsum (fun i => x i a) fun i => v i a"],"content":"·"},{"tailPos":4062,"headPos":4010,"goalsBefore":["case falsum\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize BoundedFormula.falsum (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize BoundedFormula.falsum (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"simp only [BoundedFormula.Realize, eventually_const]"},{"tailPos":4062,"headPos":4007,"goalsBefore":["case falsum\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize BoundedFormula.falsum (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize BoundedFormula.falsum (fun i => x i a) fun i => v i a","case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a","case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a","case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"content":"· simp only [BoundedFormula.Realize, eventually_const]"},{"tailPos":4067,"headPos":4065,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a","case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a"],"content":"·"},{"tailPos":4241,"headPos":4068,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a"],"content":"have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl"},{"tailPos":4303,"headPos":4246,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) t₁✝ =\n      Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"content":"simp only [BoundedFormula.Realize, h2, term_realize_cast]"},{"tailPos":4391,"headPos":4313,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) t₁✝ =\n      Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ Term.realize (Quotient.mk' ∘ Sum.elim x v) t₁✝ = Term.realize (Quotient.mk' ∘ Sum.elim x v) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"content":"(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,"},{"tailPos":4416,"headPos":4398,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ Term.realize (Quotient.mk' ∘ Sum.elim x v) t₁✝ = Term.realize (Quotient.mk' ∘ Sum.elim x v) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Term.realize (Quotient.mk' ∘ Sum.elim x v) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"content":"term_realize_cast,"},{"tailPos":4434,"headPos":4417,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Term.realize (Quotient.mk' ∘ Sum.elim x v) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ ((Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₂✝) ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"content":"term_realize_cast"},{"tailPos":4435,"headPos":4434,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ ((Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₂✝) ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ ((Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₂✝) ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"content":"]"},{"tailPos":4435,"headPos":4308,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) t₁✝ =\n      Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) t₂✝ ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"goalsAfter":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ ((Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₂✝) ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"content":"erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,\n      term_realize_cast, term_realize_cast]"},{"tailPos":4459,"headPos":4440,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ ((Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₁✝) =\n      Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) t₂✝) ↔\n    ∀ᶠ (a : α) in ↑u, Term.realize (fun i => Sum.elim x v i a) t₁✝ = Term.realize (fun i => Sum.elim x v i a) t₂✝"],"goalsAfter":[],"content":"exact Quotient.eq''"},{"tailPos":4459,"headPos":4068,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2, term_realize_cast]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,\n      term_realize_cast, term_realize_cast]\n    exact Quotient.eq''"},{"tailPos":4459,"headPos":4065,"goalsBefore":["case equal\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ : ℕ\nt₁✝ t₂✝ : Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.equal t₁✝ t₂✝) (fun i => x i a) fun i => v i a","case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"content":"· have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2, term_realize_cast]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,\n      term_realize_cast, term_realize_cast]\n    exact Quotient.eq''"},{"tailPos":4464,"headPos":4462,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a"],"content":"·"},{"tailPos":4638,"headPos":4465,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a"],"content":"have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl"},{"tailPos":4681,"headPos":4643,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"simp only [BoundedFormula.Realize, h2]"},{"tailPos":4768,"headPos":4691,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm"},{"tailPos":4769,"headPos":4768,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"]"},{"tailPos":4769,"headPos":4686,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Sum.elim (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm]"},{"tailPos":4798,"headPos":4786,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n| RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"goalsAfter":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"content":"enter [2, i]"},{"tailPos":4799,"headPos":4798,"goalsBefore":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"goalsAfter":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"content":";"},{"tailPos":4822,"headPos":4805,"goalsBefore":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"goalsAfter":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"term_realize_cast"},{"tailPos":4823,"headPos":4800,"goalsBefore":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"goalsAfter":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"erw [term_realize_cast]"},{"tailPos":4823,"headPos":4786,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n| RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)"],"goalsAfter":["case h\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\ni : Fin l✝\n| Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"enter [2, i]; erw [term_realize_cast]"},{"tailPos":4823,"headPos":4774,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Term.realize (Quotient.mk' ∘ Sum.elim x v) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"goalsAfter":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"content":"conv_lhs => enter [2, i]; erw [term_realize_cast]"},{"tailPos":4853,"headPos":4828,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\nh2 : ∀ (a : α), (Sum.elim (fun i => x i a) fun i => v i a) = fun i => Sum.elim x v i a\n⊢ (RelMap R✝ fun i => Quotient.mk' fun a => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)) ↔\n    ∀ᶠ (a : α) in ↑u, RelMap R✝ fun i => Term.realize (fun i => Sum.elim x v i a) (ts✝ i)"],"goalsAfter":[],"content":"apply relMap_quotient_mk'"},{"tailPos":4853,"headPos":4465,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm]\n    conv_lhs => enter [2, i]; erw [term_realize_cast]\n    apply relMap_quotient_mk'"},{"tailPos":4853,"headPos":4462,"goalsBefore":["case rel\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nn✝ l✝ : ℕ\nR✝ : Relations L l✝\nts✝ : Fin l✝ → Term L (β ⊕ Fin n✝)\nv : Fin n✝ → (a : α) → M a\n⊢ (BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (BoundedFormula.rel R✝ ts✝) (fun i => x i a) fun i => v i a","case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"content":"· have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm]\n    conv_lhs => enter [2, i]; erw [term_realize_cast]\n    apply relMap_quotient_mk'"},{"tailPos":4858,"headPos":4856,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a"],"content":"·"},{"tailPos":4906,"headPos":4859,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a"],"goalsAfter":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ ((∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a) ↔\n    ∀ᶠ (a : α) in ↑u,\n      (BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n        BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a"],"content":"simp only [BoundedFormula.Realize, ih v, ih' v]"},{"tailPos":4941,"headPos":4915,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ ((∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a) ↔\n    ∀ᶠ (a : α) in ↑u,\n      (BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n        BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a"],"goalsAfter":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ ((∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a) ↔\n    (∀ᶠ (x_1 : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i x_1) fun i => v i x_1) →\n      ∀ᶠ (x_1 : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i x_1) fun i => v i x_1"],"content":"Ultrafilter.eventually_imp"},{"tailPos":4942,"headPos":4941,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ ((∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a) ↔\n    (∀ᶠ (x_1 : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i x_1) fun i => v i x_1) →\n      ∀ᶠ (x_1 : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i x_1) fun i => v i x_1"],"goalsAfter":[],"content":"]"},{"tailPos":4942,"headPos":4911,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ ((∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a) ↔\n    ∀ᶠ (a : α) in ↑u,\n      (BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a) →\n        BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"rw [Ultrafilter.eventually_imp]"},{"tailPos":4942,"headPos":4859,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"simp only [BoundedFormula.Realize, ih v, ih' v]\n    rw [Ultrafilter.eventually_imp]"},{"tailPos":4942,"headPos":4856,"goalsBefore":["case imp\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nm : ℕ\nf₁✝ f₂✝ : BoundedFormula L β m\nih :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₁✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₁✝ (fun i => x i a) fun i => v i a\nih' :\n  ∀ (v : Fin m → (a : α) → M a),\n    (BoundedFormula.Realize f₂✝ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize f₂✝ (fun i => x i a) fun i => v i a\nv : Fin m → (a : α) → M a\n⊢ (BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (f₁✝ ⟹ f₂✝) (fun i => x i a) fun i => v i a","case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"content":"· simp only [BoundedFormula.Realize, ih v, ih' v]\n    rw [Ultrafilter.eventually_imp]"},{"tailPos":4947,"headPos":4945,"goalsBefore":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"content":"·"},{"tailPos":4982,"headPos":4948,"goalsBefore":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"simp only [BoundedFormula.Realize]"},{"tailPos":5223,"headPos":4987,"goalsBefore":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₁\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))","case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"apply Iff.trans (b := ∀ m : ∀ a : α, M a,\n      φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (Fin.snoc (((↑) : (∀ a, M a) → (u : Filter α).Product M) ∘ v)\n          (m : (u : Filter α).Product M)))"},{"tailPos":5230,"headPos":5228,"goalsBefore":["case all.h₁\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))","case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₁\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))"],"content":"·"},{"tailPos":5256,"headPos":5231,"goalsBefore":["case all.h₁\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))"],"goalsAfter":[],"content":"exact forall_quotient_iff"},{"tailPos":5256,"headPos":5228,"goalsBefore":["case all.h₁\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (x_1 : Quotient (productSetoid ↑u fun a => M a)),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (fun i => Quotient.mk' (v i)) x_1)) ↔\n    ∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))","case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"· exact forall_quotient_iff"},{"tailPos":5506,"headPos":5443,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)"],"goalsAfter":["case refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\n⊢ Fin.snoc v m (Fin.last k) a = Fin.snoc (fun i => v i a) (m a) (Fin.last k)","case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"content":"refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)"},{"tailPos":5515,"headPos":5513,"goalsBefore":["case refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\n⊢ Fin.snoc v m (Fin.last k) a = Fin.snoc (fun i => v i a) (m a) (Fin.last k)","case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"goalsAfter":["case refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\n⊢ Fin.snoc v m (Fin.last k) a = Fin.snoc (fun i => v i a) (m a) (Fin.last k)"],"content":"·"},{"tailPos":5541,"headPos":5516,"goalsBefore":["case refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\n⊢ Fin.snoc v m (Fin.last k) a = Fin.snoc (fun i => v i a) (m a) (Fin.last k)"],"goalsAfter":[],"content":"simp only [Fin.snoc_last]"},{"tailPos":5541,"headPos":5513,"goalsBefore":["case refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\n⊢ Fin.snoc v m (Fin.last k) a = Fin.snoc (fun i => v i a) (m a) (Fin.last k)","case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"goalsAfter":["case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"content":"· simp only [Fin.snoc_last]"},{"tailPos":5550,"headPos":5548,"goalsBefore":["case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"goalsAfter":["case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"content":"·"},{"tailPos":5580,"headPos":5551,"goalsBefore":["case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"goalsAfter":[],"content":"simp only [Fin.snoc_castSucc]"},{"tailPos":5580,"headPos":5548,"goalsBefore":["case refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nm : (a : α) → M a\na : α\ni : Fin k\nx✝ : Fin.snoc v m (Fin.succ i) a = Fin.snoc (fun i => v i a) (m a) (Fin.succ i)\n⊢ Fin.snoc v m (↑Fin.castSucc i) a = Fin.snoc (fun i => v i a) (m a) (↑Fin.castSucc i)"],"goalsAfter":[],"content":"· simp only [Fin.snoc_castSucc]"},{"tailPos":5580,"headPos":5443,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)"],"goalsAfter":[],"content":"refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]"},{"tailPos":5436,"headPos":5434,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)"],"goalsAfter":[],"content":"by"},{"tailPos":5580,"headPos":5434,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)"],"goalsAfter":[],"content":"by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]"},{"tailPos":5580,"headPos":5261,"goalsBefore":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : Fin (k + 1) => (Fin.snoc v m : _ → ∀ a, M a) i a) =\n          Fin.snoc (fun i : Fin k => v i a) (m a) := by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]"},{"tailPos":5614,"headPos":5585,"goalsBefore":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\n⊢ (∀ (m : (a : α) → M a),\n      BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Fin.snoc (Quotient.mk' ∘ v) (Quotient.mk' m))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\n⊢ (∀ (m : (a : α) → M a), BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Quotient.mk' ∘ Fin.snoc v m)) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"simp only [← Fin.comp_snoc]"},{"tailPos":5652,"headPos":5619,"goalsBefore":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\n⊢ (∀ (m : (a : α) → M a), BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) (Quotient.mk' ∘ Fin.snoc v m)) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\n⊢ (∀ (m : (a : α) → M a),\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"simp only [Function.comp, ih, h']"},{"tailPos":5695,"headPos":5657,"goalsBefore":["case all.h₂\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\n⊢ (∀ (m : (a : α) → M a),\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))) ↔\n    ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ (m : (a : α) → M a), ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))\n⊢ ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)","case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"refine' ⟨fun h => _, fun h m => _⟩"},{"tailPos":5702,"headPos":5700,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ (m : (a : α) → M a), ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))\n⊢ ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)","case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ (m : (a : α) → M a), ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))\n⊢ ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"content":"·"},{"tailPos":5716,"headPos":5703,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ (m : (a : α) → M a), ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))\n⊢ ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ¬∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"contrapose! h"},{"tailPos":5732,"headPos":5723,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ¬∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ¬∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"simp_rw ["},{"tailPos":5763,"headPos":5732,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ¬∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ¬∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"← Ultrafilter.eventually_not,"},{"tailPos":5774,"headPos":5764,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ¬∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"simp only [not_forall] at h "},{"tailPos":5780,"headPos":5723,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ¬∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"simp_rw [← Ultrafilter.eventually_not, not_forall] at h"},{"tailPos":5950,"headPos":5787,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∃ m, ¬∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ¬∀ᶠ (a : α) in ↑u,\n      BoundedFormula.Realize φ (fun i => x i a)\n        (Fin.snoc (fun i => v i a)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            a))"],"content":"refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩"},{"tailPos":5991,"headPos":5961,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ¬∀ᶠ (a : α) in ↑u,\n      BoundedFormula.Realize φ (fun i => x i a)\n        (Fin.snoc (fun i => v i a)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∀ᶠ (x_1 : α) in ↑u,\n    ¬BoundedFormula.Realize φ (fun i => x i x_1)\n        (Fin.snoc (fun i => v i x_1)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            x_1))"],"content":"← Ultrafilter.eventually_not"},{"tailPos":5992,"headPos":5991,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∀ᶠ (x_1 : α) in ↑u,\n    ¬BoundedFormula.Realize φ (fun i => x i x_1)\n        (Fin.snoc (fun i => v i x_1)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            x_1))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∀ᶠ (x_1 : α) in ↑u,\n    ¬BoundedFormula.Realize φ (fun i => x i x_1)\n        (Fin.snoc (fun i => v i x_1)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            x_1))"],"content":"]"},{"tailPos":5992,"headPos":5957,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ¬∀ᶠ (a : α) in ↑u,\n      BoundedFormula.Realize φ (fun i => x i a)\n        (Fin.snoc (fun i => v i a)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            a))"],"goalsAfter":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∀ᶠ (x_1 : α) in ↑u,\n    ¬BoundedFormula.Realize φ (fun i => x i x_1)\n        (Fin.snoc (fun i => v i x_1)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            x_1))"],"content":"rw [← Ultrafilter.eventually_not]"},{"tailPos":6067,"headPos":5999,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (x_1 : α) in ↑u, ∃ x_2, ¬BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)\n⊢ ∀ᶠ (x_1 : α) in ↑u,\n    ¬BoundedFormula.Realize φ (fun i => x i x_1)\n        (Fin.snoc (fun i => v i x_1)\n          ((fun a =>\n              Classical.epsilon fun m => ¬BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) m))\n            x_1))"],"goalsAfter":[],"content":"exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha"},{"tailPos":6067,"headPos":5703,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ (m : (a : α) → M a), ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))\n⊢ ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)"],"goalsAfter":[],"content":"contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha"},{"tailPos":6067,"headPos":5700,"goalsBefore":["case all.h₂.refine'_1\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ (m : (a : α) → M a), ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))\n⊢ ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)","case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"· contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha"},{"tailPos":6074,"headPos":6072,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"content":"·"},{"tailPos":6100,"headPos":6079,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : {x_1 | ∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)} ∈ ↑u\nm : (a : α) → M a\n⊢ {x_1 | BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) (m x_1))} ∈ ↑u"],"content":"Filter.eventually_iff"},{"tailPos":6101,"headPos":6100,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : {x_1 | ∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)} ∈ ↑u\nm : (a : α) → M a\n⊢ {x_1 | BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) (m x_1))} ∈ ↑u"],"goalsAfter":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : {x_1 | ∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)} ∈ ↑u\nm : (a : α) → M a\n⊢ {x_1 | BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) (m x_1))} ∈ ↑u"],"content":"]"},{"tailPos":6106,"headPos":6075,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : {x_1 | ∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)} ∈ ↑u\nm : (a : α) → M a\n⊢ {x_1 | BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) (m x_1))} ∈ ↑u"],"content":"rw [Filter.eventually_iff] at *"},{"tailPos":6164,"headPos":6113,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : {x_1 | ∀ (x_2 : M x_1), BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) x_2)} ∈ ↑u\nm : (a : α) → M a\n⊢ {x_1 | BoundedFormula.Realize φ (fun i => x i x_1) (Fin.snoc (fun i => v i x_1) (m x_1))} ∈ ↑u"],"goalsAfter":[],"content":"exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":6164,"headPos":6075,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":[],"content":"rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":6164,"headPos":6072,"goalsBefore":["case all.h₂.refine'_2\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\nh' : ∀ (m : (a : α) → M a) (a : α), (fun i => Fin.snoc v m i a) = Fin.snoc (fun i => v i a) (m a)\nh : ∀ᶠ (a : α) in ↑u, ∀ (x_1 : M a), BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) x_1)\nm : (a : α) → M a\n⊢ ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) (Fin.snoc (fun i => v i a) (m a))"],"goalsAfter":[],"content":"· rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":6164,"headPos":4948,"goalsBefore":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"simp only [BoundedFormula.Realize]\n    apply Iff.trans (b := ∀ m : ∀ a : α, M a,\n      φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (Fin.snoc (((↑) : (∀ a, M a) → (u : Filter α).Product M) ∘ v)\n          (m : (u : Filter α).Product M)))\n    · exact forall_quotient_iff\n    have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : Fin (k + 1) => (Fin.snoc v m : _ → ∀ a, M a) i a) =\n          Fin.snoc (fun i : Fin k => v i a) (m a) := by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]\n    simp only [← Fin.comp_snoc]\n    simp only [Function.comp, ih, h']\n    refine' ⟨fun h => _, fun h m => _⟩\n    · contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha\n    · rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":6164,"headPos":4945,"goalsBefore":["case all\nα : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nx : β → (a : α) → M a\nv✝ : Fin n → (a : α) → M a\nthis : Setoid ((a : α) → M a) := productSetoid (↑u) M\nk : ℕ\nφ : BoundedFormula L β (k + 1)\nih :\n  ∀ (v : Fin (k + 1) → (a : α) → M a),\n    (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n      ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a\nv : Fin k → (a : α) → M a\n⊢ (BoundedFormula.Realize (∀'φ) (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize (∀'φ) (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"· simp only [BoundedFormula.Realize]\n    apply Iff.trans (b := ∀ m : ∀ a : α, M a,\n      φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (Fin.snoc (((↑) : (∀ a, M a) → (u : Filter α).Product M) ∘ v)\n          (m : (u : Filter α).Product M)))\n    · exact forall_quotient_iff\n    have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : Fin (k + 1) => (Fin.snoc v m : _ → ∀ a, M a) i a) =\n          Fin.snoc (fun i : Fin k => v i a) (m a) := by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]\n    simp only [← Fin.comp_snoc]\n    simp only [Function.comp, ih, h']\n    refine' ⟨fun h => _, fun h m => _⟩\n    · contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha\n    · rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":6164,"headPos":3907,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nφ : BoundedFormula L β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\n⊢ (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"letI := (u : Filter α).productSetoid M\n  induction' φ with _ _ _ _ _ _ _ _ m _ _ ih ih' k φ ih\n  · simp only [BoundedFormula.Realize, eventually_const]\n  · have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2, term_realize_cast]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,\n      term_realize_cast, term_realize_cast]\n    exact Quotient.eq''\n  · have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm]\n    conv_lhs => enter [2, i]; erw [term_realize_cast]\n    apply relMap_quotient_mk'\n  · simp only [BoundedFormula.Realize, ih v, ih' v]\n    rw [Ultrafilter.eventually_imp]\n  · simp only [BoundedFormula.Realize]\n    apply Iff.trans (b := ∀ m : ∀ a : α, M a,\n      φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (Fin.snoc (((↑) : (∀ a, M a) → (u : Filter α).Product M) ∘ v)\n          (m : (u : Filter α).Product M)))\n    · exact forall_quotient_iff\n    have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : Fin (k + 1) => (Fin.snoc v m : _ → ∀ a, M a) i a) =\n          Fin.snoc (fun i : Fin k => v i a) (m a) := by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]\n    simp only [← Fin.comp_snoc]\n    simp only [Function.comp, ih, h']\n    refine' ⟨fun h => _, fun h m => _⟩\n    · contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha\n    · rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":3904,"headPos":3902,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nφ : BoundedFormula L β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\n⊢ (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"by"},{"tailPos":6164,"headPos":3902,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nn : ℕ\nφ : BoundedFormula L β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\n⊢ (BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) fun i => v i a"],"goalsAfter":[],"content":"by\n  letI := (u : Filter α).productSetoid M\n  induction' φ with _ _ _ _ _ _ _ _ m _ _ ih ih' k φ ih\n  · simp only [BoundedFormula.Realize, eventually_const]\n  · have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2, term_realize_cast]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,\n      term_realize_cast, term_realize_cast]\n    exact Quotient.eq''\n  · have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm]\n    conv_lhs => enter [2, i]; erw [term_realize_cast]\n    apply relMap_quotient_mk'\n  · simp only [BoundedFormula.Realize, ih v, ih' v]\n    rw [Ultrafilter.eventually_imp]\n  · simp only [BoundedFormula.Realize]\n    apply Iff.trans (b := ∀ m : ∀ a : α, M a,\n      φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (Fin.snoc (((↑) : (∀ a, M a) → (u : Filter α).Product M) ∘ v)\n          (m : (u : Filter α).Product M)))\n    · exact forall_quotient_iff\n    have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : Fin (k + 1) => (Fin.snoc v m : _ → ∀ a, M a) i a) =\n          Fin.snoc (fun i : Fin k => v i a) (m a) := by\n      refine' fun m a => funext (Fin.reverseInduction _ fun i _ => _)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]\n    simp only [← Fin.comp_snoc]\n    simp only [Function.comp, ih, h']\n    refine' ⟨fun h => _, fun h m => _⟩\n    · contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine'\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          _⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha\n    · rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)"},{"tailPos":6519,"headPos":6510,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"content":"simp_rw ["},{"tailPos":6535,"headPos":6519,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) default"],"content":"Formula.Realize,"},{"tailPos":6573,"headPos":6536,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default ↔\n    ∀ᶠ (a : α) in ↑u, BoundedFormula.Realize φ (fun i => x i a) default"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default ↔\n    BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' fun a => default i"],"content":"← boundedFormula_realize_cast φ x,"},{"tailPos":6583,"headPos":6574,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default ↔\n    BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' fun a => default i"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default =\n    BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' fun a => default i"],"content":"simp only [iff_eq_eq]"},{"tailPos":6584,"headPos":6510,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"goalsAfter":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default =\n    BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' fun a => default i"],"content":"simp_rw [Formula.Realize, ← boundedFormula_realize_cast φ x, iff_eq_eq]"},{"tailPos":6626,"headPos":6587,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) default =\n    BoundedFormula.Realize φ (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' fun a => default i"],"goalsAfter":[],"content":"exact congr rfl (Subsingleton.elim _ _)"},{"tailPos":6626,"headPos":6510,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"goalsAfter":[],"content":"simp_rw [Formula.Realize, ← boundedFormula_realize_cast φ x, iff_eq_eq]\n  exact congr rfl (Subsingleton.elim _ _)"},{"tailPos":6507,"headPos":6505,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"goalsAfter":[],"content":"by"},{"tailPos":6626,"headPos":6505,"goalsBefore":["α : Type u_2\nM : α → Type u_3\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_1\nφ : Formula L β\nx : β → (a : α) → M a\n⊢ (Formula.Realize φ fun i => Quotient.mk' (x i)) ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ fun i => x i a"],"goalsAfter":[],"content":"by\n  simp_rw [Formula.Realize, ← boundedFormula_realize_cast φ x, iff_eq_eq]\n  exact congr rfl (Subsingleton.elim _ _)"},{"tailPos":7017,"headPos":7008,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"content":"simp_rw ["},{"tailPos":7033,"headPos":7017,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ default"],"content":"simp only [Sentence.Realize]"},{"tailPos":7034,"headPos":7008,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ default"],"content":"simp_rw [Sentence.Realize]"},{"tailPos":7070,"headPos":7042,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ default"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default ↔ Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"content":"← realize_formula_cast φ,"},{"tailPos":7080,"headPos":7071,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default ↔ Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default = Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"content":"iff_eq_eq"},{"tailPos":7081,"headPos":7080,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default = Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default = Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"content":"]"},{"tailPos":7081,"headPos":7037,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default ↔ ∀ᶠ (a : α) in ↑u, Formula.Realize φ default"],"goalsAfter":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default = Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"content":"erw [← realize_formula_cast φ, iff_eq_eq]"},{"tailPos":7123,"headPos":7084,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Formula.Realize φ default = Formula.Realize φ fun i => Quotient.mk' fun a => default i"],"goalsAfter":[],"content":"exact congr rfl (Subsingleton.elim _ _)"},{"tailPos":7123,"headPos":7008,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"goalsAfter":[],"content":"simp_rw [Sentence.Realize]\n  erw [← realize_formula_cast φ, iff_eq_eq]\n  exact congr rfl (Subsingleton.elim _ _)"},{"tailPos":7005,"headPos":7003,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"goalsAfter":[],"content":"by"},{"tailPos":7123,"headPos":7003,"goalsBefore":["α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : Language\ninst✝¹ : (a : α) → Structure L (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : Sentence L\n⊢ Product (↑u) M ⊨ φ ↔ ∀ᶠ (a : α) in ↑u, M a ⊨ φ"],"goalsAfter":[],"content":"by\n  simp_rw [Sentence.Realize]\n  erw [← realize_formula_cast φ, iff_eq_eq]\n  exact congr rfl (Subsingleton.elim _ _)"}]
[{"tailPos":5607,"headPos":5544,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"content":"let t : L → Finset P := fun l => Set.toFinset { p | p ∉ l }"},{"tailPos":5803,"headPos":5711,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nthis : ∀ (s : Finset L), Finset.card s ≤ Finset.card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nthis : ∀ (s : Finset L), Finset.card s ≤ Finset.card (Finset.biUnion s t)\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (x : L), f x ∈ t x\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"content":"obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this"},{"tailPos":5866,"headPos":5810,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nthis : ∀ (s : Finset L), Finset.card s ≤ Finset.card (Finset.biUnion s t)\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (x : L), f x ∈ t x\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":[],"content":"exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩"},{"tailPos":5866,"headPos":5711,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nthis : ∀ (s : Finset L), Finset.card s ≤ Finset.card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":[],"content":"obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩"},{"tailPos":5866,"headPos":5612,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\n⊢ ∀ (s : Finset L), Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"suffices ∀ s : Finset L, s.card ≤ (s.biUnion t).card by\n      -- Hall's marriage theorem\n      obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩"},{"tailPos":5878,"headPos":5871,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\n⊢ ∀ (s : Finset L), Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"intro s"},{"tailPos":5910,"headPos":5883,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"by_cases hs₀ : s.card = 0"},{"tailPos":5978,"headPos":5976,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"·"},{"tailPos":5988,"headPos":5979,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})"],"content":"simp_rw ["},{"tailPos":5994,"headPos":5988,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ 0 ≤ Finset.card (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})"],"content":"hs₀,"},{"tailPos":6002,"headPos":5995,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ 0 ≤ Finset.card (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})"],"goalsAfter":[],"content":"simp only [zero_le]"},{"tailPos":6003,"headPos":5979,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":[],"content":"simp_rw [hs₀, zero_le]"},{"tailPos":6003,"headPos":5976,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"· simp_rw [hs₀, zero_le]"},{"tailPos":6035,"headPos":6008,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"by_cases hs₁ : s.card = 1"},{"tailPos":6091,"headPos":6089,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"·"},{"tailPos":6142,"headPos":6092,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\n⊢ Finset.card {l} ≤ Finset.card (Finset.biUnion {l} t)"],"content":"obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁"},{"tailPos":6185,"headPos":6149,"goalsBefore":["case pos.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\n⊢ Finset.card {l} ≤ Finset.card (Finset.biUnion {l} t)"],"goalsAfter":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card {l} ≤ Finset.card (Finset.biUnion {l} t)"],"content":"obtain ⟨p, hl⟩ := exists_point l"},{"tailPos":6218,"headPos":6196,"goalsBefore":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card {l} ≤ Finset.card (Finset.biUnion {l} t)"],"goalsAfter":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ 1 ≤ Finset.card (Finset.biUnion {l} t)"],"content":"Finset.card_singleton,"},{"tailPos":6244,"headPos":6219,"goalsBefore":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ 1 ≤ Finset.card (Finset.biUnion {l} t)"],"goalsAfter":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ 1 ≤ Finset.card (t l)"],"content":"Finset.singleton_biUnion,"},{"tailPos":6267,"headPos":6245,"goalsBefore":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ 1 ≤ Finset.card (t l)"],"goalsAfter":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card (t l) ≠ 0"],"content":"Nat.one_le_iff_ne_zero"},{"tailPos":6268,"headPos":6267,"goalsBefore":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card (t l) ≠ 0"],"goalsAfter":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card (t l) ≠ 0"],"content":"]"},{"tailPos":6268,"headPos":6192,"goalsBefore":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card {l} ≤ Finset.card (Finset.biUnion {l} t)"],"goalsAfter":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card (t l) ≠ 0"],"content":"rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]"},{"tailPos":6333,"headPos":6275,"goalsBefore":["case pos.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\nl : L\nhs₀ : ¬Finset.card {l} = 0\nhs₁ : Finset.card {l} = 1\np : P\nhl : ¬p ∈ l\n⊢ Finset.card (t l) ≠ 0"],"goalsAfter":[],"content":"exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)"},{"tailPos":6333,"headPos":6092,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":[],"content":"obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point l\n      rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]\n      exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)"},{"tailPos":6333,"headPos":6089,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"· obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point l\n      rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]\n      exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)"},{"tailPos":6465,"headPos":6447,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Finset.card (sᶜ)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"Finset.card_compl,"},{"tailPos":6484,"headPos":6466,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Finset.card (sᶜ)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"Finset.card_compl,"},{"tailPos":6501,"headPos":6485,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card P ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"tsub_le_iff_left"},{"tailPos":6502,"headPos":6501,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card P ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card P ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"]"},{"tailPos":6510,"headPos":6443,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card P ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this"},{"tailPos":6540,"headPos":6517,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card P ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card L ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"replace := h.trans this"},{"tailPos":6592,"headPos":6552,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card L ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card L ≤ Finset.card (Finset.biUnion s t) + Fintype.card L - Finset.card s\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"← add_tsub_assoc_of_le s.card_le_univ,"},{"tailPos":6639,"headPos":6593,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card L ≤ Finset.card (Finset.biUnion s t) + Fintype.card L - Finset.card s\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Finset.card s + Fintype.card L ≤ Finset.card (Finset.biUnion s t) + Fintype.card L\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"le_tsub_iff_left (le_add_left s.card_le_univ),"},{"tailPos":6668,"headPos":6648,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Finset.card s + Fintype.card L ≤ Finset.card (Finset.biUnion s t) + Fintype.card L\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Finset.card s ≤ Finset.card (Finset.biUnion s t)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"add_le_add_iff_right"},{"tailPos":6669,"headPos":6668,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Finset.card s ≤ Finset.card (Finset.biUnion s t)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Finset.card s ≤ Finset.card (Finset.biUnion s t)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"content":"]"},{"tailPos":6677,"headPos":6547,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis✝ : Fintype.card P - Finset.card (Finset.biUnion s t) ≤ Fintype.card L - Finset.card s\nthis : Fintype.card L ≤ Finset.card (Finset.biUnion s t) + (Fintype.card L - Finset.card s)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":[],"content":"rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this"},{"tailPos":6677,"headPos":6443,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nthis : Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":[],"content":"rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this"},{"tailPos":6677,"headPos":6338,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card s ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"content":"suffices s.biUnion tᶜ.card ≤ sᶜ.card by\n      -- Rephrase in terms of complements (uses `h`)\n      rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this"},{"tailPos":6851,"headPos":6785,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ 1"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : p₁ ∈ Finset.biUnion s tᶜ\nhp₂ : p₂ ∈ Finset.biUnion s tᶜ\n⊢ p₁ = p₂"],"content":"refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _"},{"tailPos":6867,"headPos":6858,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : p₁ ∈ (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})ᶜ\nhp₂ : p₂ ∈ (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})ᶜ\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : p₁ ∈ (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})ᶜ\nhp₂ : p₂ ∈ (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})ᶜ\n⊢ p₁ = p₂"],"content":"simp_rw ["},{"tailPos":6884,"headPos":6867,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : p₁ ∈ (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})ᶜ\nhp₂ : p₂ ∈ (Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l})ᶜ\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ¬p₁ ∈ Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l}\nhp₂ : ¬p₂ ∈ Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l}\n⊢ p₁ = p₂"],"content":"Finset.mem_compl,"},{"tailPos":6904,"headPos":6885,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ¬p₁ ∈ Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l}\nhp₂ : ¬p₂ ∈ Finset.biUnion s fun l => Set.toFinset {p | ¬p ∈ l}\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ¬∃ a, a ∈ s ∧ p₁ ∈ Set.toFinset {p | ¬p ∈ a}\nhp₂ : ¬∃ a, a ∈ s ∧ p₂ ∈ Set.toFinset {p | ¬p ∈ a}\n⊢ p₁ = p₂"],"content":"Finset.mem_biUnion,"},{"tailPos":6917,"headPos":6905,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ¬∃ a, a ∈ s ∧ p₁ ∈ Set.toFinset {p | ¬p ∈ a}\nhp₂ : ¬∃ a, a ∈ s ∧ p₂ ∈ Set.toFinset {p | ¬p ∈ a}\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ¬∃ a, a ∈ s ∧ p₁ ∈ Set.toFinset {p | ¬p ∈ a}\nhp₂ : ¬∃ a, a ∈ s ∧ p₂ ∈ Set.toFinset {p | ¬p ∈ a}\n⊢ p₁ = p₂"],"content":"exists_prop,"},{"tailPos":6929,"headPos":6918,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ¬∃ a, a ∈ s ∧ p₁ ∈ Set.toFinset {p | ¬p ∈ a}\nhp₂ : ¬∃ a, a ∈ s ∧ p₂ ∈ Set.toFinset {p | ¬p ∈ a}\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), ¬(x ∈ s ∧ p₁ ∈ Set.toFinset {p | ¬p ∈ x})\nhp₂ : ∀ (x : L), ¬(x ∈ s ∧ p₂ ∈ Set.toFinset {p | ¬p ∈ x})\n⊢ p₁ = p₂"],"content":"not_exists,"},{"tailPos":6938,"headPos":6930,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), ¬(x ∈ s ∧ p₁ ∈ Set.toFinset {p | ¬p ∈ x})\nhp₂ : ∀ (x : L), ¬(x ∈ s ∧ p₂ ∈ Set.toFinset {p | ¬p ∈ x})\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → ¬p₁ ∈ Set.toFinset {p | ¬p ∈ x}\nhp₂ : ∀ (x : L), x ∈ s → ¬p₂ ∈ Set.toFinset {p | ¬p ∈ x}\n⊢ p₁ = p₂"],"content":"not_and,"},{"tailPos":6964,"headPos":6947,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → ¬p₁ ∈ Set.toFinset {p | ¬p ∈ x}\nhp₂ : ∀ (x : L), x ∈ s → ¬p₂ ∈ Set.toFinset {p | ¬p ∈ x}\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → ¬p₁ ∈ {p | ¬p ∈ x}\nhp₂ : ∀ (x : L), x ∈ s → ¬p₂ ∈ {p | ¬p ∈ x}\n⊢ p₁ = p₂"],"content":"Set.mem_toFinset,"},{"tailPos":6982,"headPos":6965,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → ¬p₁ ∈ {p | ¬p ∈ x}\nhp₂ : ∀ (x : L), x ∈ s → ¬p₂ ∈ {p | ¬p ∈ x}\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → ¬¬p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → ¬¬p₂ ∈ x\n⊢ p₁ = p₂"],"content":"Set.mem_setOf_eq,"},{"tailPos":7000,"headPos":6983,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → ¬¬p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → ¬¬p₂ ∈ x\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → p₂ ∈ x\n⊢ p₁ = p₂"],"content":"simp only [not_not] at hp₁ hp₂ "},{"tailPos":7016,"headPos":6858,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : p₁ ∈ Finset.biUnion s tᶜ\nhp₂ : p₂ ∈ Finset.biUnion s tᶜ\n⊢ p₁ = p₂"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → p₂ ∈ x\n⊢ p₁ = p₂"],"content":"simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂"},{"tailPos":7163,"headPos":7023,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → p₂ ∈ x\n⊢ p₁ = p₂"],"goalsAfter":["case intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → p₂ ∈ x\nl₁ l₂ : L\nhl₁ : l₁ ∈ s\nhl₂ : l₂ ∈ s\nhl₃ : l₁ ≠ l₂\n⊢ p₁ = p₂"],"content":"obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)"},{"tailPos":7282,"headPos":7170,"goalsBefore":["case intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\np₁ p₂ : P\nhp₁ : ∀ (x : L), x ∈ s → p₁ ∈ x\nhp₂ : ∀ (x : L), x ∈ s → p₂ ∈ x\nl₁ l₂ : L\nhl₁ : l₁ ∈ s\nhl₂ : l₂ ∈ s\nhl₃ : l₁ ≠ l₂\n⊢ p₁ = p₂"],"goalsAfter":[],"content":"exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃"},{"tailPos":7282,"headPos":6785,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ 1"],"goalsAfter":[],"content":"refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃"},{"tailPos":6726,"headPos":6724,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ 1"],"goalsAfter":[],"content":"by"},{"tailPos":7282,"headPos":6724,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ 1"],"goalsAfter":[],"content":"by\n      -- At most one line through two points of `s`\n      refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃"},{"tailPos":7282,"headPos":6682,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"content":"have hs₂ : s.biUnion tᶜ.card ≤ 1 := by\n      -- At most one line through two points of `s`\n      refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃"},{"tailPos":7317,"headPos":7287,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"content":"by_cases hs₃ : sᶜ.card = 0"},{"tailPos":7324,"headPos":7322,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"content":"·"},{"tailPos":7335,"headPos":7329,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ 0"],"content":"hs₃,"},{"tailPos":7347,"headPos":7336,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ 0"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) = 0"],"content":"le_zero_iff"},{"tailPos":7348,"headPos":7347,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) = 0"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) = 0"],"content":"]"},{"tailPos":7348,"headPos":7325,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) = 0"],"content":"rw [hs₃, le_zero_iff]"},{"tailPos":7377,"headPos":7359,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) = 0"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Fintype.card L - Finset.card s = 0\n⊢ Fintype.card P - Finset.card (Finset.biUnion s t) = 0"],"content":"Finset.card_compl,"},{"tailPos":7398,"headPos":7378,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Fintype.card L - Finset.card s = 0\n⊢ Fintype.card P - Finset.card (Finset.biUnion s t) = 0"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Fintype.card L ≤ Finset.card s\n⊢ Fintype.card P ≤ Finset.card (Finset.biUnion s t)"],"content":"tsub_eq_zero_iff_le,"},{"tailPos":7439,"headPos":7399,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Fintype.card L ≤ Finset.card s\n⊢ Fintype.card P ≤ Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Fintype.card L = Finset.card s\n⊢ Fintype.card P = Finset.card (Finset.biUnion s t)"],"content":"LE.le.le_iff_eq (Finset.card_le_univ _),"},{"tailPos":7448,"headPos":7440,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Fintype.card L = Finset.card s\n⊢ Fintype.card P = Finset.card (Finset.biUnion s t)"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card s = Fintype.card L\n⊢ Finset.card (Finset.biUnion s t) = Fintype.card P"],"content":"eq_comm,"},{"tailPos":7483,"headPos":7457,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card s = Fintype.card L\n⊢ Finset.card (Finset.biUnion s t) = Fintype.card P"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion s t = Finset.univ"],"content":"Finset.card_eq_iff_eq_univ"},{"tailPos":7484,"headPos":7483,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion s t = Finset.univ"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion s t = Finset.univ"],"content":"]"},{"tailPos":7496,"headPos":7355,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) = 0"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion s t = Finset.univ"],"content":"rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃⊢"},{"tailPos":7512,"headPos":7507,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion s t = Finset.univ"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion Finset.univ t = Finset.univ"],"content":"hs₃"},{"tailPos":7513,"headPos":7512,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion Finset.univ t = Finset.univ"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion Finset.univ t = Finset.univ"],"content":"]"},{"tailPos":7513,"headPos":7503,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion s t = Finset.univ"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion Finset.univ t = Finset.univ"],"content":"rw [hs₃]"},{"tailPos":7549,"headPos":7524,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion Finset.univ t = Finset.univ"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ∀ (x : L), x ∈ s\n⊢ ∀ (x : P), x ∈ Finset.biUnion Finset.univ t"],"content":"Finset.eq_univ_iff_forall"},{"tailPos":7550,"headPos":7549,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ∀ (x : L), x ∈ s\n⊢ ∀ (x : P), x ∈ Finset.biUnion Finset.univ t"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ∀ (x : L), x ∈ s\n⊢ ∀ (x : P), x ∈ Finset.biUnion Finset.univ t"],"content":"]"},{"tailPos":7562,"headPos":7520,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : s = Finset.univ\n⊢ Finset.biUnion Finset.univ t = Finset.univ"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ∀ (x : L), x ∈ s\n⊢ ∀ (x : P), x ∈ Finset.biUnion Finset.univ t"],"content":"rw [Finset.eq_univ_iff_forall] at hs₃⊢"},{"tailPos":7761,"headPos":7569,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ∀ (x : L), x ∈ s\n⊢ ∀ (x : P), x ∈ Finset.biUnion Finset.univ t"],"goalsAfter":[],"content":"exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩"},{"tailPos":7761,"headPos":7325,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":[],"content":"rw [hs₃, le_zero_iff]\n      rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃⊢\n      rw [hs₃]\n      rw [Finset.eq_univ_iff_forall] at hs₃⊢\n      exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩"},{"tailPos":7761,"headPos":7322,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)","case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"content":"· rw [hs₃, le_zero_iff]\n      rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃⊢\n      rw [hs₃]\n      rw [Finset.eq_univ_iff_forall] at hs₃⊢\n      exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩"},{"tailPos":7768,"headPos":7766,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"content":"·"},{"tailPos":7821,"headPos":7769,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":[],"content":"exact hs₂.trans (Nat.one_le_iff_ne_zero.mpr hs₃)"},{"tailPos":7821,"headPos":7766,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\nt : L → Finset P := fun l => Set.toFinset {p | ¬p ∈ l}\ns : Finset L\nhs₀ : ¬Finset.card s = 0\nhs₁ : ¬Finset.card s = 1\nhs₂ : Finset.card (Finset.biUnion s tᶜ) ≤ 1\nhs₃ : ¬Finset.card (sᶜ) = 0\n⊢ Finset.card (Finset.biUnion s tᶜ) ≤ Finset.card (sᶜ)"],"goalsAfter":[],"content":"· exact hs₂.trans (Nat.one_le_iff_ne_zero.mpr hs₃)"},{"tailPos":7821,"headPos":5544,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":[],"content":"let t : L → Finset P := fun l => Set.toFinset { p | p ∉ l }\n    suffices ∀ s : Finset L, s.card ≤ (s.biUnion t).card by\n      -- Hall's marriage theorem\n      obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩\n    intro s\n    by_cases hs₀ : s.card = 0\n    -- If `s = ∅`, then `s.card = 0 ≤ (s.bUnion t).card`\n    · simp_rw [hs₀, zero_le]\n    by_cases hs₁ : s.card = 1\n    -- If `s = {l}`, then pick a point `p ∉ l`\n    · obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point l\n      rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]\n      exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)\n    suffices s.biUnion tᶜ.card ≤ sᶜ.card by\n      -- Rephrase in terms of complements (uses `h`)\n      rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this\n    have hs₂ : s.biUnion tᶜ.card ≤ 1 := by\n      -- At most one line through two points of `s`\n      refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃\n    by_cases hs₃ : sᶜ.card = 0\n    · rw [hs₃, le_zero_iff]\n      rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃⊢\n      rw [hs₃]\n      rw [Finset.eq_univ_iff_forall] at hs₃⊢\n      exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩\n    · exact hs₂.trans (Nat.one_le_iff_ne_zero.mpr hs₃)"},{"tailPos":7821,"headPos":5530,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":[],"content":"classical\n    let t : L → Finset P := fun l => Set.toFinset { p | p ∉ l }\n    suffices ∀ s : Finset L, s.card ≤ (s.biUnion t).card by\n      -- Hall's marriage theorem\n      obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩\n    intro s\n    by_cases hs₀ : s.card = 0\n    -- If `s = ∅`, then `s.card = 0 ≤ (s.bUnion t).card`\n    · simp_rw [hs₀, zero_le]\n    by_cases hs₁ : s.card = 1\n    -- If `s = {l}`, then pick a point `p ∉ l`\n    · obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point l\n      rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]\n      exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)\n    suffices s.biUnion tᶜ.card ≤ sᶜ.card by\n      -- Rephrase in terms of complements (uses `h`)\n      rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this\n    have hs₂ : s.biUnion tᶜ.card ≤ 1 := by\n      -- At most one line through two points of `s`\n      refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃\n    by_cases hs₃ : sᶜ.card = 0\n    · rw [hs₃, le_zero_iff]\n      rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃⊢\n      rw [hs₃]\n      rw [Finset.eq_univ_iff_forall] at hs₃⊢\n      exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩\n    · exact hs₂.trans (Nat.one_le_iff_ne_zero.mpr hs₃)"},{"tailPos":5527,"headPos":5525,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":[],"content":"by"},{"tailPos":7821,"headPos":5525,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card L ≤ Fintype.card P\n⊢ ∃ f, Function.Injective f ∧ ∀ (l : L), ¬f l ∈ l"],"goalsAfter":[],"content":"by\n  classical\n    let t : L → Finset P := fun l => Set.toFinset { p | p ∉ l }\n    suffices ∀ s : Finset L, s.card ≤ (s.biUnion t).card by\n      -- Hall's marriage theorem\n      obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩\n    intro s\n    by_cases hs₀ : s.card = 0\n    -- If `s = ∅`, then `s.card = 0 ≤ (s.bUnion t).card`\n    · simp_rw [hs₀, zero_le]\n    by_cases hs₁ : s.card = 1\n    -- If `s = {l}`, then pick a point `p ∉ l`\n    · obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point l\n      rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]\n      exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)\n    suffices s.biUnion tᶜ.card ≤ sᶜ.card by\n      -- Rephrase in terms of complements (uses `h`)\n      rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this\n    have hs₂ : s.biUnion tᶜ.card ≤ 1 := by\n      -- At most one line through two points of `s`\n      refine' Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => _\n      simp_rw [Finset.mem_compl, Finset.mem_biUnion, exists_prop, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃\n    by_cases hs₃ : sᶜ.card = 0\n    · rw [hs₃, le_zero_iff]\n      rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃⊢\n      rw [hs₃]\n      rw [Finset.eq_univ_iff_forall] at hs₃⊢\n      exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩\n    · exact hs₂.trans (Nat.one_le_iff_ne_zero.mpr hs₃)"},{"tailPos":8756,"headPos":8673,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ ∑ p : P, lineCount L p = ∑ l : L, pointCount P l"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card ((a : P) × { l // a ∈ l }) = Fintype.card ((a : L) × { p // p ∈ a })"],"content":"simp only [lineCount, pointCount, Nat.card_eq_fintype_card, ← Fintype.card_sigma]"},{"tailPos":8785,"headPos":8761,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card ((a : P) × { l // a ∈ l }) = Fintype.card ((a : L) × { p // p ∈ a })"],"goalsAfter":["case f\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ (a : P) × { l // a ∈ l } ≃ (a : L) × { p // p ∈ a }"],"content":"apply Fintype.card_congr"},{"tailPos":9128,"headPos":8790,"goalsBefore":["case f\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ (a : P) × { l // a ∈ l } ≃ (a : L) × { p // p ∈ a }"],"goalsAfter":[],"content":"calc\n      (Σp, { l : L // p ∈ l }) ≃ { x : P × L // x.1 ∈ x.2 } :=\n        (Equiv.subtypeProdEquivSigmaSubtype (· ∈ ·)).symm\n      _ ≃ { x : L × P // x.2 ∈ x.1 } := ((Equiv.prodComm P L).subtypeEquiv fun x => Iff.rfl)\n      _ ≃ Σl, { p // p ∈ l } := Equiv.subtypeProdEquivSigmaSubtype fun (l : L) (p : P) => p ∈ l"},{"tailPos":9128,"headPos":8673,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ ∑ p : P, lineCount L p = ∑ l : L, pointCount P l"],"goalsAfter":[],"content":"simp only [lineCount, pointCount, Nat.card_eq_fintype_card, ← Fintype.card_sigma]\n    apply Fintype.card_congr\n    calc\n      (Σp, { l : L // p ∈ l }) ≃ { x : P × L // x.1 ∈ x.2 } :=\n        (Equiv.subtypeProdEquivSigmaSubtype (· ∈ ·)).symm\n      _ ≃ { x : L × P // x.2 ∈ x.1 } := ((Equiv.prodComm P L).subtypeEquiv fun x => Iff.rfl)\n      _ ≃ Σl, { p // p ∈ l } := Equiv.subtypeProdEquivSigmaSubtype fun (l : L) (p : P) => p ∈ l"},{"tailPos":9128,"headPos":8659,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ ∑ p : P, lineCount L p = ∑ l : L, pointCount P l"],"goalsAfter":[],"content":"classical\n    simp only [lineCount, pointCount, Nat.card_eq_fintype_card, ← Fintype.card_sigma]\n    apply Fintype.card_congr\n    calc\n      (Σp, { l : L // p ∈ l }) ≃ { x : P × L // x.1 ∈ x.2 } :=\n        (Equiv.subtypeProdEquivSigmaSubtype (· ∈ ·)).symm\n      _ ≃ { x : L × P // x.2 ∈ x.1 } := ((Equiv.prodComm P L).subtypeEquiv fun x => Iff.rfl)\n      _ ≃ Σl, { p // p ∈ l } := Equiv.subtypeProdEquivSigmaSubtype fun (l : L) (p : P) => p ∈ l"},{"tailPos":8656,"headPos":8654,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ ∑ p : P, lineCount L p = ∑ l : L, pointCount P l"],"goalsAfter":[],"content":"by"},{"tailPos":9128,"headPos":8654,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ ∑ p : P, lineCount L p = ∑ l : L, pointCount P l"],"goalsAfter":[],"content":"by\n  classical\n    simp only [lineCount, pointCount, Nat.card_eq_fintype_card, ← Fintype.card_sigma]\n    apply Fintype.card_congr\n    calc\n      (Σp, { l : L // p ∈ l }) ≃ { x : P × L // x.1 ∈ x.2 } :=\n        (Equiv.subtypeProdEquivSigmaSubtype (· ∈ ·)).symm\n      _ ≃ { x : L × P // x.2 ∈ x.1 } := ((Equiv.prodComm P L).subtypeEquiv fun x => Iff.rfl)\n      _ ≃ Σl, { p // p ∈ l } := Equiv.subtypeProdEquivSigmaSubtype fun (l : L) (p : P) => p ∈ l"},{"tailPos":9453,"headPos":9410,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p","case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"content":"by_cases hf : Infinite { p : P // p ∈ l }"},{"tailPos":9458,"headPos":9456,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p","case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case pos\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"content":"·"},{"tailPos":9536,"headPos":9459,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":[],"content":"exact (le_of_eq Nat.card_eq_zero_of_infinite).trans (zero_le (lineCount L p))"},{"tailPos":9536,"headPos":9456,"goalsBefore":["case pos\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p","case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"content":"· exact (le_of_eq Nat.card_eq_zero_of_infinite).trans (zero_le (lineCount L p))"},{"tailPos":9571,"headPos":9539,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"content":"haveI := fintypeOfNotInfinite hf"},{"tailPos":9617,"headPos":9574,"goalsBefore":["case neg\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"content":"cases nonempty_fintype { l : L // p ∈ l }"},{"tailPos":9634,"headPos":9624,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ pointCount P l ≤ Nat.card { l // p ∈ l }"],"content":"lineCount,"},{"tailPos":9646,"headPos":9635,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ pointCount P l ≤ Nat.card { l // p ∈ l }"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Nat.card { p // p ∈ l } ≤ Nat.card { l // p ∈ l }"],"content":"pointCount,"},{"tailPos":9672,"headPos":9647,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Nat.card { p // p ∈ l } ≤ Nat.card { l // p ∈ l }"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Nat.card { l // p ∈ l }"],"content":"Nat.card_eq_fintype_card,"},{"tailPos":9697,"headPos":9673,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Nat.card { l // p ∈ l }"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"content":"Nat.card_eq_fintype_card"},{"tailPos":9698,"headPos":9697,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"content":"]"},{"tailPos":9698,"headPos":9620,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"content":"rw [lineCount, pointCount, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]"},{"tailPos":9800,"headPos":9701,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"goalsAfter":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis✝ : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\nthis : ∀ (p' : { p // p ∈ l }), p ≠ ↑p'\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"content":"have : ∀ p' : { p // p ∈ l }, p ≠ p' := fun p' hp' => h ((congr_arg (· ∈ l) hp').mpr p'.2)"},{"tailPos":10183,"headPos":9803,"goalsBefore":["case neg.intro\nP : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\nhf : ¬Infinite { p // p ∈ l }\nthis✝ : Fintype { p // p ∈ l }\nval✝ : Fintype { l // p ∈ l }\nthis : ∀ (p' : { p // p ∈ l }), p ≠ ↑p'\n⊢ Fintype.card { p // p ∈ l } ≤ Fintype.card { l // p ∈ l }"],"goalsAfter":[],"content":"exact\n    Fintype.card_le_of_injective (fun p' => ⟨mkLine (this p'), (mkLine_ax (this p')).1⟩)\n      fun p₁ p₂ hp =>\n      Subtype.ext\n        ((eq_or_eq p₁.2 p₂.2 (mkLine_ax (this p₁)).2\n              ((congr_arg _ (Subtype.ext_iff.mp hp)).mpr (mkLine_ax (this p₂)).2)).resolve_right\n          fun h' => (congr_arg (¬p ∈ ·) h').mp h (mkLine_ax (this p₁)).1)"},{"tailPos":10183,"headPos":9410,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":[],"content":"by_cases hf : Infinite { p : P // p ∈ l }\n  · exact (le_of_eq Nat.card_eq_zero_of_infinite).trans (zero_le (lineCount L p))\n  haveI := fintypeOfNotInfinite hf\n  cases nonempty_fintype { l : L // p ∈ l }\n  rw [lineCount, pointCount, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]\n  have : ∀ p' : { p // p ∈ l }, p ≠ p' := fun p' hp' => h ((congr_arg (· ∈ l) hp').mpr p'.2)\n  exact\n    Fintype.card_le_of_injective (fun p' => ⟨mkLine (this p'), (mkLine_ax (this p')).1⟩)\n      fun p₁ p₂ hp =>\n      Subtype.ext\n        ((eq_or_eq p₁.2 p₂.2 (mkLine_ax (this p₁)).2\n              ((congr_arg _ (Subtype.ext_iff.mp hp)).mpr (mkLine_ax (this p₂)).2)).resolve_right\n          fun h' => (congr_arg (¬p ∈ ·) h').mp h (mkLine_ax (this p₁)).1)"},{"tailPos":9407,"headPos":9405,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":[],"content":"by"},{"tailPos":10183,"headPos":9405,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : HasLines P L\np : P\nl : L\nh : ¬p ∈ l\ninst✝ : Finite { l // p ∈ l }\n⊢ pointCount P l ≤ lineCount L p"],"goalsAfter":[],"content":"by\n  by_cases hf : Infinite { p : P // p ∈ l }\n  · exact (le_of_eq Nat.card_eq_zero_of_infinite).trans (zero_le (lineCount L p))\n  haveI := fintypeOfNotInfinite hf\n  cases nonempty_fintype { l : L // p ∈ l }\n  rw [lineCount, pointCount, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]\n  have : ∀ p' : { p // p ∈ l }, p ≠ p' := fun p' hp' => h ((congr_arg (· ∈ l) hp').mpr p'.2)\n  exact\n    Fintype.card_le_of_injective (fun p' => ⟨mkLine (this p'), (mkLine_ax (this p')).1⟩)\n      fun p₁ p₂ hp =>\n      Subtype.ext\n        ((eq_or_eq p₁.2 p₂.2 (mkLine_ax (this p₁)).2\n              ((congr_arg _ (Subtype.ext_iff.mp hp)).mpr (mkLine_ax (this p₂)).2)).resolve_right\n          fun h' => (congr_arg (¬p ∈ ·) h').mp h (mkLine_ax (this p₁)).1)"},{"tailPos":10885,"headPos":10870,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card P ≤ Fintype.card L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\n⊢ False"],"content":"by_contra hc₂"},{"tailPos":10982,"headPos":10888,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\n⊢ False"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\n⊢ False"],"content":"obtain ⟨f, hf₁, hf₂⟩ := Nondegenerate.exists_injective_of_card_le (le_of_not_le hc₂)"},{"tailPos":11475,"headPos":11459,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ p ∈ Finset.image f Finset.univ → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ (∃ a, a ∈ Finset.univ ∧ f a = p) → ∃ a ha, p = (fun l x => f l) a ha"],"content":"Finset.mem_image"},{"tailPos":11476,"headPos":11475,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ (∃ a, a ∈ Finset.univ ∧ f a = p) → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ (∃ a, a ∈ Finset.univ ∧ f a = p) → ∃ a ha, p = (fun l x => f l) a ha"],"content":"]"},{"tailPos":11476,"headPos":11455,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ p ∈ Finset.image f Finset.univ → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ (∃ a, a ∈ Finset.univ ∧ f a = p) → ∃ a ha, p = (fun l x => f l) a ha"],"content":"rw [Finset.mem_image]"},{"tailPos":11546,"headPos":11487,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ (∃ a, a ∈ Finset.univ ∧ f a = p) → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":[],"content":"exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩"},{"tailPos":11546,"headPos":11455,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ p ∈ Finset.image f Finset.univ → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":[],"content":"rw [Finset.mem_image]\n          exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩"},{"tailPos":11444,"headPos":11442,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ p ∈ Finset.image f Finset.univ → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":[],"content":"by"},{"tailPos":11546,"headPos":11442,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\n⊢ p ∈ Finset.image f Finset.univ → ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":[],"content":"by\n          rw [Finset.mem_image]\n          exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩"},{"tailPos":11673,"headPos":11593,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\n⊢ ∑ p in Finset.image f Finset.univ, lineCount L p < ∑ p : P, lineCount L p"],"goalsAfter":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ∑ p in Finset.image f Finset.univ, lineCount L p < ∑ p : P, lineCount L p"],"content":"obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)"},{"tailPos":11834,"headPos":11682,"goalsBefore":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ∑ p in Finset.image f Finset.univ, lineCount L p < ∑ p : P, lineCount L p"],"goalsAfter":["case intro.refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ¬p ∈ Finset.image f Finset.univ","case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"content":"refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)"},{"tailPos":11845,"headPos":11843,"goalsBefore":["case intro.refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ¬p ∈ Finset.image f Finset.univ","case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":["case intro.refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ¬p ∈ Finset.image f Finset.univ"],"content":"·"},{"tailPos":11919,"headPos":11846,"goalsBefore":["case intro.refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ¬p ∈ Finset.image f Finset.univ"],"goalsAfter":[],"content":"simpa only [Finset.mem_image, Finset.mem_univ, true_and_iff]"},{"tailPos":11919,"headPos":11843,"goalsBefore":["case intro.refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ ¬p ∈ Finset.image f Finset.univ","case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"content":"· simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]"},{"tailPos":11930,"headPos":11928,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"content":"·"},{"tailPos":11945,"headPos":11935,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < Nat.card { l // p ∈ l }"],"content":"lineCount,"},{"tailPos":11971,"headPos":11946,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < Nat.card { l // p ∈ l }"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < Fintype.card { l // p ∈ l }"],"content":"Nat.card_eq_fintype_card,"},{"tailPos":11992,"headPos":11972,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < Fintype.card { l // p ∈ l }"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ Nonempty { l // p ∈ l }"],"content":"Fintype.card_pos_iff"},{"tailPos":11993,"headPos":11992,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ Nonempty { l // p ∈ l }"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ Nonempty { l // p ∈ l }"],"content":"]"},{"tailPos":11993,"headPos":11931,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ Nonempty { l // p ∈ l }"],"content":"rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]"},{"tailPos":12047,"headPos":12004,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ Nonempty { l // p ∈ l }"],"goalsAfter":["case intro.refine'_2.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\nl : L\nh✝ : ¬p ∈ l\n⊢ Nonempty { l // p ∈ l }"],"content":"obtain ⟨l, _⟩ := @exists_line P L _ _ p"},{"tailPos":12162,"headPos":12058,"goalsBefore":["case intro.refine'_2.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\nl : L\nh✝ : ¬p ∈ l\n⊢ Nonempty { l // p ∈ l }"],"goalsAfter":[],"content":"exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩"},{"tailPos":12162,"headPos":11931,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":[],"content":"rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩"},{"tailPos":12162,"headPos":11928,"goalsBefore":["case intro.refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\np : P\nhp : ¬∃ a, f a = p\n⊢ 0 < lineCount L p"],"goalsAfter":[],"content":"· rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩"},{"tailPos":12162,"headPos":11593,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\n⊢ ∑ p in Finset.image f Finset.univ, lineCount L p < ∑ p : P, lineCount L p"],"goalsAfter":[],"content":"obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)\n        · simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩"},{"tailPos":11584,"headPos":11582,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\n⊢ ∑ p in Finset.image f Finset.univ, lineCount L p < ∑ p : P, lineCount L p"],"goalsAfter":[],"content":"by"},{"tailPos":12162,"headPos":11582,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\n⊢ ∑ p in Finset.image f Finset.univ, lineCount L p < ∑ p : P, lineCount L p"],"goalsAfter":[],"content":"by\n        obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)\n        · simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩"},{"tailPos":12162,"headPos":10985,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\n⊢ False"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\nthis : ∑ p : P, lineCount L p < ∑ p : P, lineCount L p\n⊢ False"],"content":"have :=\n    calc\n      (∑ p, lineCount L p) = ∑ l, pointCount P l := sum_lineCount_eq_sum_pointCount P L\n      _ ≤ ∑ l, lineCount L (f l) :=\n        (Finset.sum_le_sum fun l _ => HasLines.pointCount_le_lineCount (hf₂ l))\n      _ = ∑ p in Finset.univ.image f, lineCount L p :=\n        (Finset.sum_bij (fun l _ => f l) (fun l hl => Finset.mem_image_of_mem f hl)\n          (fun l _ => rfl) (fun l₁ l₂ hl₁ hl₂ hl₃ => hf₁ hl₃) fun p => by\n          rw [Finset.mem_image]\n          exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩)\n      _ < ∑ p, lineCount L p := by\n        obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)\n        · simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩"},{"tailPos":12187,"headPos":12165,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhc₂ : ¬Fintype.card P ≤ Fintype.card L\nf : L → P\nhf₁ : Function.Injective f\nhf₂ : ∀ (l : L), ¬f l ∈ l\nthis : ∑ p : P, lineCount L p < ∑ p : P, lineCount L p\n⊢ False"],"goalsAfter":[],"content":"exact lt_irrefl _ this"},{"tailPos":12187,"headPos":10870,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card P ≤ Fintype.card L"],"goalsAfter":[],"content":"by_contra hc₂\n  obtain ⟨f, hf₁, hf₂⟩ := Nondegenerate.exists_injective_of_card_le (le_of_not_le hc₂)\n  have :=\n    calc\n      (∑ p, lineCount L p) = ∑ l, pointCount P l := sum_lineCount_eq_sum_pointCount P L\n      _ ≤ ∑ l, lineCount L (f l) :=\n        (Finset.sum_le_sum fun l _ => HasLines.pointCount_le_lineCount (hf₂ l))\n      _ = ∑ p in Finset.univ.image f, lineCount L p :=\n        (Finset.sum_bij (fun l _ => f l) (fun l hl => Finset.mem_image_of_mem f hl)\n          (fun l _ => rfl) (fun l₁ l₂ hl₁ hl₂ hl₃ => hf₁ hl₃) fun p => by\n          rw [Finset.mem_image]\n          exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩)\n      _ < ∑ p, lineCount L p := by\n        obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)\n        · simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩\n  exact lt_irrefl _ this"},{"tailPos":12187,"headPos":10858,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card P ≤ Fintype.card L"],"goalsAfter":[],"content":"classical\n  by_contra hc₂\n  obtain ⟨f, hf₁, hf₂⟩ := Nondegenerate.exists_injective_of_card_le (le_of_not_le hc₂)\n  have :=\n    calc\n      (∑ p, lineCount L p) = ∑ l, pointCount P l := sum_lineCount_eq_sum_pointCount P L\n      _ ≤ ∑ l, lineCount L (f l) :=\n        (Finset.sum_le_sum fun l _ => HasLines.pointCount_le_lineCount (hf₂ l))\n      _ = ∑ p in Finset.univ.image f, lineCount L p :=\n        (Finset.sum_bij (fun l _ => f l) (fun l hl => Finset.mem_image_of_mem f hl)\n          (fun l _ => rfl) (fun l₁ l₂ hl₁ hl₂ hl₃ => hf₁ hl₃) fun p => by\n          rw [Finset.mem_image]\n          exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩)\n      _ < ∑ p, lineCount L p := by\n        obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)\n        · simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩\n  exact lt_irrefl _ this"},{"tailPos":10855,"headPos":10853,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card P ≤ Fintype.card L"],"goalsAfter":[],"content":"by"},{"tailPos":12187,"headPos":10853,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Fintype.card P ≤ Fintype.card L"],"goalsAfter":[],"content":"by\n  classical\n  by_contra hc₂\n  obtain ⟨f, hf₁, hf₂⟩ := Nondegenerate.exists_injective_of_card_le (le_of_not_le hc₂)\n  have :=\n    calc\n      (∑ p, lineCount L p) = ∑ l, pointCount P l := sum_lineCount_eq_sum_pointCount P L\n      _ ≤ ∑ l, lineCount L (f l) :=\n        (Finset.sum_le_sum fun l _ => HasLines.pointCount_le_lineCount (hf₂ l))\n      _ = ∑ p in Finset.univ.image f, lineCount L p :=\n        (Finset.sum_bij (fun l _ => f l) (fun l hl => Finset.mem_image_of_mem f hl)\n          (fun l _ => rfl) (fun l₁ l₂ hl₁ hl₂ hl₃ => hf₁ hl₃) fun p => by\n          rw [Finset.mem_image]\n          exact fun ⟨a, ⟨h, h'⟩⟩ => ⟨a, ⟨h, h'.symm⟩⟩)\n      _ < ∑ p, lineCount L p := by\n        obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine'\n          Finset.sum_lt_sum_of_subset (Finset.univ.image f).subset_univ (Finset.mem_univ p) _ _\n            fun p _ _ => zero_le (lineCount L p)\n        · simpa only [Finset.mem_image, exists_prop, Finset.mem_univ, true_and_iff]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩\n  exact lt_irrefl _ this"},{"tailPos":12920,"headPos":12838,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"content":"obtain ⟨f, hf1, hf2⟩ := Nondegenerate.exists_injective_of_card_le (ge_of_eq h)"},{"tailPos":13003,"headPos":12925,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\nhf3 : Function.Bijective f\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"content":"have hf3 := (Fintype.bijective_iff_injective_and_card f).mpr ⟨hf1, h.symm⟩"},{"tailPos":13441,"headPos":13008,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\nhf3 : Function.Bijective f\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\nhf3 : Function.Bijective f\nl : L\np : P\nhp : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"content":"refine'\n      ⟨f, hf3, fun l =>\n        (Finset.sum_eq_sum_iff_of_le fun l _ => HasLines.pointCount_le_lineCount (hf2 l)).mp\n          ((sum_lineCount_eq_sum_pointCount P L).symm.trans\n            (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l))\n                (fun l _ => refl (lineCount L (f l))) (fun l₁ l₂ hl₁ hl₂ hl => hf1 hl) fun p hp =>\n                _).symm)\n          l (Finset.mem_univ l)⟩"},{"tailPos":13476,"headPos":13446,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\nhf3 : Function.Bijective f\nl : L\np : P\nhp : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":["case intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\nhf3 : Function.Bijective f\nl✝ l : L\nhp : f l ∈ Finset.univ\n⊢ ∃ a ha, f l = (fun l x => f l) a ha"],"content":"obtain ⟨l, rfl⟩ := hf3.2 p"},{"tailPos":13518,"headPos":13481,"goalsBefore":["case intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nf : L → P\nhf1 : Function.Injective f\nhf2 : ∀ (l : L), ¬f l ∈ l\nhf3 : Function.Bijective f\nl✝ l : L\nhp : f l ∈ Finset.univ\n⊢ ∃ a ha, f l = (fun l x => f l) a ha"],"goalsAfter":[],"content":"exact ⟨l, Finset.mem_univ l, rfl⟩"},{"tailPos":13518,"headPos":12838,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":[],"content":"obtain ⟨f, hf1, hf2⟩ := Nondegenerate.exists_injective_of_card_le (ge_of_eq h)\n    have hf3 := (Fintype.bijective_iff_injective_and_card f).mpr ⟨hf1, h.symm⟩\n    refine'\n      ⟨f, hf3, fun l =>\n        (Finset.sum_eq_sum_iff_of_le fun l _ => HasLines.pointCount_le_lineCount (hf2 l)).mp\n          ((sum_lineCount_eq_sum_pointCount P L).symm.trans\n            (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l))\n                (fun l _ => refl (lineCount L (f l))) (fun l₁ l₂ hl₁ hl₂ hl => hf1 hl) fun p hp =>\n                _).symm)\n          l (Finset.mem_univ l)⟩\n    obtain ⟨l, rfl⟩ := hf3.2 p\n    exact ⟨l, Finset.mem_univ l, rfl⟩"},{"tailPos":13518,"headPos":12824,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":[],"content":"classical\n    obtain ⟨f, hf1, hf2⟩ := Nondegenerate.exists_injective_of_card_le (ge_of_eq h)\n    have hf3 := (Fintype.bijective_iff_injective_and_card f).mpr ⟨hf1, h.symm⟩\n    refine'\n      ⟨f, hf3, fun l =>\n        (Finset.sum_eq_sum_iff_of_le fun l _ => HasLines.pointCount_le_lineCount (hf2 l)).mp\n          ((sum_lineCount_eq_sum_pointCount P L).symm.trans\n            (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l))\n                (fun l _ => refl (lineCount L (f l))) (fun l₁ l₂ hl₁ hl₂ hl => hf1 hl) fun p hp =>\n                _).symm)\n          l (Finset.mem_univ l)⟩\n    obtain ⟨l, rfl⟩ := hf3.2 p\n    exact ⟨l, Finset.mem_univ l, rfl⟩"},{"tailPos":12821,"headPos":12819,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":[],"content":"by"},{"tailPos":13518,"headPos":12819,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\n⊢ ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l)"],"goalsAfter":[],"content":"by\n  classical\n    obtain ⟨f, hf1, hf2⟩ := Nondegenerate.exists_injective_of_card_le (ge_of_eq h)\n    have hf3 := (Fintype.bijective_iff_injective_and_card f).mpr ⟨hf1, h.symm⟩\n    refine'\n      ⟨f, hf3, fun l =>\n        (Finset.sum_eq_sum_iff_of_le fun l _ => HasLines.pointCount_le_lineCount (hf2 l)).mp\n          ((sum_lineCount_eq_sum_pointCount P L).symm.trans\n            (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l))\n                (fun l _ => refl (lineCount L (f l))) (fun l₁ l₂ hl₁ hl₂ hl => hf1 hl) fun p hp =>\n                _).symm)\n          l (Finset.mem_univ l)⟩\n    obtain ⟨l, rfl⟩ := hf3.2 p\n    exact ⟨l, Finset.mem_univ l, rfl⟩"},{"tailPos":13913,"headPos":13845,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\n⊢ lineCount L p = pointCount P l"],"content":"obtain ⟨f, hf1, hf2⟩ := HasLines.exists_bijective_of_card_eq hPL"},{"tailPos":13977,"headPos":13918,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ lineCount L p = pointCount P l"],"content":"let s : Finset (P × L) := Set.toFinset { i | i.1 ∈ i.2 }"},{"tailPos":14109,"headPos":14080,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i in Finset.univ ×ˢ Finset.univ, lineCount L i.fst = ∑ i in Finset.univ ×ˢ Finset.univ, pointCount P i.snd"],"content":"← Finset.univ_product_univ,"},{"tailPos":14135,"headPos":14110,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i in Finset.univ ×ˢ Finset.univ, lineCount L i.fst = ∑ i in Finset.univ ×ˢ Finset.univ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ i in Finset.univ ×ˢ Finset.univ, pointCount P i.snd"],"content":"Finset.sum_product_right,"},{"tailPos":14154,"headPos":14136,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ i in Finset.univ ×ˢ Finset.univ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ x : P, ∑ y : L, pointCount P (x, y).snd"],"content":"Finset.sum_product"},{"tailPos":14155,"headPos":14154,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ x : P, ∑ y : L, pointCount P (x, y).snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ x : P, ∑ y : L, pointCount P (x, y).snd"],"content":"]"},{"tailPos":14155,"headPos":14076,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ x : P, ∑ y : L, pointCount P (x, y).snd"],"content":"rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]"},{"tailPos":14171,"headPos":14162,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ x : L, ∑ x : P, lineCount L x = ∑ x : P, ∑ x : L, pointCount P x"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ x : L, ∑ x : P, lineCount L x = ∑ x : P, ∑ x : L, pointCount P x"],"content":"simp_rw ["},{"tailPos":14188,"headPos":14171,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ x : L, ∑ x : P, lineCount L x = ∑ x : P, ∑ x : L, pointCount P x"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ Finset.card Finset.univ • ∑ x : P, lineCount L x = Finset.card Finset.univ • ∑ x : L, pointCount P x"],"content":"Finset.sum_const,"},{"tailPos":14206,"headPos":14189,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ Finset.card Finset.univ • ∑ x : P, lineCount L x = Finset.card Finset.univ • ∑ x : L, pointCount P x"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ Fintype.card L • ∑ x : P, lineCount L x = Fintype.card P • ∑ x : L, pointCount P x"],"content":"Finset.card_univ,"},{"tailPos":14211,"headPos":14207,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ Fintype.card L • ∑ x : P, lineCount L x = Fintype.card P • ∑ x : L, pointCount P x"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ Fintype.card L • ∑ x : P, lineCount L x = Fintype.card L • ∑ x : L, pointCount P x"],"content":"hPL,"},{"tailPos":14243,"headPos":14212,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ Fintype.card L • ∑ x : P, lineCount L x = Fintype.card L • ∑ x : L, pointCount P x"],"goalsAfter":[],"content":"simp only [sum_lineCount_eq_sum_pointCount]"},{"tailPos":14244,"headPos":14162,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ y : L, ∑ x : P, lineCount L (x, y).fst = ∑ x : P, ∑ y : L, pointCount P (x, y).snd"],"goalsAfter":[],"content":"simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]"},{"tailPos":14244,"headPos":14076,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd"],"goalsAfter":[],"content":"rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]"},{"tailPos":14069,"headPos":14067,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd"],"goalsAfter":[],"content":"by"},{"tailPos":14244,"headPos":14067,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd"],"goalsAfter":[],"content":"by\n      rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]"},{"tailPos":14244,"headPos":13982,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"content":"have step1 : (∑ i : P × L, lineCount L i.1) = ∑ i : P × L, pointCount P i.2 := by\n      rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]"},{"tailPos":14409,"headPos":14339,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst = ∑ i in s, pointCount P i.snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }"},{"tailPos":14410,"headPos":14409,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst = ∑ i in s, pointCount P i.snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst = ∑ i in s, pointCount P i.snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"]"},{"tailPos":14410,"headPos":14335,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst = ∑ i in s, pointCount P i.snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]"},{"tailPos":14497,"headPos":14421,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst = ∑ i in s, pointCount P i.snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst =\n    ∑ c : L, ∑ a in Set.toFinset {p | p ∈ c}, pointCount P (a, c).snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }"},{"tailPos":14498,"headPos":14497,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst =\n    ∑ c : L, ∑ a in Set.toFinset {p | p ∈ c}, pointCount P (a, c).snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst =\n    ∑ c : L, ∑ a in Set.toFinset {p | p ∈ c}, pointCount P (a, c).snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"]"},{"tailPos":14498,"headPos":14417,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst = ∑ i in s, pointCount P i.snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst =\n    ∑ c : L, ∑ a in Set.toFinset {p | p ∈ c}, pointCount P (a, c).snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]"},{"tailPos":14662,"headPos":14505,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ c : P, ∑ a in Set.toFinset {l | c ∈ l}, lineCount L (c, a).fst =\n    ∑ c : L, ∑ a in Set.toFinset {p | p ∈ c}, pointCount P (a, c).snd","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ a in Set.toFinset {p | p ∈ l}, pointCount P (a, l).snd =\n    ∑ a in Set.toFinset {l_1 | (fun l x => f l) l hl ∈ l_1}, lineCount L ((fun l x => f l) l hl, a).fst","case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm"},{"tailPos":14671,"headPos":14669,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ a in Set.toFinset {p | p ∈ l}, pointCount P (a, l).snd =\n    ∑ a in Set.toFinset {l_1 | (fun l x => f l) l hl ∈ l_1}, lineCount L ((fun l x => f l) l hl, a).fst","case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ a in Set.toFinset {p | p ∈ l}, pointCount P (a, l).snd =\n    ∑ a in Set.toFinset {l_1 | (fun l x => f l) l hl ∈ l_1}, lineCount L ((fun l x => f l) l hl, a).fst"],"content":"·"},{"tailPos":14681,"headPos":14672,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ x in Set.toFinset {p | p ∈ l}, pointCount P l = ∑ x in Set.toFinset {l_1 | f l ∈ l_1}, lineCount L (f l)"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ x in Set.toFinset {p | p ∈ l}, pointCount P l = ∑ x in Set.toFinset {l_1 | f l ∈ l_1}, lineCount L (f l)"],"content":"simp_rw ["},{"tailPos":14698,"headPos":14681,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ x in Set.toFinset {p | p ∈ l}, pointCount P l = ∑ x in Set.toFinset {l_1 | f l ∈ l_1}, lineCount L (f l)"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Finset.card (Set.toFinset {p | p ∈ l}) • pointCount P l =\n    Finset.card (Set.toFinset {l_1 | f l ∈ l_1}) • lineCount L (f l)"],"content":"Finset.sum_const,"},{"tailPos":14717,"headPos":14699,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Finset.card (Set.toFinset {p | p ∈ l}) • pointCount P l =\n    Finset.card (Set.toFinset {l_1 | f l ∈ l_1}) • lineCount L (f l)"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Fintype.card ↑{p | p ∈ l} • pointCount P l = Fintype.card ↑{l_1 | f l ∈ l_1} • lineCount L (f l)"],"content":"Set.toFinset_card,"},{"tailPos":14746,"headPos":14718,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Fintype.card ↑{p | p ∈ l} • pointCount P l = Fintype.card ↑{l_1 | f l ∈ l_1} • lineCount L (f l)"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Nat.card ↑{p | p ∈ l} • pointCount P l = Nat.card ↑{l_1 | f l ∈ l_1} • lineCount L (f l)"],"content":"← Nat.card_eq_fintype_card"},{"tailPos":14747,"headPos":14672,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ a in Set.toFinset {p | p ∈ l}, pointCount P (a, l).snd =\n    ∑ a in Set.toFinset {l_1 | (fun l x => f l) l hl ∈ l_1}, lineCount L ((fun l x => f l) l hl, a).fst"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Nat.card ↑{p | p ∈ l} • pointCount P l = Nat.card ↑{l_1 | f l ∈ l_1} • lineCount L (f l)"],"content":"simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]"},{"tailPos":14838,"headPos":14756,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ Nat.card ↑{p | p ∈ l} • pointCount P l = Nat.card ↑{l_1 | f l ∈ l_1} • lineCount L (f l)"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)"],"content":"change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)"},{"tailPos":14854,"headPos":14851,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)"],"goalsAfter":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ lineCount L (f l) • lineCount L (f l) = lineCount L (f l) • lineCount L (f l)"],"content":"hf2"},{"tailPos":14855,"headPos":14854,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ lineCount L (f l) • lineCount L (f l) = lineCount L (f l) • lineCount L (f l)"],"goalsAfter":[],"content":"]"},{"tailPos":14855,"headPos":14847,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)"],"goalsAfter":[],"content":"rw [hf2]"},{"tailPos":14855,"headPos":14672,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ a in Set.toFinset {p | p ∈ l}, pointCount P (a, l).snd =\n    ∑ a in Set.toFinset {l_1 | (fun l x => f l) l hl ∈ l_1}, lineCount L ((fun l x => f l) l hl, a).fst"],"goalsAfter":[],"content":"simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]"},{"tailPos":14855,"headPos":14669,"goalsBefore":["case refine'_1\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl✝ : L\nhpl : ¬p ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nl : L\nhl : l ∈ Finset.univ\n⊢ ∑ a in Set.toFinset {p | p ∈ l}, pointCount P (a, l).snd =\n    ∑ a in Set.toFinset {l_1 | (fun l x => f l) l hl ∈ l_1}, lineCount L ((fun l x => f l) l hl, a).fst","case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"· simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]"},{"tailPos":14864,"headPos":14862,"goalsBefore":["case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"content":"·"},{"tailPos":14894,"headPos":14865,"goalsBefore":["case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":["case refine'_2.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl✝ : L\nhpl : ¬p✝ ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\nl : L\nhl : f l = p\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"content":"obtain ⟨l, hl⟩ := hf1.2 p"},{"tailPos":14944,"headPos":14903,"goalsBefore":["case refine'_2.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl✝ : L\nhpl : ¬p✝ ∈ l✝\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\nl : L\nhl : f l = p\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":[],"content":"exact ⟨l, Finset.mem_univ l, hl.symm⟩"},{"tailPos":14944,"headPos":14865,"goalsBefore":["case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha"],"goalsAfter":[],"content":"obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩"},{"tailPos":14944,"headPos":14862,"goalsBefore":["case refine'_2\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np✝ : P\nl : L\nhpl : ¬p✝ ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\np : P\nx✝ : p ∈ Finset.univ\n⊢ ∃ a ha, p = (fun l x => f l) a ha","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"· obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩"},{"tailPos":14970,"headPos":14961,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"content":"simp_rw ["},{"tailPos":14986,"headPos":14970,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ True ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"content":"Finset.mem_univ,"},{"tailPos":15000,"headPos":14987,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ True ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"content":"true_and_iff,"},{"tailPos":15017,"headPos":15001,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.fst ∈ {p_1 | p_1 ∈ p.snd}"],"content":"simp only [Set.mem_toFinset]"},{"tailPos":15018,"headPos":14961,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.fst ∈ {p_1 | p_1 ∈ p.snd}"],"content":"simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]"},{"tailPos":15019,"headPos":15018,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.fst ∈ {p_1 | p_1 ∈ p.snd}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.fst ∈ {p_1 | p_1 ∈ p.snd}"],"content":";"},{"tailPos":15042,"headPos":15020,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.fst ∈ {p_1 | p_1 ∈ p.snd}"],"goalsAfter":[],"content":"exact fun p => Iff.rfl"},{"tailPos":15042,"headPos":14961,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}"],"goalsAfter":[],"content":"simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl"},{"tailPos":14970,"headPos":14961,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"simp_rw ["},{"tailPos":14986,"headPos":14970,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ True ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"Finset.mem_univ,"},{"tailPos":15000,"headPos":14987,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ True ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"content":"true_and_iff,"},{"tailPos":15017,"headPos":15001,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ Set.toFinset {i | i.fst ∈ i.snd} ↔ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.snd ∈ {l | p.fst ∈ l}"],"content":"simp only [Set.mem_toFinset]"},{"tailPos":15018,"headPos":14961,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.snd ∈ {l | p.fst ∈ l}"],"content":"simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]"},{"tailPos":15019,"headPos":15018,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.snd ∈ {l | p.fst ∈ l}"],"goalsAfter":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.snd ∈ {l | p.fst ∈ l}"],"content":";"},{"tailPos":15042,"headPos":15020,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ {i | i.fst ∈ i.snd} ↔ p.snd ∈ {l | p.fst ∈ l}"],"goalsAfter":[],"content":"exact fun p => Iff.rfl"},{"tailPos":15042,"headPos":14961,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":[],"content":"simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl"},{"tailPos":15042,"headPos":14951,"goalsBefore":["case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.snd ∈ Finset.univ ∧ p.fst ∈ Set.toFinset {p_1 | p_1 ∈ p.snd}","case h\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∀ (p : P × L), p ∈ s ↔ p.fst ∈ Finset.univ ∧ p.snd ∈ Set.toFinset {l | p.fst ∈ l}"],"goalsAfter":[],"content":"all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl"},{"tailPos":15042,"headPos":14335,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd"],"goalsAfter":[],"content":"rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]\n      refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm\n      · simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]\n      · obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩\n      all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl"},{"tailPos":14328,"headPos":14326,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd"],"goalsAfter":[],"content":"by"},{"tailPos":15042,"headPos":14326,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd"],"goalsAfter":[],"content":"by\n      rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]\n      refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm\n      · simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]\n      · obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩\n      all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl"},{"tailPos":15042,"headPos":14249,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"content":"have step2 : (∑ i in s, lineCount L i.1) = ∑ i in s, pointCount P i.2 := by\n      rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]\n      refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm\n      · simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]\n      · obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩\n      all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl"},{"tailPos":15168,"headPos":15144,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i in s, lineCount L i.fst + ∑ i in sᶜ, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"content":"← s.sum_add_sum_compl,"},{"tailPos":15193,"headPos":15169,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i in s, lineCount L i.fst + ∑ i in sᶜ, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 :\n  ∑ i in s, lineCount L i.fst + ∑ i in sᶜ, lineCount L i.fst =\n    ∑ i in s, pointCount P i.snd + ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"content":"← s.sum_add_sum_compl,"},{"tailPos":15200,"headPos":15194,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 :\n  ∑ i in s, lineCount L i.fst + ∑ i in sᶜ, lineCount L i.fst =\n    ∑ i in s, pointCount P i.snd + ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 :\n  ∑ i in s, pointCount P i.snd + ∑ i in sᶜ, lineCount L i.fst =\n    ∑ i in s, pointCount P i.snd + ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"content":"step2,"},{"tailPos":15220,"headPos":15201,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 :\n  ∑ i in s, pointCount P i.snd + ∑ i in sᶜ, lineCount L i.fst =\n    ∑ i in s, pointCount P i.snd + ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"content":"add_left_cancel_iff"},{"tailPos":15221,"headPos":15220,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"content":"]"},{"tailPos":15230,"headPos":15139,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":[],"content":"rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1"},{"tailPos":15132,"headPos":15130,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":[],"content":"by"},{"tailPos":15230,"headPos":15130,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd"],"goalsAfter":[],"content":"by\n      rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1"},{"tailPos":15230,"headPos":15047,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 : ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"content":"have step3 : (∑ i in sᶜ, lineCount L i.1) = ∑ i in sᶜ, pointCount P i.2 := by\n      rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1"},{"tailPos":15261,"headPos":15239,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 : ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"content":"← Set.toFinset_compl"},{"tailPos":15262,"headPos":15261,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"content":"]"},{"tailPos":15271,"headPos":15235,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 : ∑ i in sᶜ, lineCount L i.fst = ∑ i in sᶜ, pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"content":"rw [← Set.toFinset_compl] at step3"},{"tailPos":15409,"headPos":15381,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\ni : P × L\nhi : i ∈ Set.toFinset ({i | i.fst ∈ i.snd}ᶜ)\n⊢ ¬i.fst ∈ i.snd"],"goalsAfter":[],"content":"exact Set.mem_toFinset.mp hi"},{"tailPos":15380,"headPos":15378,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\ni : P × L\nhi : i ∈ Set.toFinset ({i | i.fst ∈ i.snd}ᶜ)\n⊢ ¬i.fst ∈ i.snd"],"goalsAfter":[],"content":"by"},{"tailPos":15409,"headPos":15378,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\ni : P × L\nhi : i ∈ Set.toFinset ({i | i.fst ∈ i.snd}ᶜ)\n⊢ ¬i.fst ∈ i.snd"],"goalsAfter":[],"content":"by exact Set.mem_toFinset.mp hi"},{"tailPos":15475,"headPos":15276,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\nf : L → P\nhf1 : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\ns : Finset (P × L) := Set.toFinset {i | i.fst ∈ i.snd}\nstep1 : ∑ i : P × L, lineCount L i.fst = ∑ i : P × L, pointCount P i.snd\nstep2 : ∑ i in s, lineCount L i.fst = ∑ i in s, pointCount P i.snd\nstep3 :\n  ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), lineCount L i.fst =\n    ∑ i in Set.toFinset ({i | i.fst ∈ i.snd}ᶜ), pointCount P i.snd\n⊢ lineCount L p = pointCount P l"],"goalsAfter":[],"content":"exact\n      ((Finset.sum_eq_sum_iff_of_le fun i hi =>\n              HasLines.pointCount_le_lineCount (by exact Set.mem_toFinset.mp hi)).mp\n          step3.symm (p, l) (Set.mem_toFinset.mpr hpl)).symm"},{"tailPos":15475,"headPos":13845,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\n⊢ lineCount L p = pointCount P l"],"goalsAfter":[],"content":"obtain ⟨f, hf1, hf2⟩ := HasLines.exists_bijective_of_card_eq hPL\n    let s : Finset (P × L) := Set.toFinset { i | i.1 ∈ i.2 }\n    have step1 : (∑ i : P × L, lineCount L i.1) = ∑ i : P × L, pointCount P i.2 := by\n      rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]\n    have step2 : (∑ i in s, lineCount L i.1) = ∑ i in s, pointCount P i.2 := by\n      rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]\n      refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm\n      · simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]\n      · obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩\n      all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl\n    have step3 : (∑ i in sᶜ, lineCount L i.1) = ∑ i in sᶜ, pointCount P i.2 := by\n      rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1\n    rw [← Set.toFinset_compl] at step3\n    exact\n      ((Finset.sum_eq_sum_iff_of_le fun i hi =>\n              HasLines.pointCount_le_lineCount (by exact Set.mem_toFinset.mp hi)).mp\n          step3.symm (p, l) (Set.mem_toFinset.mpr hpl)).symm"},{"tailPos":15475,"headPos":13831,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\n⊢ lineCount L p = pointCount P l"],"goalsAfter":[],"content":"classical\n    obtain ⟨f, hf1, hf2⟩ := HasLines.exists_bijective_of_card_eq hPL\n    let s : Finset (P × L) := Set.toFinset { i | i.1 ∈ i.2 }\n    have step1 : (∑ i : P × L, lineCount L i.1) = ∑ i : P × L, pointCount P i.2 := by\n      rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]\n    have step2 : (∑ i in s, lineCount L i.1) = ∑ i in s, pointCount P i.2 := by\n      rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]\n      refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm\n      · simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]\n      · obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩\n      all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl\n    have step3 : (∑ i in sᶜ, lineCount L i.1) = ∑ i in sᶜ, pointCount P i.2 := by\n      rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1\n    rw [← Set.toFinset_compl] at step3\n    exact\n      ((Finset.sum_eq_sum_iff_of_le fun i hi =>\n              HasLines.pointCount_le_lineCount (by exact Set.mem_toFinset.mp hi)).mp\n          step3.symm (p, l) (Set.mem_toFinset.mpr hpl)).symm"},{"tailPos":13828,"headPos":13826,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\n⊢ lineCount L p = pointCount P l"],"goalsAfter":[],"content":"by"},{"tailPos":15475,"headPos":13826,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Fintype.card P = Fintype.card L\np : P\nl : L\nhpl : ¬p ∈ l\n⊢ lineCount L p = pointCount P l"],"goalsAfter":[],"content":"by\n  classical\n    obtain ⟨f, hf1, hf2⟩ := HasLines.exists_bijective_of_card_eq hPL\n    let s : Finset (P × L) := Set.toFinset { i | i.1 ∈ i.2 }\n    have step1 : (∑ i : P × L, lineCount L i.1) = ∑ i : P × L, pointCount P i.2 := by\n      rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]\n    have step2 : (∑ i in s, lineCount L i.1) = ∑ i in s, pointCount P i.2 := by\n      rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }]\n      refine'\n        (Finset.sum_bij (fun l _ => f l) (fun l _ => Finset.mem_univ (f l)) (fun l hl => _)\n            (fun _ _ _ _ h => hf1.1 h) fun p _ => _).symm\n      · simp_rw [Finset.sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n        change pointCount P l • pointCount P l = lineCount L (f l) • lineCount L (f l)\n        rw [hf2]\n      · obtain ⟨l, hl⟩ := hf1.2 p\n        exact ⟨l, Finset.mem_univ l, hl.symm⟩\n      all_goals simp_rw [Finset.mem_univ, true_and_iff, Set.mem_toFinset]; exact fun p => Iff.rfl\n    have step3 : (∑ i in sᶜ, lineCount L i.1) = ∑ i in sᶜ, pointCount P i.2 := by\n      rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1\n    rw [← Set.toFinset_compl] at step3\n    exact\n      ((Finset.sum_eq_sum_iff_of_le fun i hi =>\n              HasLines.pointCount_le_lineCount (by exact Set.mem_toFinset.mp hi)).mp\n          step3.symm (p, l) (Set.mem_toFinset.mpr hpl)).symm"},{"tailPos":16457,"headPos":16393,"goalsBefore":["P : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"obtain ⟨f, _, hf2⟩ := HasLines.exists_bijective_of_card_eq h"},{"tailPos":16514,"headPos":16464,"goalsBefore":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis : Nontrivial L\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"haveI : Nontrivial L := ⟨⟨l₁, l₂, hl⟩⟩"},{"tailPos":16609,"headPos":16521,"goalsBefore":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis : Nontrivial L\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"haveI := Fintype.one_lt_card_iff_nontrivial.mp ((congr_arg _ h).mpr Fintype.one_lt_card)"},{"tailPos":16846,"headPos":16616,"goalsBefore":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"have h₁ : ∀ p : P, 0 < lineCount L p := fun p =>\n        Exists.elim (exists_ne p) fun q hq =>\n          (congr_arg _ Nat.card_eq_fintype_card).mpr\n            (Fintype.card_pos_iff.mpr ⟨⟨mkLine hq, (mkLine_ax hq).2⟩⟩)"},{"tailPos":16945,"headPos":16853,"goalsBefore":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"have h₂ : ∀ l : L, 0 < pointCount P l := fun l => (congr_arg _ (hf2 l)).mpr (h₁ (f l))"},{"tailPos":17056,"headPos":16952,"goalsBefore":["case intro.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case intro.intro.intro.mk\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"obtain ⟨p, hl₁⟩ := Fintype.card_pos_iff.mp ((congr_arg _ Nat.card_eq_fintype_card).mp (h₂ l₁))"},{"tailPos":17090,"headPos":17063,"goalsBefore":["case intro.intro.intro.mk\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case pos\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : p ∈ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂","case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"by_cases hl₂ : p ∈ l₂"},{"tailPos":17124,"headPos":17097,"goalsBefore":["case pos\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : p ∈ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂","case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"exact ⟨p, hl₁, hl₂⟩"},{"tailPos":17348,"headPos":17131,"goalsBefore":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"have key' : Fintype.card { q : P // q ∈ l₂ } = Fintype.card { l : L // p ∈ l } :=\n        ((HasLines.lineCount_eq_pointCount h hl₂).trans Nat.card_eq_fintype_card).symm.trans\n          Nat.card_eq_fintype_card"},{"tailPos":17458,"headPos":17355,"goalsBefore":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝ : Nontrivial L\nthis : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"have : ∀ q : { q // q ∈ l₂ }, p ≠ q := fun q hq => hl₂ ((congr_arg (· ∈ l₂) hq).mpr q.2)"},{"tailPos":17587,"headPos":17465,"goalsBefore":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf : L → P\nleft✝ : Function.Bijective f\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"let f : { q : P // q ∈ l₂ } → { l : L // p ∈ l } := fun q =>\n        ⟨mkLine (this q), (mkLine_ax (this q)).1⟩"},{"tailPos":17913,"headPos":17594,"goalsBefore":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\nhf : Function.Injective f\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"have hf : Function.Injective f := fun q₁ q₂ hq =>\n        Subtype.ext\n          ((eq_or_eq q₁.2 q₂.2 (mkLine_ax (this q₁)).2\n                ((congr_arg _ (Subtype.ext_iff.mp hq)).mpr (mkLine_ax (this q₂)).2)).resolve_right\n            fun h => (congr_arg (¬p ∈ ·) h).mp hl₂ (mkLine_ax (this q₁)).1)"},{"tailPos":18000,"headPos":17920,"goalsBefore":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey' : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\nhf : Function.Injective f\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey'✝ : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\nhf : Function.Injective f\nkey' : Function.Surjective f\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"have key' := ((Fintype.bijective_iff_injective_and_card f).mpr ⟨hf, key'⟩).2"},{"tailPos":18051,"headPos":18007,"goalsBefore":["case neg\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey'✝ : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\nhf : Function.Injective f\nkey' : Function.Surjective f\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":["case neg.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey'✝ : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\nhf : Function.Injective f\nkey' : Function.Surjective f\nq : { q // q ∈ l₂ }\nhq : f q = { val := l₁, property := hl₁ }\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"content":"obtain ⟨q, hq⟩ := key' ⟨l₁, hl₁⟩"},{"tailPos":18141,"headPos":18058,"goalsBefore":["case neg.intro\nP : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\nf✝ : L → P\nleft✝ : Function.Bijective f✝\nhf2 : ∀ (l : L), pointCount P l = lineCount L (f✝ l)\nthis✝¹ : Nontrivial L\nthis✝ : Nontrivial P\nh₁ : ∀ (p : P), 0 < lineCount L p\nh₂ : ∀ (l : L), 0 < pointCount P l\np : P\nhl₁ : p ∈ l₁\nhl₂ : ¬p ∈ l₂\nkey'✝ : Fintype.card { q // q ∈ l₂ } = Fintype.card { l // p ∈ l }\nthis : ∀ (q : { q // q ∈ l₂ }), p ≠ ↑q\nf : { q // q ∈ l₂ } → { l // p ∈ l } :=\n  fun q => { val := mkLine (_ : p ≠ ↑q), property := (_ : p ∈ mkLine (_ : p ≠ ↑q)) }\nhf : Function.Injective f\nkey' : Function.Surjective f\nq : { q // q ∈ l₂ }\nhq : f q = { val := l₁, property := hl₁ }\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":[],"content":"exact ⟨q, (congr_arg _ (Subtype.ext_iff.mp hq)).mp (mkLine_ax (this q)).2, q.2⟩"},{"tailPos":18141,"headPos":16393,"goalsBefore":["P : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":[],"content":"obtain ⟨f, _, hf2⟩ := HasLines.exists_bijective_of_card_eq h\n      haveI : Nontrivial L := ⟨⟨l₁, l₂, hl⟩⟩\n      haveI := Fintype.one_lt_card_iff_nontrivial.mp ((congr_arg _ h).mpr Fintype.one_lt_card)\n      have h₁ : ∀ p : P, 0 < lineCount L p := fun p =>\n        Exists.elim (exists_ne p) fun q hq =>\n          (congr_arg _ Nat.card_eq_fintype_card).mpr\n            (Fintype.card_pos_iff.mpr ⟨⟨mkLine hq, (mkLine_ax hq).2⟩⟩)\n      have h₂ : ∀ l : L, 0 < pointCount P l := fun l => (congr_arg _ (hf2 l)).mpr (h₁ (f l))\n      obtain ⟨p, hl₁⟩ := Fintype.card_pos_iff.mp ((congr_arg _ Nat.card_eq_fintype_card).mp (h₂ l₁))\n      by_cases hl₂ : p ∈ l₂\n      exact ⟨p, hl₁, hl₂⟩\n      have key' : Fintype.card { q : P // q ∈ l₂ } = Fintype.card { l : L // p ∈ l } :=\n        ((HasLines.lineCount_eq_pointCount h hl₂).trans Nat.card_eq_fintype_card).symm.trans\n          Nat.card_eq_fintype_card\n      have : ∀ q : { q // q ∈ l₂ }, p ≠ q := fun q hq => hl₂ ((congr_arg (· ∈ l₂) hq).mpr q.2)\n      let f : { q : P // q ∈ l₂ } → { l : L // p ∈ l } := fun q =>\n        ⟨mkLine (this q), (mkLine_ax (this q)).1⟩\n      have hf : Function.Injective f := fun q₁ q₂ hq =>\n        Subtype.ext\n          ((eq_or_eq q₁.2 q₂.2 (mkLine_ax (this q₁)).2\n                ((congr_arg _ (Subtype.ext_iff.mp hq)).mpr (mkLine_ax (this q₂)).2)).resolve_right\n            fun h => (congr_arg (¬p ∈ ·) h).mp hl₂ (mkLine_ax (this q₁)).1)\n      have key' := ((Fintype.bijective_iff_injective_and_card f).mpr ⟨hf, key'⟩).2\n      obtain ⟨q, hq⟩ := key' ⟨l₁, hl₁⟩\n      exact ⟨q, (congr_arg _ (Subtype.ext_iff.mp hq)).mp (mkLine_ax (this q)).2, q.2⟩"},{"tailPos":18141,"headPos":16377,"goalsBefore":["P : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":[],"content":"classical\n      obtain ⟨f, _, hf2⟩ := HasLines.exists_bijective_of_card_eq h\n      haveI : Nontrivial L := ⟨⟨l₁, l₂, hl⟩⟩\n      haveI := Fintype.one_lt_card_iff_nontrivial.mp ((congr_arg _ h).mpr Fintype.one_lt_card)\n      have h₁ : ∀ p : P, 0 < lineCount L p := fun p =>\n        Exists.elim (exists_ne p) fun q hq =>\n          (congr_arg _ Nat.card_eq_fintype_card).mpr\n            (Fintype.card_pos_iff.mpr ⟨⟨mkLine hq, (mkLine_ax hq).2⟩⟩)\n      have h₂ : ∀ l : L, 0 < pointCount P l := fun l => (congr_arg _ (hf2 l)).mpr (h₁ (f l))\n      obtain ⟨p, hl₁⟩ := Fintype.card_pos_iff.mp ((congr_arg _ Nat.card_eq_fintype_card).mp (h₂ l₁))\n      by_cases hl₂ : p ∈ l₂\n      exact ⟨p, hl₁, hl₂⟩\n      have key' : Fintype.card { q : P // q ∈ l₂ } = Fintype.card { l : L // p ∈ l } :=\n        ((HasLines.lineCount_eq_pointCount h hl₂).trans Nat.card_eq_fintype_card).symm.trans\n          Nat.card_eq_fintype_card\n      have : ∀ q : { q // q ∈ l₂ }, p ≠ q := fun q hq => hl₂ ((congr_arg (· ∈ l₂) hq).mpr q.2)\n      let f : { q : P // q ∈ l₂ } → { l : L // p ∈ l } := fun q =>\n        ⟨mkLine (this q), (mkLine_ax (this q)).1⟩\n      have hf : Function.Injective f := fun q₁ q₂ hq =>\n        Subtype.ext\n          ((eq_or_eq q₁.2 q₂.2 (mkLine_ax (this q₁)).2\n                ((congr_arg _ (Subtype.ext_iff.mp hq)).mpr (mkLine_ax (this q₂)).2)).resolve_right\n            fun h => (congr_arg (¬p ∈ ·) h).mp hl₂ (mkLine_ax (this q₁)).1)\n      have key' := ((Fintype.bijective_iff_injective_and_card f).mpr ⟨hf, key'⟩).2\n      obtain ⟨q, hq⟩ := key' ⟨l₁, hl₁⟩\n      exact ⟨q, (congr_arg _ (Subtype.ext_iff.mp hq)).mp (mkLine_ax (this q)).2, q.2⟩"},{"tailPos":16372,"headPos":16370,"goalsBefore":["P : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":[],"content":"by"},{"tailPos":18141,"headPos":16370,"goalsBefore":["P : Type ?u.39382\nL : Type ?u.39385\ninst✝³ : Membership P L\ninst✝² : HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Fintype.card P = Fintype.card L\nl₁ l₂ : L\nhl : l₁ ≠ l₂\n⊢ ∃ p, p ∈ l₁ ∧ p ∈ l₂"],"goalsAfter":[],"content":"by\n    classical\n      obtain ⟨f, _, hf2⟩ := HasLines.exists_bijective_of_card_eq h\n      haveI : Nontrivial L := ⟨⟨l₁, l₂, hl⟩⟩\n      haveI := Fintype.one_lt_card_iff_nontrivial.mp ((congr_arg _ h).mpr Fintype.one_lt_card)\n      have h₁ : ∀ p : P, 0 < lineCount L p := fun p =>\n        Exists.elim (exists_ne p) fun q hq =>\n          (congr_arg _ Nat.card_eq_fintype_card).mpr\n            (Fintype.card_pos_iff.mpr ⟨⟨mkLine hq, (mkLine_ax hq).2⟩⟩)\n      have h₂ : ∀ l : L, 0 < pointCount P l := fun l => (congr_arg _ (hf2 l)).mpr (h₁ (f l))\n      obtain ⟨p, hl₁⟩ := Fintype.card_pos_iff.mp ((congr_arg _ Nat.card_eq_fintype_card).mp (h₂ l₁))\n      by_cases hl₂ : p ∈ l₂\n      exact ⟨p, hl₁, hl₂⟩\n      have key' : Fintype.card { q : P // q ∈ l₂ } = Fintype.card { l : L // p ∈ l } :=\n        ((HasLines.lineCount_eq_pointCount h hl₂).trans Nat.card_eq_fintype_card).symm.trans\n          Nat.card_eq_fintype_card\n      have : ∀ q : { q // q ∈ l₂ }, p ≠ q := fun q hq => hl₂ ((congr_arg (· ∈ l₂) hq).mpr q.2)\n      let f : { q : P // q ∈ l₂ } → { l : L // p ∈ l } := fun q =>\n        ⟨mkLine (this q), (mkLine_ax (this q)).1⟩\n      have hf : Function.Injective f := fun q₁ q₂ hq =>\n        Subtype.ext\n          ((eq_or_eq q₁.2 q₂.2 (mkLine_ax (this q₁)).2\n                ((congr_arg _ (Subtype.ext_iff.mp hq)).mpr (mkLine_ax (this q₂)).2)).resolve_right\n            fun h => (congr_arg (¬p ∈ ·) h).mp hl₂ (mkLine_ax (this q₁)).1)\n      have key' := ((Fintype.bijective_iff_injective_and_card f).mpr ⟨hf, key'⟩).2\n      obtain ⟨q, hq⟩ := key' ⟨l₁, hl₁⟩\n      exact ⟨q, (congr_arg _ (Subtype.ext_iff.mp hq)).mp (mkLine_ax (this q)).2, q.2⟩"},{"tailPos":20814,"headPos":20790,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝ : Fintype P\n⊢ lineCount L p = lineCount L q"],"content":"cases nonempty_fintype P"},{"tailPos":20841,"headPos":20817,"goalsBefore":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝ : Fintype P\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\n⊢ lineCount L p = lineCount L q"],"content":"cases nonempty_fintype L"},{"tailPos":20989,"headPos":20844,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\n⊢ lineCount L p = lineCount L q"],"content":"obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, h₁₂, h₁₃, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _"},{"tailPos":21031,"headPos":20992,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\n⊢ lineCount L p = lineCount L q"],"content":"have h := card_points_eq_card_lines P L"},{"tailPos":21059,"headPos":21034,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\n⊢ lineCount L p = lineCount L q"],"content":"let n := lineCount L p₂"},{"tailPos":21102,"headPos":21062,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\n⊢ lineCount L p = lineCount L q"],"content":"have hp₂ : lineCount L p₂ = n := rfl"},{"tailPos":21204,"headPos":21105,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\n⊢ lineCount L p = lineCount L q"],"content":"have hl₁ : pointCount P l₁ = n := (HasLines.lineCount_eq_pointCount h h₂₁).symm.trans hp₂"},{"tailPos":21300,"headPos":21207,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\n⊢ lineCount L p = lineCount L q"],"content":"have hp₃ : lineCount L p₃ = n := (HasLines.lineCount_eq_pointCount h h₃₁).trans hl₁"},{"tailPos":21402,"headPos":21303,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\n⊢ lineCount L p = lineCount L q"],"content":"have hl₃ : pointCount P l₃ = n := (HasLines.lineCount_eq_pointCount h h₃₃).symm.trans hp₃"},{"tailPos":21498,"headPos":21405,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\n⊢ lineCount L p = lineCount L q"],"content":"have hp₁ : lineCount L p₁ = n := (HasLines.lineCount_eq_pointCount h h₁₃).trans hl₃"},{"tailPos":21600,"headPos":21501,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\n⊢ lineCount L p = lineCount L q"],"content":"have hl₂ : pointCount P l₂ = n := (HasLines.lineCount_eq_pointCount h h₁₂).symm.trans hp₁"},{"tailPos":21678,"headPos":21644,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\nthis : ∀ (p : P), lineCount L p = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":[],"content":"exact (this p).trans (this q).symm"},{"tailPos":21678,"headPos":21603,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\n⊢ lineCount L p = lineCount L q"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\n⊢ ∀ (p : P), lineCount L p = n"],"content":"suffices ∀ p : P, lineCount L p = n by exact (this p).trans (this q).symm"},{"tailPos":21795,"headPos":21681,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\n⊢ ∀ (p : P), lineCount L p = n"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\n⊢ lineCount L p = n"],"content":"refine' fun p =>\n    or_not.elim (fun h₂ => _) fun h₂ => (HasLines.lineCount_eq_pointCount h h₂).trans hl₂"},{"tailPos":21899,"headPos":21798,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\n⊢ lineCount L p = n"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\nh₃ : p ∈ l₃\n⊢ lineCount L p = n"],"content":"refine' or_not.elim (fun h₃ => _) fun h₃ => (HasLines.lineCount_eq_pointCount h h₃).trans hl₃"},{"tailPos":22028,"headPos":21906,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\nh₃ : p ∈ l₃\n⊢ lineCount L p = n"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\nh₃ : p ∈ l₃\n⊢ lineCount L p₂ = n"],"content":"(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h =>\n      h₃₃ ((congr_arg (Membership.mem p₃) h).mp h₃₂)"},{"tailPos":22029,"headPos":22028,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\nh₃ : p ∈ l₃\n⊢ lineCount L p₂ = n"],"goalsAfter":[],"content":"]"},{"tailPos":22029,"headPos":21902,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np✝ q : P\nval✝¹ : Fintype P\nval✝ : Fintype L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₁₂ : ¬p₁ ∈ l₂\nh₁₃ : ¬p₁ ∈ l₃\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nh : Fintype.card P = Fintype.card L\nn : ℕ := lineCount L p₂\nhp₂ : lineCount L p₂ = n\nhl₁ : pointCount P l₁ = n\nhp₃ : lineCount L p₃ = n\nhl₃ : pointCount P l₃ = n\nhp₁ : lineCount L p₁ = n\nhl₂ : pointCount P l₂ = n\np : P\nh₂ : p ∈ l₂\nh₃ : p ∈ l₃\n⊢ lineCount L p = n"],"goalsAfter":[],"content":"rw [(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h =>\n      h₃₃ ((congr_arg (Membership.mem p₃) h).mp h₃₂)]"},{"tailPos":22029,"headPos":20790,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\n⊢ lineCount L p = lineCount L q"],"goalsAfter":[],"content":"cases nonempty_fintype P\n  cases nonempty_fintype L\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, h₁₂, h₁₃, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  have h := card_points_eq_card_lines P L\n  let n := lineCount L p₂\n  have hp₂ : lineCount L p₂ = n := rfl\n  have hl₁ : pointCount P l₁ = n := (HasLines.lineCount_eq_pointCount h h₂₁).symm.trans hp₂\n  have hp₃ : lineCount L p₃ = n := (HasLines.lineCount_eq_pointCount h h₃₁).trans hl₁\n  have hl₃ : pointCount P l₃ = n := (HasLines.lineCount_eq_pointCount h h₃₃).symm.trans hp₃\n  have hp₁ : lineCount L p₁ = n := (HasLines.lineCount_eq_pointCount h h₁₃).trans hl₃\n  have hl₂ : pointCount P l₂ = n := (HasLines.lineCount_eq_pointCount h h₁₂).symm.trans hp₁\n  suffices ∀ p : P, lineCount L p = n by exact (this p).trans (this q).symm\n  refine' fun p =>\n    or_not.elim (fun h₂ => _) fun h₂ => (HasLines.lineCount_eq_pointCount h h₂).trans hl₂\n  refine' or_not.elim (fun h₃ => _) fun h₃ => (HasLines.lineCount_eq_pointCount h h₃).trans hl₃\n  rw [(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h =>\n      h₃₃ ((congr_arg (Membership.mem p₃) h).mp h₃₂)]"},{"tailPos":20787,"headPos":20785,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\n⊢ lineCount L p = lineCount L q"],"goalsAfter":[],"content":"by"},{"tailPos":22029,"headPos":20785,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\n⊢ lineCount L p = lineCount L q"],"goalsAfter":[],"content":"by\n  cases nonempty_fintype P\n  cases nonempty_fintype L\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, h₁₂, h₁₃, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  have h := card_points_eq_card_lines P L\n  let n := lineCount L p₂\n  have hp₂ : lineCount L p₂ = n := rfl\n  have hl₁ : pointCount P l₁ = n := (HasLines.lineCount_eq_pointCount h h₂₁).symm.trans hp₂\n  have hp₃ : lineCount L p₃ = n := (HasLines.lineCount_eq_pointCount h h₃₁).trans hl₁\n  have hl₃ : pointCount P l₃ = n := (HasLines.lineCount_eq_pointCount h h₃₃).symm.trans hp₃\n  have hp₁ : lineCount L p₁ = n := (HasLines.lineCount_eq_pointCount h h₁₃).trans hl₃\n  have hl₂ : pointCount P l₂ = n := (HasLines.lineCount_eq_pointCount h h₁₂).symm.trans hp₁\n  suffices ∀ p : P, lineCount L p = n by exact (this p).trans (this q).symm\n  refine' fun p =>\n    or_not.elim (fun h₂ => _) fun h₂ => (HasLines.lineCount_eq_pointCount h h₂).trans hl₂\n  refine' or_not.elim (fun h₃ => _) fun h₃ => (HasLines.lineCount_eq_pointCount h h₃).trans hl₃\n  rw [(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h =>\n      h₃₃ ((congr_arg (Membership.mem p₃) h).mp h₃₂)]"},{"tailPos":22313,"headPos":22276,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl m : L\n⊢ pointCount P l = pointCount P m"],"goalsAfter":[],"content":"apply lineCount_eq_lineCount (Dual P)"},{"tailPos":22273,"headPos":22271,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl m : L\n⊢ pointCount P l = pointCount P m"],"goalsAfter":[],"content":"by"},{"tailPos":22313,"headPos":22271,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl m : L\n⊢ pointCount P l = pointCount P m"],"goalsAfter":[],"content":"by\n  apply lineCount_eq_lineCount (Dual P)"},{"tailPos":22746,"headPos":22722,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\n⊢ lineCount L q = pointCount P l"],"goalsAfter":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\nval✝ : Fintype P\n⊢ lineCount L q = pointCount P l"],"content":"cases nonempty_fintype P"},{"tailPos":22777,"headPos":22753,"goalsBefore":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\nval✝ : Fintype P\n⊢ lineCount L q = pointCount P l"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\nval✝¹ : Fintype P\nval✝ : Fintype L\n⊢ lineCount L q = pointCount P l"],"content":"cases nonempty_fintype L"},{"tailPos":22857,"headPos":22784,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\nval✝¹ : Fintype P\nval✝ : Fintype L\n⊢ lineCount L q = pointCount P l"],"goalsAfter":[],"content":"exact HasLines.lineCount_eq_pointCount (card_points_eq_card_lines P L) hq"},{"tailPos":22857,"headPos":22722,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\n⊢ lineCount L q = pointCount P l"],"goalsAfter":[],"content":"cases nonempty_fintype P\n      cases nonempty_fintype L\n      exact HasLines.lineCount_eq_pointCount (card_points_eq_card_lines P L) hq"},{"tailPos":22715,"headPos":22713,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\n⊢ lineCount L q = pointCount P l"],"goalsAfter":[],"content":"by"},{"tailPos":22857,"headPos":22713,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\nq : P\nhq : ¬q ∈ l\n⊢ lineCount L q = pointCount P l"],"goalsAfter":[],"content":"by\n      cases nonempty_fintype P\n      cases nonempty_fintype L\n      exact HasLines.lineCount_eq_pointCount (card_points_eq_card_lines P L) hq"},{"tailPos":23502,"headPos":23411,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ lineCount L p = order P L + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\n⊢ lineCount L p = order P L + 1"],"content":"obtain ⟨q, -, -, l, -, -, -, -, h, -⟩ := Classical.choose_spec (@exists_config P L _ _)"},{"tailPos":23550,"headPos":23507,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\n⊢ lineCount L p = order P L + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L p = order P L + 1"],"content":"cases nonempty_fintype { l : L // q ∈ l }"},{"tailPos":23565,"headPos":23559,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L p = order P L + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L p =\n    lineCount L\n          (Classical.choose\n            (_ :\n              ∃ p₁ p₂ p₃ l₁ l₂ l₃,\n                ¬p₁ ∈ l₂ ∧ ¬p₁ ∈ l₃ ∧ ¬p₂ ∈ l₁ ∧ p₂ ∈ l₂ ∧ p₂ ∈ l₃ ∧ ¬p₃ ∈ l₁ ∧ p₃ ∈ l₂ ∧ ¬p₃ ∈ l₃)) -\n        1 +\n      1"],"content":"order,"},{"tailPos":23595,"headPos":23566,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L p =\n    lineCount L\n          (Classical.choose\n            (_ :\n              ∃ p₁ p₂ p₃ l₁ l₂ l₃,\n                ¬p₁ ∈ l₂ ∧ ¬p₁ ∈ l₃ ∧ ¬p₂ ∈ l₁ ∧ p₂ ∈ l₂ ∧ p₂ ∈ l₃ ∧ ¬p₃ ∈ l₁ ∧ p₃ ∈ l₂ ∧ ¬p₃ ∈ l₃)) -\n        1 +\n      1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L q =\n    lineCount L\n          (Classical.choose\n            (_ :\n              ∃ p₁ p₂ p₃ l₁ l₂ l₃,\n                ¬p₁ ∈ l₂ ∧ ¬p₁ ∈ l₃ ∧ ¬p₂ ∈ l₁ ∧ p₂ ∈ l₂ ∧ p₂ ∈ l₃ ∧ ¬p₃ ∈ l₁ ∧ p₃ ∈ l₂ ∧ ¬p₃ ∈ l₃)) -\n        1 +\n      1"],"content":"lineCount_eq_lineCount L p q,"},{"tailPos":23644,"headPos":23596,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L q =\n    lineCount L\n          (Classical.choose\n            (_ :\n              ∃ p₁ p₂ p₃ l₁ l₂ l₃,\n                ¬p₁ ∈ l₂ ∧ ¬p₁ ∈ l₃ ∧ ¬p₂ ∈ l₁ ∧ p₂ ∈ l₂ ∧ p₂ ∈ l₃ ∧ ¬p₃ ∈ l₁ ∧ p₃ ∈ l₂ ∧ ¬p₃ ∈ l₃)) -\n        1 +\n      1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L q = lineCount L q - 1 + 1"],"content":"lineCount_eq_lineCount L (Classical.choose _) q,"},{"tailPos":23661,"headPos":23651,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L q = lineCount L q - 1 + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ Nat.card { l // q ∈ l } = Nat.card { l // q ∈ l } - 1 + 1"],"content":"lineCount,"},{"tailPos":23687,"headPos":23662,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ Nat.card { l // q ∈ l } = Nat.card { l // q ∈ l } - 1 + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ Fintype.card { l // q ∈ l } = Fintype.card { l // q ∈ l } - 1 + 1"],"content":"Nat.card_eq_fintype_card,"},{"tailPos":23706,"headPos":23688,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ Fintype.card { l // q ∈ l } = Fintype.card { l // q ∈ l } - 1 + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ Fintype.card { l // q ∈ l } = Fintype.card { l // q ∈ l }","case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ 1 ≤ Fintype.card { l // q ∈ l }"],"content":"Nat.sub_add_cancel"},{"tailPos":23707,"headPos":23706,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ Fintype.card { l // q ∈ l } = Fintype.card { l // q ∈ l }","case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ 1 ≤ Fintype.card { l // q ∈ l }"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ 1 ≤ Fintype.card { l // q ∈ l }"],"content":"]"},{"tailPos":23707,"headPos":23555,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ lineCount L p = order P L + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ 1 ≤ Fintype.card { l // q ∈ l }"],"content":"rw [order, lineCount_eq_lineCount L p q, lineCount_eq_lineCount L (Classical.choose _) q,\n      lineCount, Nat.card_eq_fintype_card, Nat.sub_add_cancel]"},{"tailPos":23759,"headPos":23712,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\nl : L\nh : q ∈ l\nval✝ : Fintype { l // q ∈ l }\n⊢ 1 ≤ Fintype.card { l // q ∈ l }"],"goalsAfter":[],"content":"exact Fintype.card_pos_iff.mpr ⟨⟨l, h⟩⟩"},{"tailPos":23759,"headPos":23411,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ lineCount L p = order P L + 1"],"goalsAfter":[],"content":"obtain ⟨q, -, -, l, -, -, -, -, h, -⟩ := Classical.choose_spec (@exists_config P L _ _)\n    cases nonempty_fintype { l : L // q ∈ l }\n    rw [order, lineCount_eq_lineCount L p q, lineCount_eq_lineCount L (Classical.choose _) q,\n      lineCount, Nat.card_eq_fintype_card, Nat.sub_add_cancel]\n    exact Fintype.card_pos_iff.mpr ⟨⟨l, h⟩⟩"},{"tailPos":23759,"headPos":23397,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ lineCount L p = order P L + 1"],"goalsAfter":[],"content":"classical\n    obtain ⟨q, -, -, l, -, -, -, -, h, -⟩ := Classical.choose_spec (@exists_config P L _ _)\n    cases nonempty_fintype { l : L // q ∈ l }\n    rw [order, lineCount_eq_lineCount L p q, lineCount_eq_lineCount L (Classical.choose _) q,\n      lineCount, Nat.card_eq_fintype_card, Nat.sub_add_cancel]\n    exact Fintype.card_pos_iff.mpr ⟨⟨l, h⟩⟩"},{"tailPos":23394,"headPos":23392,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ lineCount L p = order P L + 1"],"goalsAfter":[],"content":"by"},{"tailPos":23759,"headPos":23392,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ lineCount L p = order P L + 1"],"goalsAfter":[],"content":"by\n  classical\n    obtain ⟨q, -, -, l, -, -, -, -, h, -⟩ := Classical.choose_spec (@exists_config P L _ _)\n    cases nonempty_fintype { l : L // q ∈ l }\n    rw [order, lineCount_eq_lineCount L p q, lineCount_eq_lineCount L (Classical.choose _) q,\n      lineCount, Nat.card_eq_fintype_card, Nat.sub_add_cancel]\n    exact Fintype.card_pos_iff.mpr ⟨⟨l, h⟩⟩"},{"tailPos":24354,"headPos":24221,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\n⊢ 1 < order P L"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\n⊢ 1 < order P L"],"content":"obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, -, -, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _"},{"tailPos":24403,"headPos":24357,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\n⊢ 1 < order P L"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 < order P L"],"content":"cases nonempty_fintype { p : P // p ∈ l₂ }"},{"tailPos":24437,"headPos":24410,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 < order P L"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < order P L + 1"],"content":"← add_lt_add_iff_right 1,"},{"tailPos":24463,"headPos":24438,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < order P L + 1"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < pointCount P l₂"],"content":"← pointCount_eq _ l₂,"},{"tailPos":24475,"headPos":24464,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < pointCount P l₂"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < Nat.card { p // p ∈ l₂ }"],"content":"pointCount,"},{"tailPos":24501,"headPos":24476,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < Nat.card { p // p ∈ l₂ }"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < Fintype.card { p // p ∈ l₂ }"],"content":"Nat.card_eq_fintype_card,"},{"tailPos":24529,"headPos":24506,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 + 1 < Fintype.card { p // p ∈ l₂ }"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"content":"Fintype.two_lt_card_iff"},{"tailPos":24530,"headPos":24529,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"content":"]"},{"tailPos":24530,"headPos":24406,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ 1 < order P L"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"content":"rw [← add_lt_add_iff_right 1, ← pointCount_eq _ l₂, pointCount, Nat.card_eq_fintype_card,\n    Fintype.two_lt_card_iff]"},{"tailPos":24542,"headPos":24533,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"content":"simp_rw ["},{"tailPos":24545,"headPos":24542,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, ¬a = b ∧ ¬a = c ∧ ¬b = c"],"content":"Ne,"},{"tailPos":24561,"headPos":24546,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, ¬a = b ∧ ¬a = c ∧ ¬b = c"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, ¬↑a = ↑b ∧ ¬↑a = ↑c ∧ ¬↑b = ↑c"],"content":"simp only [Subtype.ext_iff]"},{"tailPos":24562,"headPos":24533,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, a ≠ b ∧ a ≠ c ∧ b ≠ c"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, ¬↑a = ↑b ∧ ¬↑a = ↑c ∧ ¬↑b = ↑c"],"content":"simp_rw [Ne, Subtype.ext_iff]"},{"tailPos":24632,"headPos":24565,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\n⊢ ∃ a b c, ¬↑a = ↑b ∧ ¬↑a = ↑c ∧ ¬↑b = ↑c"],"goalsAfter":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\nh : mkPoint (_ : l₁ = l₂ → False) ∈ l₁ ∧ mkPoint (_ : l₁ = l₂ → False) ∈ l₂\n⊢ ∃ a b c, ¬↑a = ↑b ∧ ¬↑a = ↑c ∧ ¬↑b = ↑c"],"content":"have h := mkPoint_ax fun h => h₂₁ ((congr_arg _ h).mpr h₂₂)"},{"tailPos":24825,"headPos":24635,"goalsBefore":["case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np₁ p₂ p₃ : P\nl₁ l₂ l₃ : L\nh₂₁ : ¬p₂ ∈ l₁\nh₂₂ : p₂ ∈ l₂\nh₂₃ : p₂ ∈ l₃\nh₃₁ : ¬p₃ ∈ l₁\nh₃₂ : p₃ ∈ l₂\nh₃₃ : ¬p₃ ∈ l₃\nval✝ : Fintype { p // p ∈ l₂ }\nh : mkPoint (_ : l₁ = l₂ → False) ∈ l₁ ∧ mkPoint (_ : l₁ = l₂ → False) ∈ l₂\n⊢ ∃ a b c, ¬↑a = ↑b ∧ ¬↑a = ↑c ∧ ¬↑b = ↑c"],"goalsAfter":[],"content":"exact\n    ⟨⟨mkPoint _, h.2⟩, ⟨p₂, h₂₂⟩, ⟨p₃, h₃₂⟩, ne_of_mem_of_not_mem h.1 h₂₁,\n      ne_of_mem_of_not_mem h.1 h₃₁, ne_of_mem_of_not_mem h₂₃ h₃₃⟩"},{"tailPos":24825,"headPos":24221,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\n⊢ 1 < order P L"],"goalsAfter":[],"content":"obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, -, -, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  cases nonempty_fintype { p : P // p ∈ l₂ }\n  rw [← add_lt_add_iff_right 1, ← pointCount_eq _ l₂, pointCount, Nat.card_eq_fintype_card,\n    Fintype.two_lt_card_iff]\n  simp_rw [Ne, Subtype.ext_iff]\n  have h := mkPoint_ax fun h => h₂₁ ((congr_arg _ h).mpr h₂₂)\n  exact\n    ⟨⟨mkPoint _, h.2⟩, ⟨p₂, h₂₂⟩, ⟨p₃, h₃₂⟩, ne_of_mem_of_not_mem h.1 h₂₁,\n      ne_of_mem_of_not_mem h.1 h₃₁, ne_of_mem_of_not_mem h₂₃ h₃₃⟩"},{"tailPos":24218,"headPos":24216,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\n⊢ 1 < order P L"],"goalsAfter":[],"content":"by"},{"tailPos":24825,"headPos":24216,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\n⊢ 1 < order P L"],"goalsAfter":[],"content":"by\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, -, -, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  cases nonempty_fintype { p : P // p ∈ l₂ }\n  rw [← add_lt_add_iff_right 1, ← pointCount_eq _ l₂, pointCount, Nat.card_eq_fintype_card,\n    Fintype.two_lt_card_iff]\n  simp_rw [Ne, Subtype.ext_iff]\n  have h := mkPoint_ax fun h => h₂₁ ((congr_arg _ h).mpr h₂₂)\n  exact\n    ⟨⟨mkPoint _, h.2⟩, ⟨p₂, h₂₂⟩, ⟨p₃, h₃₂⟩, ne_of_mem_of_not_mem h.1 h₂₁,\n      ne_of_mem_of_not_mem h.1 h₃₁, ne_of_mem_of_not_mem h₂₃ h₃₃⟩"},{"tailPos":25092,"headPos":25018,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ 2 < lineCount L p"],"goalsAfter":[],"content":"simpa only [lineCount_eq L p, Nat.succ_lt_succ_iff] using one_lt_order P L"},{"tailPos":25015,"headPos":25013,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ 2 < lineCount L p"],"goalsAfter":[],"content":"by"},{"tailPos":25092,"headPos":25013,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ 2 < lineCount L p"],"goalsAfter":[],"content":"by\n  simpa only [lineCount_eq L p, Nat.succ_lt_succ_iff] using one_lt_order P L"},{"tailPos":25375,"headPos":25300,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl : L\n⊢ 2 < pointCount P l"],"goalsAfter":[],"content":"simpa only [pointCount_eq P l, Nat.succ_lt_succ_iff] using one_lt_order P L"},{"tailPos":25297,"headPos":25295,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl : L\n⊢ 2 < pointCount P l"],"goalsAfter":[],"content":"by"},{"tailPos":25375,"headPos":25295,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl : L\n⊢ 2 < pointCount P l"],"goalsAfter":[],"content":"by\n  simpa only [pointCount_eq P l, Nat.succ_lt_succ_iff] using one_lt_order P L"},{"tailPos":25687,"headPos":25663,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"content":"cases nonempty_fintype L"},{"tailPos":25733,"headPos":25690,"goalsBefore":["case intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"content":"obtain ⟨p, -⟩ := @exists_config P L _ _"},{"tailPos":26228,"headPos":25736,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"content":"let ϕ : { q // q ≠ p } ≃ Σl : { l : L // p ∈ l }, { q // q ∈ l.1 ∧ q ≠ p } :=\n    { toFun := fun q => ⟨⟨mkLine q.2, (mkLine_ax q.2).2⟩, q, (mkLine_ax q.2).1, q.2⟩\n      invFun := fun lq => ⟨lq.2, lq.2.2.2⟩\n      left_inv := fun q => Subtype.ext rfl\n      right_inv := fun lq =>\n        Sigma.subtype_ext\n          (Subtype.ext\n            ((eq_or_eq (mkLine_ax lq.2.2.2).1 (mkLine_ax lq.2.2.2).2 lq.2.2.1 lq.1.2).resolve_left\n              lq.2.2.2))\n          rfl }"},{"tailPos":26408,"headPos":26318,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card { q // q ≠ p } + 1 = Fintype.card P"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card { q // q ≠ p } = Fintype.card P - Nat.succ 0"],"content":"apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp"},{"tailPos":26500,"headPos":26415,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card { q // q ≠ p } = Fintype.card P - Nat.succ 0"],"goalsAfter":[],"content":"convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))"},{"tailPos":26500,"headPos":26318,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card { q // q ≠ p } + 1 = Fintype.card P"],"goalsAfter":[],"content":"apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))"},{"tailPos":26311,"headPos":26309,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card { q // q ≠ p } + 1 = Fintype.card P"],"goalsAfter":[],"content":"by"},{"tailPos":26500,"headPos":26309,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card { q // q ≠ p } + 1 = Fintype.card P"],"goalsAfter":[],"content":"by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))"},{"tailPos":26500,"headPos":26245,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"content":"have h1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P := by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))"},{"tailPos":26620,"headPos":26613,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\n⊢ ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"content":"intro l"},{"tailPos":26720,"headPos":26631,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { x // ↑x ≠ p } = order P L"],"content":"← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),"},{"tailPos":26800,"headPos":26729,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { x // ↑x ≠ p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"content":"Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p,"},{"tailPos":26837,"headPos":26801,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Nat.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"content":"←\n        Nat.card_eq_fintype_card"},{"tailPos":26838,"headPos":26837,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Nat.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Nat.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"content":"]"},{"tailPos":26838,"headPos":26627,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Nat.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"content":"rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]"},{"tailPos":26902,"headPos":26845,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ Nat.card { x // x ∈ ↑l } - Fintype.card { x // ↑x = p } = order P L"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + 1 = order P L + Fintype.card { x // ↑x = p }"],"content":"refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)"},{"tailPos":26980,"headPos":26913,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + 1 = order P L + Fintype.card { x // ↑x = p }"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"content":"← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })"},{"tailPos":26981,"headPos":26980,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"content":"]"},{"tailPos":26981,"headPos":26909,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + 1 = order P L + Fintype.card { x // ↑x = p }"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"content":"rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]"},{"tailPos":26997,"headPos":26988,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"goalsAfter":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"content":"simp_rw ["},{"tailPos":27016,"headPos":26997,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"goalsAfter":[],"content":"simp only [Subtype.ext_iff_val]"},{"tailPos":27017,"headPos":26988,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nl : { l // p ∈ l }\n⊢ order P L + Fintype.card { x // x = { val := p, property := (_ : p ∈ ↑l) } } =\n    order P L + Fintype.card { x // ↑x = p }"],"goalsAfter":[],"content":"simp_rw [Subtype.ext_iff_val]"},{"tailPos":27017,"headPos":26613,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\n⊢ ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"goalsAfter":[],"content":"intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]"},{"tailPos":26606,"headPos":26604,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\n⊢ ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"goalsAfter":[],"content":"by"},{"tailPos":27017,"headPos":26604,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\n⊢ ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L"],"goalsAfter":[],"content":"by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]"},{"tailPos":27017,"headPos":26505,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"content":"have h2 : ∀ l : { l : L // p ∈ l }, Fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L := by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]"},{"tailPos":27031,"headPos":27022,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"content":"simp_rw ["},{"tailPos":27038,"headPos":27031,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card { q // q ≠ p } + 1 = order P L ^ 2 + order P L + 1"],"content":"← h1,"},{"tailPos":27061,"headPos":27039,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card { q // q ≠ p } + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card ((l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }) + 1 = order P L ^ 2 + order P L + 1"],"content":"Fintype.card_congr ϕ,"},{"tailPos":27081,"headPos":27062,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card ((l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }) + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ ∑ a : { l // p ∈ l }, Fintype.card { q // q ∈ ↑a ∧ q ≠ p } + 1 = order P L ^ 2 + order P L + 1"],"content":"Fintype.card_sigma,"},{"tailPos":27085,"headPos":27082,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ ∑ a : { l // p ∈ l }, Fintype.card { q // q ∈ ↑a ∧ q ≠ p } + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ ∑ x : { l // p ∈ l }, order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"h2,"},{"tailPos":27103,"headPos":27086,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ ∑ x : { l // p ∈ l }, order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Finset.card Finset.univ • order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"Finset.sum_const,"},{"tailPos":27120,"headPos":27104,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Finset.card Finset.univ • order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card { l // p ∈ l } • order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"simp only [Finset.card_univ]"},{"tailPos":27121,"headPos":27022,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card { l // p ∈ l } • order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"simp_rw [← h1, Fintype.card_congr ϕ, Fintype.card_sigma, h2, Finset.sum_const, Finset.card_univ]"},{"tailPos":27159,"headPos":27130,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card { l // p ∈ l } • order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Nat.card { l // p ∈ l } • order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"← Nat.card_eq_fintype_card,"},{"tailPos":27174,"headPos":27160,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Nat.card { l // p ∈ l } • order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ lineCount L p • order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"← lineCount,"},{"tailPos":27188,"headPos":27175,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ lineCount L p • order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ (order P L + 1) • order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"lineCount_eq,"},{"tailPos":27201,"headPos":27189,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ (order P L + 1) • order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ (order P L + 1) * order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"smul_eq_mul,"},{"tailPos":27215,"headPos":27202,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ (order P L + 1) * order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ order P L * order P L + order P L + 1 = order P L ^ 2 + order P L + 1"],"content":"Nat.succ_mul,"},{"tailPos":27218,"headPos":27216,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ order P L * order P L + order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ order P L * order P L + order P L + 1 = order P L * order P L + order P L + 1"],"content":"sq"},{"tailPos":27219,"headPos":27218,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ order P L * order P L + order P L + 1 = order P L * order P L + order P L + 1"],"goalsAfter":[],"content":"]"},{"tailPos":27219,"headPos":27126,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\nh1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P\nh2 : ∀ (l : { l // p ∈ l }), Fintype.card { q // q ∈ ↑l ∧ q ≠ p } = order P L\n⊢ Fintype.card { l // p ∈ l } • order P L + 1 = order P L ^ 2 + order P L + 1"],"goalsAfter":[],"content":"rw [← Nat.card_eq_fintype_card, ← lineCount, lineCount_eq, smul_eq_mul, Nat.succ_mul, sq]"},{"tailPos":27219,"headPos":26245,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":[],"content":"have h1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P := by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))\n    have h2 : ∀ l : { l : L // p ∈ l }, Fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L := by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]\n    simp_rw [← h1, Fintype.card_congr ϕ, Fintype.card_sigma, h2, Finset.sum_const, Finset.card_univ]\n    rw [← Nat.card_eq_fintype_card, ← lineCount, lineCount_eq, smul_eq_mul, Nat.succ_mul, sq]"},{"tailPos":27219,"headPos":26231,"goalsBefore":["case intro.intro\nP : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\nval✝ : Fintype L\np : P\nϕ : { q // q ≠ p } ≃ (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p } :=\n  {\n    toFun := fun q =>\n      { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n        snd :=\n          { val := ↑q,\n            property :=\n              (_ : ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } },\n    invFun := fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) },\n    left_inv :=\n      (_ :\n        ∀ (q : { q // q ≠ p }),\n          (fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) })\n              ((fun q =>\n                  { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                    snd :=\n                      { val := ↑q,\n                        property :=\n                          (_ :\n                            ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧\n                              ↑q ≠ p) } })\n                q) =\n            q),\n    right_inv :=\n      (_ :\n        ∀ (lq : (l : { l // p ∈ l }) × { q // q ∈ ↑l ∧ q ≠ p }),\n          (fun q =>\n                { fst := { val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) },\n                  snd :=\n                    { val := ↑q,\n                      property :=\n                        (_ :\n                          ↑q ∈ ↑{ val := mkLine (_ : ↑q ≠ p), property := (_ : p ∈ mkLine (_ : ↑q ≠ p)) } ∧ ↑q ≠ p) } })\n              ((fun lq => { val := ↑lq.snd, property := (_ : ↑lq.snd ≠ p) }) lq) =\n            lq) }\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":[],"content":"classical\n    have h1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P := by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))\n    have h2 : ∀ l : { l : L // p ∈ l }, Fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L := by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]\n    simp_rw [← h1, Fintype.card_congr ϕ, Fintype.card_sigma, h2, Finset.sum_const, Finset.card_univ]\n    rw [← Nat.card_eq_fintype_card, ← lineCount, lineCount_eq, smul_eq_mul, Nat.succ_mul, sq]"},{"tailPos":27219,"headPos":25663,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":[],"content":"cases nonempty_fintype L\n  obtain ⟨p, -⟩ := @exists_config P L _ _\n  let ϕ : { q // q ≠ p } ≃ Σl : { l : L // p ∈ l }, { q // q ∈ l.1 ∧ q ≠ p } :=\n    { toFun := fun q => ⟨⟨mkLine q.2, (mkLine_ax q.2).2⟩, q, (mkLine_ax q.2).1, q.2⟩\n      invFun := fun lq => ⟨lq.2, lq.2.2.2⟩\n      left_inv := fun q => Subtype.ext rfl\n      right_inv := fun lq =>\n        Sigma.subtype_ext\n          (Subtype.ext\n            ((eq_or_eq (mkLine_ax lq.2.2.2).1 (mkLine_ax lq.2.2.2).2 lq.2.2.1 lq.1.2).resolve_left\n              lq.2.2.2))\n          rfl }\n  classical\n    have h1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P := by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))\n    have h2 : ∀ l : { l : L // p ∈ l }, Fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L := by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]\n    simp_rw [← h1, Fintype.card_congr ϕ, Fintype.card_sigma, h2, Finset.sum_const, Finset.card_univ]\n    rw [← Nat.card_eq_fintype_card, ← lineCount, lineCount_eq, smul_eq_mul, Nat.succ_mul, sq]"},{"tailPos":25660,"headPos":25658,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":[],"content":"by"},{"tailPos":27219,"headPos":25658,"goalsBefore":["P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\n⊢ Fintype.card P = order P L ^ 2 + order P L + 1"],"goalsAfter":[],"content":"by\n  cases nonempty_fintype L\n  obtain ⟨p, -⟩ := @exists_config P L _ _\n  let ϕ : { q // q ≠ p } ≃ Σl : { l : L // p ∈ l }, { q // q ∈ l.1 ∧ q ≠ p } :=\n    { toFun := fun q => ⟨⟨mkLine q.2, (mkLine_ax q.2).2⟩, q, (mkLine_ax q.2).1, q.2⟩\n      invFun := fun lq => ⟨lq.2, lq.2.2.2⟩\n      left_inv := fun q => Subtype.ext rfl\n      right_inv := fun lq =>\n        Sigma.subtype_ext\n          (Subtype.ext\n            ((eq_or_eq (mkLine_ax lq.2.2.2).1 (mkLine_ax lq.2.2.2).2 lq.2.2.1 lq.1.2).resolve_left\n              lq.2.2.2))\n          rfl }\n  classical\n    have h1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P := by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert(Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))\n    have h2 : ∀ l : { l : L // p ∈ l }, Fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L := by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine' tsub_eq_of_eq_add ((pointCount_eq P l.1).trans _)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]\n    simp_rw [← h1, Fintype.card_congr ϕ, Fintype.card_sigma, h2, Finset.sum_const, Finset.card_univ]\n    rw [← Nat.card_eq_fintype_card, ← lineCount, lineCount_eq, smul_eq_mul, Nat.succ_mul, sq]"}]
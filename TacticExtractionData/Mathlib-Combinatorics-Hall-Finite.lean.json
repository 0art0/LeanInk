[{"tailPos":1907,"headPos":1880,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\ns' : Finset ↑{x' | x' ≠ x}\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"haveI := Classical.decEq ι"},{"tailPos":1947,"headPos":1910,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha :\n  Finset.Nonempty (image (fun z => ↑z) s') →\n    image (fun z => ↑z) s' ≠ univ → card (image (fun z => ↑z) s') < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"specialize ha (s'.image fun z => z.1)"},{"tailPos":1973,"headPos":1954,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha :\n  Finset.Nonempty (image (fun z => ↑z) s') →\n    image (fun z => ↑z) s' ≠ univ → card (image (fun z => ↑z) s') < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha :\n  Finset.Nonempty s' →\n    image (fun z => ↑z) s' ≠ univ → card (image (fun z => ↑z) s') < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"Nonempty.image_iff,"},{"tailPos":2029,"headPos":1974,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha :\n  Finset.Nonempty s' →\n    image (fun z => ↑z) s' ≠ univ → card (image (fun z => ↑z) s') < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"Finset.card_image_of_injective s' Subtype.coe_injective"},{"tailPos":2030,"headPos":2029,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"]"},{"tailPos":2036,"headPos":1950,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha :\n  Finset.Nonempty (image (fun z => ↑z) s') →\n    image (fun z => ↑z) s' ≠ univ → card (image (fun z => ↑z) s') < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"rw [Nonempty.image_iff, Finset.card_image_of_injective s' Subtype.coe_injective] at ha"},{"tailPos":2064,"headPos":2039,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"by_cases he : s'.Nonempty"},{"tailPos":2069,"headPos":2067,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"·"},{"tailPos":2190,"headPos":2160,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nh : image (fun z => ↑z) s' = univ\n⊢ False"],"goalsAfter":[],"content":"simpa only [← h, ne_eq, Set.coe_setOf, Set.mem_setOf_eq, mem_image, Subtype.exists, exists_and_right,\n  exists_eq_right, not_true, IsEmpty.exists_iff] using mem_univ x"},{"tailPos":2159,"headPos":2157,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nh : image (fun z => ↑z) s' = univ\n⊢ False"],"goalsAfter":[],"content":"by"},{"tailPos":2190,"headPos":2157,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nh : image (fun z => ↑z) s' = univ\n⊢ False"],"goalsAfter":[],"content":"by simpa [← h] using mem_univ x"},{"tailPos":2198,"headPos":2134,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"goalsAfter":["case h.e'_4.h.e'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ (Finset.biUnion s' fun x_1 => t ↑x_1) = Finset.biUnion (image (fun z => ↑z) s') t"],"content":"convert ha he fun h => by simpa [← h] using mem_univ x using 2"},{"tailPos":2210,"headPos":2205,"goalsBefore":["case h.e'_4.h.e'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ (Finset.biUnion s' fun x_1 => t ↑x_1) = Finset.biUnion (image (fun z => ↑z) s') t"],"goalsAfter":["case h.e'_4.h.e'_2.a\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx✝ : ι\na : α\ns' : Finset ↑{x' | x' ≠ x✝}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nx : α\n⊢ (x ∈ Finset.biUnion s' fun x => t ↑x) ↔ x ∈ Finset.biUnion (image (fun z => ↑z) s') t"],"content":"ext x"},{"tailPos":2338,"headPos":2217,"goalsBefore":["case h.e'_4.h.e'_2.a\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx✝ : ι\na : α\ns' : Finset ↑{x' | x' ≠ x✝}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nx : α\n⊢ (x ∈ Finset.biUnion s' fun x => t ↑x) ↔ x ∈ Finset.biUnion (image (fun z => ↑z) s') t"],"goalsAfter":[],"content":"simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]"},{"tailPos":2338,"headPos":2134,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"goalsAfter":[],"content":"convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]"},{"tailPos":2127,"headPos":2125,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"goalsAfter":[],"content":"by"},{"tailPos":2338,"headPos":2125,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"goalsAfter":[],"content":"by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]"},{"tailPos":2338,"headPos":2070,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"have ha' : s'.card < (s'.biUnion fun x => t x).card := by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]"},{"tailPos":2364,"headPos":2347,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"← erase_biUnion"},{"tailPos":2365,"headPos":2364,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"]"},{"tailPos":2365,"headPos":2343,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"rw [← erase_biUnion]"},{"tailPos":2413,"headPos":2370,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"by_cases hb : a ∈ s'.biUnion fun x => t x"},{"tailPos":2420,"headPos":2418,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"·"},{"tailPos":2445,"headPos":2425,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1) - 1"],"content":"card_erase_of_mem hb"},{"tailPos":2446,"headPos":2445,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1) - 1"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1) - 1"],"content":"]"},{"tailPos":2446,"headPos":2421,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1) - 1"],"content":"rw [card_erase_of_mem hb]"},{"tailPos":2480,"headPos":2453,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1) - 1"],"goalsAfter":[],"content":"exact Nat.le_pred_of_lt ha'"},{"tailPos":2480,"headPos":2421,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":[],"content":"rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'"},{"tailPos":2480,"headPos":2418,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"· rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'"},{"tailPos":2487,"headPos":2485,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"content":"·"},{"tailPos":2514,"headPos":2492,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"content":"erase_eq_of_not_mem hb"},{"tailPos":2515,"headPos":2514,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"content":"]"},{"tailPos":2515,"headPos":2488,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"content":"rw [erase_eq_of_not_mem hb]"},{"tailPos":2544,"headPos":2522,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (Finset.biUnion s' fun x_1 => t ↑x_1)"],"goalsAfter":[],"content":"exact Nat.le_of_lt ha'"},{"tailPos":2544,"headPos":2488,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":[],"content":"rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'"},{"tailPos":2544,"headPos":2485,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\nha' : card s' < card (Finset.biUnion s' fun x_1 => t ↑x_1)\nhb : ¬a ∈ Finset.biUnion s' fun x_1 => t ↑x_1\n⊢ card s' ≤ card (erase (Finset.biUnion s' fun x' => t ↑x') a)"],"goalsAfter":[],"content":"· rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'"},{"tailPos":2544,"headPos":2070,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"have ha' : s'.card < (s'.biUnion fun x => t x).card := by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]\n    rw [← erase_biUnion]\n    by_cases hb : a ∈ s'.biUnion fun x => t x\n    · rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'\n    · rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'"},{"tailPos":2544,"headPos":2067,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"· have ha' : s'.card < (s'.biUnion fun x => t x).card := by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]\n    rw [← erase_biUnion]\n    by_cases hb : a ∈ s'.biUnion fun x => t x\n    · rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'\n    · rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'"},{"tailPos":2549,"headPos":2547,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"·"},{"tailPos":2576,"headPos":2554,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬s' ≠ ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"nonempty_iff_ne_empty,"},{"tailPos":2584,"headPos":2577,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬s' ≠ ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : s' = ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"not_not"},{"tailPos":2585,"headPos":2584,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : s' = ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : s' = ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"]"},{"tailPos":2591,"headPos":2550,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : s' = ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"content":"rw [nonempty_iff_ne_empty, not_not] at he"},{"tailPos":2604,"headPos":2596,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : s' = ∅\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nthis : DecidableEq ι\nha : Finset.Nonempty ∅ → image (fun z => ↑z) ∅ ≠ univ → card ∅ < card (Finset.biUnion (image (fun z => ↑z) ∅) t)\n⊢ card ∅ ≤ card (Finset.biUnion ∅ fun x' => erase (t ↑x') a)"],"content":"subst s'"},{"tailPos":2613,"headPos":2609,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nthis : DecidableEq ι\nha : Finset.Nonempty ∅ → image (fun z => ↑z) ∅ ≠ univ → card ∅ < card (Finset.biUnion (image (fun z => ↑z) ∅) t)\n⊢ card ∅ ≤ card (Finset.biUnion ∅ fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"simp only [ne_eq, Set.coe_setOf, card_empty, Set.mem_setOf_eq, biUnion_empty, le_refl]"},{"tailPos":2613,"headPos":2550,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"rw [nonempty_iff_ne_empty, not_not] at he\n    subst s'\n    simp"},{"tailPos":2613,"headPos":2547,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\ns' : Finset ↑{x' | x' ≠ x}\nthis : DecidableEq ι\nha : Finset.Nonempty s' → image (fun z => ↑z) s' ≠ univ → card s' < card (Finset.biUnion (image (fun z => ↑z) s') t)\nhe : ¬Finset.Nonempty s'\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"· rw [nonempty_iff_ne_empty, not_not] at he\n    subst s'\n    simp"},{"tailPos":2613,"headPos":1880,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\ns' : Finset ↑{x' | x' ≠ x}\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"haveI := Classical.decEq ι\n  specialize ha (s'.image fun z => z.1)\n  rw [Nonempty.image_iff, Finset.card_image_of_injective s' Subtype.coe_injective] at ha\n  by_cases he : s'.Nonempty\n  · have ha' : s'.card < (s'.biUnion fun x => t x).card := by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]\n    rw [← erase_biUnion]\n    by_cases hb : a ∈ s'.biUnion fun x => t x\n    · rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'\n    · rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'\n  · rw [nonempty_iff_ne_empty, not_not] at he\n    subst s'\n    simp"},{"tailPos":1877,"headPos":1875,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\ns' : Finset ↑{x' | x' ≠ x}\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"by"},{"tailPos":2613,"headPos":1875,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nx : ι\na : α\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\ns' : Finset ↑{x' | x' ≠ x}\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => erase (t ↑x') a)"],"goalsAfter":[],"content":"by\n  haveI := Classical.decEq ι\n  specialize ha (s'.image fun z => z.1)\n  rw [Nonempty.image_iff, Finset.card_image_of_injective s' Subtype.coe_injective] at ha\n  by_cases he : s'.Nonempty\n  · have ha' : s'.card < (s'.biUnion fun x => t x).card := by\n      convert ha he fun h => by simpa [← h] using mem_univ x using 2\n      ext x\n      simp only [mem_image, mem_biUnion, exists_prop, SetCoe.exists, exists_and_right,\n        exists_eq_right, Subtype.coe_mk]\n    rw [← erase_biUnion]\n    by_cases hb : a ∈ s'.biUnion fun x => t x\n    · rw [card_erase_of_mem hb]\n      exact Nat.le_pred_of_lt ha'\n    · rw [erase_eq_of_not_mem hb]\n      exact Nat.le_of_lt ha'\n  · rw [nonempty_iff_ne_empty, not_not] at he\n    subst s'\n    simp"},{"tailPos":3621,"headPos":3546,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis : Nonempty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"haveI : Nonempty ι := Fintype.card_pos_iff.mp (hn.symm ▸ Nat.succ_pos _)"},{"tailPos":3651,"headPos":3624,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis : Nonempty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"haveI := Classical.decEq ι"},{"tailPos":3742,"headPos":3711,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"let x := Classical.arbitrary ι"},{"tailPos":3806,"headPos":3787,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ Finset.Nonempty (t x)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ 0 < card (t x)"],"content":"← Finset.card_pos"},{"tailPos":3807,"headPos":3806,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ 0 < card (t x)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ 0 < card (t x)"],"content":"]"},{"tailPos":3807,"headPos":3783,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ Finset.Nonempty (t x)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ 0 < card (t x)"],"content":"rw [← Finset.card_pos]"},{"tailPos":3949,"headPos":3925,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ card (Finset.biUnion {x} t) = card (t x)"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ card (t x) = card (t x)"],"content":"Finset.singleton_biUnion"},{"tailPos":3950,"headPos":3949,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ card (t x) = card (t x)"],"goalsAfter":[],"content":"]"},{"tailPos":3950,"headPos":3921,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ card (Finset.biUnion {x} t) = card (t x)"],"goalsAfter":[],"content":"rw [Finset.singleton_biUnion]"},{"tailPos":3920,"headPos":3918,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ card (Finset.biUnion {x} t) = card (t x)"],"goalsAfter":[],"content":"by"},{"tailPos":3950,"headPos":3918,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ card (Finset.biUnion {x} t) = card (t x)"],"goalsAfter":[],"content":"by rw [Finset.singleton_biUnion]"},{"tailPos":3950,"headPos":3812,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ 0 < card (t x)"],"goalsAfter":[],"content":"calc\n      0 < 1 := Nat.one_pos\n      _ ≤ (Finset.biUnion {x} t).card := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]"},{"tailPos":3950,"headPos":3783,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ Finset.Nonempty (t x)"],"goalsAfter":[],"content":"rw [← Finset.card_pos]\n    calc\n      0 < 1 := Nat.one_pos\n      _ ≤ (Finset.biUnion {x} t).card := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]"},{"tailPos":3778,"headPos":3776,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ Finset.Nonempty (t x)"],"goalsAfter":[],"content":"by"},{"tailPos":3950,"headPos":3776,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ Finset.Nonempty (t x)"],"goalsAfter":[],"content":"by\n    rw [← Finset.card_pos]\n    calc\n      0 < 1 := Nat.one_pos\n      _ ≤ (Finset.biUnion {x} t).card := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]"},{"tailPos":3950,"headPos":3745,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ntx_ne : Finset.Nonempty (t x)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have tx_ne : (t x).Nonempty := by\n    rw [← Finset.card_pos]\n    calc\n      0 < 1 := Nat.one_pos\n      _ ≤ (Finset.biUnion {x} t).card := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]"},{"tailPos":3977,"headPos":3954,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ntx_ne : Finset.Nonempty (t x)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"choose y hy using tx_ne"},{"tailPos":4061,"headPos":4028,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"let ι' := { x' : ι | x' ≠ x }"},{"tailPos":4118,"headPos":4064,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"let t' : ι' → Finset α := fun x' => (t x').erase y"},{"tailPos":4260,"headPos":4257,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ Fintype.card ι - 1 = n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ n + 1 - 1 = n"],"content":"hn,"},{"tailPos":4282,"headPos":4261,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ n + 1 - 1 = n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ n + 0 = n"],"content":"Nat.add_succ_sub_one,"},{"tailPos":4291,"headPos":4283,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ n + 0 = n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ n = n"],"content":"add_zero"},{"tailPos":4292,"headPos":4291,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ n = n"],"goalsAfter":[],"content":"]"},{"tailPos":4292,"headPos":4253,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ Fintype.card ι - 1 = n"],"goalsAfter":[],"content":"rw [hn, Nat.add_succ_sub_one, add_zero]"},{"tailPos":4252,"headPos":4250,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ Fintype.card ι - 1 = n"],"goalsAfter":[],"content":"by"},{"tailPos":4292,"headPos":4250,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ Fintype.card ι - 1 = n"],"goalsAfter":[],"content":"by rw [hn, Nat.add_succ_sub_one, add_zero]"},{"tailPos":4292,"headPos":4121,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have card_ι' : Fintype.card ι' = n :=\n    calc\n      Fintype.card ι' = Fintype.card ι - 1 := Set.card_ne_eq _\n      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]"},{"tailPos":4372,"headPos":4296,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rcases ih t' card_ι'.le (hall_cond_of_erase y ha) with ⟨f', hfinj, hfr⟩"},{"tailPos":4478,"headPos":4411,"goalsBefore":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ Function.Injective fun z => if h : z = x then y else f' { val := z, property := h }","case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"content":"refine' ⟨fun z => if h : z = x then y else f' ⟨z, h⟩, _, _⟩"},{"tailPos":4483,"headPos":4481,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ Function.Injective fun z => if h : z = x then y else f' { val := z, property := h }","case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"goalsAfter":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ Function.Injective fun z => if h : z = x then y else f' { val := z, property := h }"],"content":"·"},{"tailPos":4500,"headPos":4484,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ Function.Injective fun z => if h : z = x then y else f' { val := z, property := h }"],"goalsAfter":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"rintro z₁ z₂"},{"tailPos":4557,"headPos":4548,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\n⊢ ∀ {x : ↑ι'}, y ≠ f' x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx✝ : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x✝\nι' : Set ι := {x' | x' ≠ x✝}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nx : ↑ι'\nh : y = f' x\n⊢ False"],"content":"intro x h"},{"tailPos":4589,"headPos":4564,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx✝ : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x✝\nι' : Set ι := {x' | x' ≠ x✝}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nx : ↑ι'\nh : y = f' x\n⊢ False"],"goalsAfter":[],"content":"simpa only [← h, ne_eq, Set.coe_setOf, Set.mem_setOf_eq, mem_erase, not_true, false_and] using hfr x"},{"tailPos":4589,"headPos":4548,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\n⊢ ∀ {x : ↑ι'}, y ≠ f' x"],"goalsAfter":[],"content":"intro x h\n      simpa [← h] using hfr x"},{"tailPos":4541,"headPos":4539,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\n⊢ ∀ {x : ↑ι'}, y ≠ f' x"],"goalsAfter":[],"content":"by"},{"tailPos":4589,"headPos":4539,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\n⊢ ∀ {x : ↑ι'}, y ≠ f' x"],"goalsAfter":[],"content":"by\n      intro x h\n      simpa [← h] using hfr x"},{"tailPos":4589,"headPos":4505,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [← h] using hfr x"},{"tailPos":4618,"headPos":4594,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"by_cases h₁ : z₁ = x"},{"tailPos":4622,"headPos":4619,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"<;>"},{"tailPos":4647,"headPos":4623,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"by_cases h₂ : z₂ = x"},{"tailPos":4647,"headPos":4623,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"by_cases h₂ : z₂ = x"},{"tailPos":4647,"headPos":4594,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x"},{"tailPos":4651,"headPos":4648,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂","case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"content":"<;>"},{"tailPos":4698,"headPos":4652,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":[],"content":"simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4698,"headPos":4652,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":[],"content":"simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4698,"headPos":4652,"goalsBefore":["case pos\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":[],"content":"simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4698,"headPos":4652,"goalsBefore":["case neg\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\nh₁ : ¬z₁ = x\nh₂ : ¬z₂ = x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":[],"content":"simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4698,"headPos":4594,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz₁ z₂ : ι\nkey : ∀ {x : ↑ι'}, y ≠ f' x\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z₁ =\n      (fun z => if h : z = x then y else f' { val := z, property := h }) z₂ →\n    z₁ = z₂"],"goalsAfter":[],"content":"by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;> simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4698,"headPos":4484,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ Function.Injective fun z => if h : z = x then y else f' { val := z, property := h }"],"goalsAfter":[],"content":"rintro z₁ z₂\n    have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [← h] using hfr x\n    by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;> simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4698,"headPos":4481,"goalsBefore":["case intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ Function.Injective fun z => if h : z = x then y else f' { val := z, property := h }","case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"goalsAfter":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"content":"· rintro z₁ z₂\n    have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [← h] using hfr x\n    by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;> simp [h₁, h₂, hfinj.eq_iff, key, key.symm]"},{"tailPos":4703,"headPos":4701,"goalsBefore":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"goalsAfter":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"content":"·"},{"tailPos":4711,"headPos":4704,"goalsBefore":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"goalsAfter":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z ∈ t z"],"content":"intro z"},{"tailPos":4751,"headPos":4716,"goalsBefore":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\n⊢ (fun z => if h : z = x then y else f' { val := z, property := h }) z ∈ t z"],"goalsAfter":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\n⊢ (if h : z = Classical.arbitrary ι then y else f' { val := z, property := h }) ∈ t z"],"content":"simp only [ne_eq, Set.mem_setOf_eq]"},{"tailPos":4773,"headPos":4756,"goalsBefore":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\n⊢ (if h : z = Classical.arbitrary ι then y else f' { val := z, property := h }) ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t z","case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"split_ifs with hz"},{"tailPos":4780,"headPos":4778,"goalsBefore":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t z","case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t z"],"content":"·"},{"tailPos":4788,"headPos":4786,"goalsBefore":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t (Classical.arbitrary ι)"],"content":"hz"},{"tailPos":4789,"headPos":4788,"goalsBefore":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t (Classical.arbitrary ι)"],"goalsAfter":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t (Classical.arbitrary ι)"],"content":"]"},{"tailPos":4789,"headPos":4781,"goalsBefore":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t z"],"goalsAfter":[],"content":"rwa [hz]"},{"tailPos":4789,"headPos":4778,"goalsBefore":["case intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : z = Classical.arbitrary ι\n⊢ y ∈ t z","case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"· rwa [hz]"},{"tailPos":4796,"headPos":4794,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"·"},{"tailPos":4823,"headPos":4797,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ∈ t' { val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"specialize hfr ⟨z, hz⟩"},{"tailPos":4843,"headPos":4834,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ∈ t' { val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ≠ y ∧ f' { val := z, property := hz } ∈ t ↑{ val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"mem_erase"},{"tailPos":4844,"headPos":4843,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ≠ y ∧ f' { val := z, property := hz } ∈ t ↑{ val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ≠ y ∧ f' { val := z, property := hz } ∈ t ↑{ val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"]"},{"tailPos":4851,"headPos":4830,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ∈ t' { val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ≠ y ∧ f' { val := z, property := hz } ∈ t ↑{ val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"content":"rw [mem_erase] at hfr"},{"tailPos":4869,"headPos":4858,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nz : ι\nhz : ¬z = Classical.arbitrary ι\nhfr : f' { val := z, property := hz } ≠ y ∧ f' { val := z, property := hz } ∈ t ↑{ val := z, property := hz }\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":[],"content":"exact hfr.2"},{"tailPos":4869,"headPos":4797,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":[],"content":"specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2"},{"tailPos":4869,"headPos":4794,"goalsBefore":["case intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\nz : ι\nhz : ¬z = Classical.arbitrary ι\n⊢ f' { val := z, property := hz } ∈ t z"],"goalsAfter":[],"content":"· specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2"},{"tailPos":4869,"headPos":4704,"goalsBefore":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"goalsAfter":[],"content":"intro z\n    simp only [ne_eq, Set.mem_setOf_eq]\n    split_ifs with hz\n    · rwa [hz]\n    · specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2"},{"tailPos":4869,"headPos":4701,"goalsBefore":["case intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\nthis✝ : Nonempty ι\nthis : DecidableEq ι\nx : ι := Classical.arbitrary ι\ny : α\nhy : y ∈ t x\nι' : Set ι := {x' | x' ≠ x}\nt' : ↑ι' → Finset α := fun x' => erase (t ↑x') y\ncard_ι' : Fintype.card ↑ι' = n\nf' : ↑ι' → α\nhfinj : Function.Injective f'\nhfr : ∀ (x : ↑ι'), f' x ∈ t' x\n⊢ ∀ (x_1 : ι), (fun z => if h : z = x then y else f' { val := z, property := h }) x_1 ∈ t x_1"],"goalsAfter":[],"content":"· intro z\n    simp only [ne_eq, Set.mem_setOf_eq]\n    split_ifs with hz\n    · rwa [hz]\n    · specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2"},{"tailPos":4869,"headPos":3546,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"haveI : Nonempty ι := Fintype.card_pos_iff.mp (hn.symm ▸ Nat.succ_pos _)\n  haveI := Classical.decEq ι\n  -- Choose an arbitrary element `x : ι` and `y : t x`.\n  let x := Classical.arbitrary ι\n  have tx_ne : (t x).Nonempty := by\n    rw [← Finset.card_pos]\n    calc\n      0 < 1 := Nat.one_pos\n      _ ≤ (Finset.biUnion {x} t).card := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]\n\n  choose y hy using tx_ne\n  -- Restrict to everything except `x` and `y`.\n  let ι' := { x' : ι | x' ≠ x }\n  let t' : ι' → Finset α := fun x' => (t x').erase y\n  have card_ι' : Fintype.card ι' = n :=\n    calc\n      Fintype.card ι' = Fintype.card ι - 1 := Set.card_ne_eq _\n      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]\n\n  rcases ih t' card_ι'.le (hall_cond_of_erase y ha) with ⟨f', hfinj, hfr⟩\n  -- Extend the resulting function.\n  refine' ⟨fun z => if h : z = x then y else f' ⟨z, h⟩, _, _⟩\n  · rintro z₁ z₂\n    have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [← h] using hfr x\n    by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;> simp [h₁, h₂, hfinj.eq_iff, key, key.symm]\n  · intro z\n    simp only [ne_eq, Set.mem_setOf_eq]\n    split_ifs with hz\n    · rwa [hz]\n    · specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2"},{"tailPos":3543,"headPos":3541,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by"},{"tailPos":4869,"headPos":3541,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nha : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by\n  haveI : Nonempty ι := Fintype.card_pos_iff.mp (hn.symm ▸ Nat.succ_pos _)\n  haveI := Classical.decEq ι\n  -- Choose an arbitrary element `x : ι` and `y : t x`.\n  let x := Classical.arbitrary ι\n  have tx_ne : (t x).Nonempty := by\n    rw [← Finset.card_pos]\n    calc\n      0 < 1 := Nat.one_pos\n      _ ≤ (Finset.biUnion {x} t).card := ht {x}\n      _ = (t x).card := by rw [Finset.singleton_biUnion]\n\n  choose y hy using tx_ne\n  -- Restrict to everything except `x` and `y`.\n  let ι' := { x' : ι | x' ≠ x }\n  let t' : ι' → Finset α := fun x' => (t x').erase y\n  have card_ι' : Fintype.card ι' = n :=\n    calc\n      Fintype.card ι' = Fintype.card ι - 1 := Set.card_ne_eq _\n      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]\n\n  rcases ih t' card_ι'.le (hall_cond_of_erase y ha) with ⟨f', hfinj, hfr⟩\n  -- Extend the resulting function.\n  refine' ⟨fun z => if h : z = x then y else f' ⟨z, h⟩, _, _⟩\n  · rintro z₁ z₂\n    have key : ∀ {x}, y ≠ f' x := by\n      intro x h\n      simpa [← h] using hfr x\n    by_cases h₁ : z₁ = x <;> by_cases h₂ : z₂ = x <;> simp [h₁, h₂, hfinj.eq_iff, key, key.symm]\n  · intro z\n    simp only [ne_eq, Set.mem_setOf_eq]\n    split_ifs with hz\n    · rwa [hz]\n    · specialize hfr ⟨z, hz⟩\n      rw [mem_erase] at hfr\n      exact hfr.2"},{"tailPos":5315,"headPos":5263,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card s' ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (image (fun a => ↑a) s') ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"content":"← card_image_of_injective s' Subtype.coe_injective"},{"tailPos":5316,"headPos":5315,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (image (fun a => ↑a) s') ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (image (fun a => ↑a) s') ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"content":"]"},{"tailPos":5316,"headPos":5259,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card s' ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (image (fun a => ↑a) s') ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"content":"rw [← card_image_of_injective s' Subtype.coe_injective]"},{"tailPos":5363,"headPos":5321,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (image (fun a => ↑a) s') ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":["case h.e'_4\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (Finset.biUnion s' fun a' => t ↑a') = card (Finset.biUnion (image (fun z => ↑z) s') t)"],"content":"convert ht (s'.image fun z => z.1) using 1"},{"tailPos":5383,"headPos":5368,"goalsBefore":["case h.e'_4\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card (Finset.biUnion s' fun a' => t ↑a') = card (Finset.biUnion (image (fun z => ↑z) s') t)"],"goalsAfter":["case h.e'_4.h\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ (Finset.biUnion s' fun a' => t ↑a') = Finset.biUnion (image (fun z => ↑z) s') t"],"content":"apply congr_arg"},{"tailPos":5393,"headPos":5388,"goalsBefore":["case h.e'_4.h\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ (Finset.biUnion s' fun a' => t ↑a') = Finset.biUnion (image (fun z => ↑z) s') t"],"goalsAfter":["case h.e'_4.h.a\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\ny : α\n⊢ (y ∈ Finset.biUnion s' fun a' => t ↑a') ↔ y ∈ Finset.biUnion (image (fun z => ↑z) s') t"],"content":"ext y"},{"tailPos":5402,"headPos":5398,"goalsBefore":["case h.e'_4.h.a\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\ny : α\n⊢ (y ∈ Finset.biUnion s' fun a' => t ↑a') ↔ y ∈ Finset.biUnion (image (fun z => ↑z) s') t"],"goalsAfter":[],"content":"simp only [coe_sort_coe, mem_biUnion, Subtype.exists, exists_and_right, mem_image, exists_eq_right]"},{"tailPos":5402,"headPos":5259,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card s' ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":[],"content":"rw [← card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image fun z => z.1) using 1\n    apply congr_arg\n    ext y\n    simp"},{"tailPos":5402,"headPos":5245,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card s' ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":[],"content":"classical\n    rw [← card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image fun z => z.1) using 1\n    apply congr_arg\n    ext y\n    simp"},{"tailPos":5242,"headPos":5240,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card s' ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":[],"content":"by"},{"tailPos":5402,"headPos":5240,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑↑s\n⊢ card s' ≤ card (Finset.biUnion s' fun a' => t ↑a')"],"goalsAfter":[],"content":"by\n  classical\n    rw [← card_image_of_injective s' Subtype.coe_injective]\n    convert ht (s'.image fun z => z.1) using 1\n    apply congr_arg\n    ext y\n    simp"},{"tailPos":5803,"headPos":5776,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"haveI := Classical.decEq ι"},{"tailPos":5996,"headPos":5863,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ Disjoint s (image (fun z => ↑z) s')"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ ∀ ⦃a : ι⦄, a ∈ s → ∀ (x : a ∈ ↑sᶜ), ¬{ val := a, property := (_ : a ∈ ↑sᶜ) } ∈ s'"],"content":"simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]"},{"tailPos":6016,"headPos":6001,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ ∀ ⦃a : ι⦄, a ∈ s → ∀ (x : a ∈ ↑sᶜ), ¬{ val := a, property := (_ : a ∈ ↑sᶜ) } ∈ s'"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\nx : ι\nhx : x ∈ s\nhc : x ∈ ↑sᶜ\na✝ : { val := x, property := (_ : x ∈ ↑sᶜ) } ∈ s'\n⊢ False"],"content":"intro x hx hc _"},{"tailPos":6039,"headPos":6021,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\nx : ι\nhx : x ∈ s\nhc : x ∈ ↑sᶜ\na✝ : { val := x, property := (_ : x ∈ ↑sᶜ) } ∈ s'\n⊢ False"],"goalsAfter":[],"content":"exact absurd hx hc"},{"tailPos":6039,"headPos":5863,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ Disjoint s (image (fun z => ↑z) s')"],"goalsAfter":[],"content":"simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]\n    intro x hx hc _\n    exact absurd hx hc"},{"tailPos":5858,"headPos":5856,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ Disjoint s (image (fun z => ↑z) s')"],"goalsAfter":[],"content":"by"},{"tailPos":6039,"headPos":5856,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ Disjoint s (image (fun z => ↑z) s')"],"goalsAfter":[],"content":"by\n    simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]\n    intro x hx hc _\n    exact absurd hx hc"},{"tailPos":6039,"headPos":5806,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"have disj : Disjoint s (s'.image fun z => z.1) := by\n    simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]\n    intro x hx hc _\n    exact absurd hx hc"},{"tailPos":6173,"headPos":6113,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\n⊢ card s' = card (s ∪ image (fun z => ↑z) s') - card s"],"goalsAfter":[],"content":"simp [disj, card_image_of_injective _ Subtype.coe_injective]"},{"tailPos":6108,"headPos":6106,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\n⊢ card s' = card (s ∪ image (fun z => ↑z) s') - card s"],"goalsAfter":[],"content":"by"},{"tailPos":6173,"headPos":6106,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\n⊢ card s' = card (s ∪ image (fun z => ↑z) s') - card s"],"goalsAfter":[],"content":"by\n    simp [disj, card_image_of_injective _ Subtype.coe_injective]"},{"tailPos":6173,"headPos":6042,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"have : s'.card = (s ∪ s'.image fun z => z.1).card - s.card := by\n    simp [disj, card_image_of_injective _ Subtype.coe_injective]"},{"tailPos":6185,"headPos":6180,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card s ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"this,"},{"tailPos":6189,"headPos":6186,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card s ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"hus"},{"tailPos":6190,"headPos":6189,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"]"},{"tailPos":6190,"headPos":6176,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"rw [this, hus]"},{"tailPos":6238,"headPos":6193,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (s ∪ image (fun z => ↑z) s') - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t) - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"refine' (tsub_le_tsub_right (ht _) _).trans _"},{"tailPos":6259,"headPos":6245,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t) - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)","ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"content":"← card_sdiff"},{"tailPos":6260,"headPos":6259,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)","ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)","ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"content":"]"},{"tailPos":6260,"headPos":6241,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t) - card (Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)","ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"content":"rw [← card_sdiff]"},{"tailPos":6265,"headPos":6263,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)","ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"content":"·"},{"tailPos":6308,"headPos":6266,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t ⊆\n    Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t"],"content":"refine' (card_le_of_subset _).trans le_rfl"},{"tailPos":6320,"headPos":6313,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t ⊆\n    Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\n⊢ t ∈ Finset.biUnion (s ∪ image (fun z => ↑z) s') t✝ \\ Finset.biUnion s t✝ →\n    t ∈ Finset.biUnion s' fun x' => t✝ ↑x' \\ Finset.biUnion s t✝"],"content":"intro t"},{"tailPos":6438,"headPos":6325,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\n⊢ t ∈ Finset.biUnion (s ∪ image (fun z => ↑z) s') t✝ \\ Finset.biUnion s t✝ →\n    t ∈ Finset.biUnion s' fun x' => t✝ ↑x' \\ Finset.biUnion s t✝"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\n⊢ ∀ (x : ι),\n    (x ∈ s ∨ ∃ a, a ∈ s' ∧ ↑a = x) →\n      t ∈ t✝ x → (∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)) → ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"content":"simp only [mem_biUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right,\n      exists_imp]"},{"tailPos":6484,"headPos":6443,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\n⊢ ∀ (x : ι),\n    (x ∈ s ∨ ∃ a, a ∈ s' ∧ ↑a = x) →\n      t ∈ t✝ x → (∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)) → ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":["case inl\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx : ι\nhx : x ∈ s\nrat : t ∈ t✝ x\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)","case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"content":"rintro x (hx | ⟨x', hx', rfl⟩) rat hs"},{"tailPos":6491,"headPos":6489,"goalsBefore":["case inl\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx : ι\nhx : x ∈ s\nrat : t ∈ t✝ x\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)","case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":["case inl\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx : ι\nhx : x ∈ s\nrat : t ∈ t✝ x\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"content":"·"},{"tailPos":6538,"headPos":6492,"goalsBefore":["case inl\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx : ι\nhx : x ∈ s\nrat : t ∈ t✝ x\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":[],"content":"exact False.elim <| (hs x) <| And.intro hx rat"},{"tailPos":6538,"headPos":6489,"goalsBefore":["case inl\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx : ι\nhx : x ∈ s\nrat : t ∈ t✝ x\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)","case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"content":"· exact False.elim <| (hs x) <| And.intro hx rat"},{"tailPos":6545,"headPos":6543,"goalsBefore":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"content":"·"},{"tailPos":6552,"headPos":6546,"goalsBefore":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ x' ∈ s' ∧ t ∈ t✝ ↑x' ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"content":"use x'"},{"tailPos":6597,"headPos":6559,"goalsBefore":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ x' ∈ s' ∧ t ∈ t✝ ↑x' ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":[],"content":"exact And.intro hx' (And.intro rat hs)"},{"tailPos":6597,"headPos":6546,"goalsBefore":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":[],"content":"use x'\n      exact And.intro hx' (And.intro rat hs)"},{"tailPos":6597,"headPos":6543,"goalsBefore":["case inr.intro.intro\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝¹ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt✝ : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t✝)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t✝)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\nt : α\nx' : ↑(↑sᶜ)\nhx' : x' ∈ s'\nrat : t ∈ t✝ ↑x'\nhs : ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)\n⊢ ∃ a, a ∈ s' ∧ t ∈ t✝ ↑a ∧ ∀ (x : ι), ¬(x ∈ s ∧ t ∈ t✝ x)"],"goalsAfter":[],"content":"· use x'\n      exact And.intro hx' (And.intro rat hs)"},{"tailPos":6597,"headPos":6266,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":[],"content":"refine' (card_le_of_subset _).trans le_rfl\n    intro t\n    simp only [mem_biUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right,\n      exists_imp]\n    rintro x (hx | ⟨x', hx', rfl⟩) rat hs\n    · exact False.elim <| (hs x) <| And.intro hx rat\n    · use x'\n      exact And.intro hx' (And.intro rat hs)"},{"tailPos":6597,"headPos":6263,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ card (Finset.biUnion (s ∪ image (fun z => ↑z) s') t \\ Finset.biUnion s t) ≤\n    card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)","ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"content":"· refine' (card_le_of_subset _).trans le_rfl\n    intro t\n    simp only [mem_biUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right,\n      exists_imp]\n    rintro x (hx | ⟨x', hx', rfl⟩) rat hs\n    · exact False.elim <| (hs x) <| And.intro hx rat\n    · use x'\n      exact And.intro hx' (And.intro rat hs)"},{"tailPos":6602,"headPos":6600,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"content":"·"},{"tailPos":6646,"headPos":6603,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":["case h\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ s ⊆ s ∪ image (fun z => ↑z) s'"],"content":"apply biUnion_subset_biUnion_of_subset_left"},{"tailPos":6674,"headPos":6651,"goalsBefore":["case h\nι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ s ⊆ s ∪ image (fun z => ↑z) s'"],"goalsAfter":[],"content":"apply subset_union_left"},{"tailPos":6674,"headPos":6603,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":[],"content":"apply biUnion_subset_biUnion_of_subset_left\n    apply subset_union_left"},{"tailPos":6674,"headPos":6600,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\nthis✝ : DecidableEq ι\ndisj : Disjoint s (image (fun z => ↑z) s')\nthis : card s' = card (s ∪ image (fun z => ↑z) s') - card s\n⊢ Finset.biUnion s t ⊆ Finset.biUnion (s ∪ image (fun z => ↑z) s') t"],"goalsAfter":[],"content":"· apply biUnion_subset_biUnion_of_subset_left\n    apply subset_union_left"},{"tailPos":6674,"headPos":5776,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":[],"content":"haveI := Classical.decEq ι\n  have disj : Disjoint s (s'.image fun z => z.1) := by\n    simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]\n    intro x hx hc _\n    exact absurd hx hc\n  have : s'.card = (s ∪ s'.image fun z => z.1).card - s.card := by\n    simp [disj, card_image_of_injective _ Subtype.coe_injective]\n  rw [this, hus]\n  refine' (tsub_le_tsub_right (ht _) _).trans _\n  rw [← card_sdiff]\n  · refine' (card_le_of_subset _).trans le_rfl\n    intro t\n    simp only [mem_biUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right,\n      exists_imp]\n    rintro x (hx | ⟨x', hx', rfl⟩) rat hs\n    · exact False.elim <| (hs x) <| And.intro hx rat\n    · use x'\n      exact And.intro hx' (And.intro rat hs)\n  · apply biUnion_subset_biUnion_of_subset_left\n    apply subset_union_left"},{"tailPos":5773,"headPos":5771,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":[],"content":"by"},{"tailPos":6674,"headPos":5771,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝ : Fintype ι✝\nι : Type u\nt : ι → Finset α\ns : Finset ι\nhus : card s = card (Finset.biUnion s t)\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\ns' : Finset ↑(↑sᶜ)\n⊢ card s' ≤ card (Finset.biUnion s' fun x' => t ↑x' \\ Finset.biUnion s t)"],"goalsAfter":[],"content":"by\n  haveI := Classical.decEq ι\n  have disj : Disjoint s (s'.image fun z => z.1) := by\n    simp only [disjoint_left, not_exists, mem_image, exists_prop, SetCoe.exists, exists_and_right,\n      exists_eq_right, Subtype.coe_mk]\n    intro x hx hc _\n    exact absurd hx hc\n  have : s'.card = (s ∪ s'.image fun z => z.1).card - s.card := by\n    simp [disj, card_image_of_injective _ Subtype.coe_injective]\n  rw [this, hus]\n  refine' (tsub_le_tsub_right (ht _) _).trans _\n  rw [← card_sdiff]\n  · refine' (card_le_of_subset _).trans le_rfl\n    intro t\n    simp only [mem_biUnion, mem_sdiff, not_exists, mem_image, and_imp, mem_union, exists_and_right,\n      exists_imp]\n    rintro x (hx | ⟨x', hx', rfl⟩) rat hs\n    · exact False.elim <| (hs x) <| And.intro hx rat\n    · use x'\n      exact And.intro hx' (And.intro rat hs)\n  · apply biUnion_subset_biUnion_of_subset_left\n    apply subset_union_left"},{"tailPos":7625,"headPos":7598,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"haveI := Classical.decEq ι"},{"tailPos":7664,"headPos":7653,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"Nat.add_one"},{"tailPos":7665,"headPos":7664,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"]"},{"tailPos":7671,"headPos":7649,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rw [Nat.add_one] at hn"},{"tailPos":7747,"headPos":7724,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ Fintype.card { x // x ∈ s } ≤ n"],"goalsAfter":["case a\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ Fintype.card { x // x ∈ s } < Nat.succ n"],"content":"apply Nat.le_of_lt_succ"},{"tailPos":7892,"headPos":7752,"goalsBefore":["case a\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ Fintype.card { x // x ∈ s } < Nat.succ n"],"goalsAfter":[],"content":"calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn"},{"tailPos":7892,"headPos":7724,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ Fintype.card { x // x ∈ s } ≤ n"],"goalsAfter":[],"content":"apply Nat.le_of_lt_succ\n    calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn"},{"tailPos":7719,"headPos":7717,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ Fintype.card { x // x ∈ s } ≤ n"],"goalsAfter":[],"content":"by"},{"tailPos":7892,"headPos":7717,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ Fintype.card { x // x ∈ s } ≤ n"],"goalsAfter":[],"content":"by\n    apply Nat.le_of_lt_succ\n    calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn"},{"tailPos":7892,"headPos":7674,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have card_ι'_le : Fintype.card s ≤ n := by\n    apply Nat.le_of_lt_succ\n    calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn"},{"tailPos":7937,"headPos":7895,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"let t' : s → Finset α := fun x' => t x'"},{"tailPos":8016,"headPos":7940,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rcases ih t' card_ι'_le (hall_cond_of_restrict ht) with ⟨f', hf', hsf'⟩"},{"tailPos":8124,"headPos":8097,"goalsBefore":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"set ι'' := (s : Set ι)ᶜ"},{"tailPos":8189,"headPos":8127,"goalsBefore":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"let t'' : ι'' → Finset α := fun a'' => t a'' \\ s.biUnion t"},{"tailPos":8255,"headPos":8246,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) ≤ n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) ≤ n"],"content":"simp_rw ["},{"tailPos":8275,"headPos":8255,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) ≤ n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) < Nat.succ n"],"content":"← Nat.lt_succ_iff,"},{"tailPos":8283,"headPos":8276,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) < Nat.succ n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) < Fintype.card ι"],"content":"← hn,"},{"tailPos":8305,"headPos":8284,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑(↑sᶜ) < Fintype.card ι"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑↑(sᶜ) < Fintype.card ι"],"content":"← Finset.coe_compl,"},{"tailPos":8318,"headPos":8306,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑↑(sᶜ) < Fintype.card ι"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card { x // x ∈ sᶜ } < Fintype.card ι"],"content":"simp only [coe_sort_coe]"},{"tailPos":8319,"headPos":8246,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑ι'' ≤ n"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card { x // x ∈ sᶜ } < Fintype.card ι"],"content":"simp_rw [← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]"},{"tailPos":8346,"headPos":8329,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card { x // x ∈ sᶜ } < Fintype.card ι"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ card (sᶜ) < Fintype.card ι"],"content":"Fintype.card_coe,"},{"tailPos":8373,"headPos":8347,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ card (sᶜ) < Fintype.card ι"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Finset.Nonempty s"],"content":"card_compl_lt_iff_nonempty"},{"tailPos":8374,"headPos":8373,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Finset.Nonempty s"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Finset.Nonempty s"],"content":"]"},{"tailPos":8374,"headPos":8324,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card { x // x ∈ sᶜ } < Fintype.card ι"],"goalsAfter":[],"content":"rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]"},{"tailPos":8374,"headPos":8246,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑ι'' ≤ n"],"goalsAfter":[],"content":"simp_rw [← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]"},{"tailPos":8241,"headPos":8239,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑ι'' ≤ n"],"goalsAfter":[],"content":"by"},{"tailPos":8374,"headPos":8239,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ Fintype.card ↑ι'' ≤ n"],"goalsAfter":[],"content":"by\n    simp_rw [← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]"},{"tailPos":8374,"headPos":8192,"goalsBefore":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have card_ι''_le : Fintype.card ι'' ≤ n := by\n    simp_rw [← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]"},{"tailPos":8459,"headPos":8377,"goalsBefore":["case intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rcases ih t'' card_ι''_le (hall_cond_of_compl hus ht) with ⟨f'', hf'', hsf''⟩"},{"tailPos":8589,"headPos":8577,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\n⊢ ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"content":"intro x' hx'"},{"tailPos":8609,"headPos":8598,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ ∃ a, a ∈ s ∧ f' { val := x', property := hx' } ∈ t a"],"content":"mem_biUnion"},{"tailPos":8610,"headPos":8609,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ ∃ a, a ∈ s ∧ f' { val := x', property := hx' } ∈ t a"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ ∃ a, a ∈ s ∧ f' { val := x', property := hx' } ∈ t a"],"content":"]"},{"tailPos":8610,"headPos":8594,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ ∃ a, a ∈ s ∧ f' { val := x', property := hx' } ∈ t a"],"content":"rw [mem_biUnion]"},{"tailPos":8642,"headPos":8615,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nx' : ι\nhx' : x' ∈ s\n⊢ ∃ a, a ∈ s ∧ f' { val := x', property := hx' } ∈ t a"],"goalsAfter":[],"content":"exact ⟨x', hx', hsf' _⟩"},{"tailPos":8642,"headPos":8577,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\n⊢ ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"intro x' hx'\n    rw [mem_biUnion]\n    exact ⟨x', hx', hsf' _⟩"},{"tailPos":8572,"headPos":8570,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\n⊢ ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"by"},{"tailPos":8642,"headPos":8570,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\n⊢ ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"by\n    intro x' hx'\n    rw [mem_biUnion]\n    exact ⟨x', hx', hsf' _⟩"},{"tailPos":8642,"headPos":8485,"goalsBefore":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have f'_mem_biUnion : ∀ (x') (hx' : x' ∈ s), f' ⟨x', hx'⟩ ∈ s.biUnion t := by\n    intro x' hx'\n    rw [mem_biUnion]\n    exact ⟨x', hx', hsf' _⟩"},{"tailPos":8766,"headPos":8752,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\n⊢ ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"content":"intro x'' hx''"},{"tailPos":8802,"headPos":8771,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh : f'' { val := x'', property := hx'' } ∈ t'' { val := x'', property := hx'' }\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"content":"have h := hsf'' ⟨x'', hx''⟩"},{"tailPos":8820,"headPos":8811,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh : f'' { val := x'', property := hx'' } ∈ t'' { val := x'', property := hx'' }\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh :\n  f'' { val := x'', property := hx'' } ∈ t ↑{ val := x'', property := hx'' } ∧\n    ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"content":"mem_sdiff"},{"tailPos":8821,"headPos":8820,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh :\n  f'' { val := x'', property := hx'' } ∈ t ↑{ val := x'', property := hx'' } ∧\n    ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh :\n  f'' { val := x'', property := hx'' } ∈ t ↑{ val := x'', property := hx'' } ∧\n    ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"content":"]"},{"tailPos":8826,"headPos":8807,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh : f'' { val := x'', property := hx'' } ∈ t'' { val := x'', property := hx'' }\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh :\n  f'' { val := x'', property := hx'' } ∈ t ↑{ val := x'', property := hx'' } ∧\n    ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"content":"rw [mem_sdiff] at h"},{"tailPos":8840,"headPos":8831,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nx'' : ι\nhx'' : ¬x'' ∈ s\nh :\n  f'' { val := x'', property := hx'' } ∈ t ↑{ val := x'', property := hx'' } ∧\n    ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"exact h.2"},{"tailPos":8840,"headPos":8752,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\n⊢ ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2"},{"tailPos":8747,"headPos":8745,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\n⊢ ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"by"},{"tailPos":8840,"headPos":8745,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\n⊢ ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"by\n    intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2"},{"tailPos":8840,"headPos":8645,"goalsBefore":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have f''_not_mem_biUnion : ∀ (x'') (hx'' : ¬x'' ∈ s), ¬f'' ⟨x'', hx''⟩ ∈ s.biUnion t := by\n    intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2"},{"tailPos":8993,"headPos":8972,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ False"],"content":"intro x x' hx' hx'' h"},{"tailPos":9031,"headPos":8998,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ False"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f'' { val := x', property := hx'' } ∈ Finset.biUnion s t"],"content":"apply f''_not_mem_biUnion x' hx''"},{"tailPos":9045,"headPos":9040,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f'' { val := x', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f' { val := x, property := hx' } ∈ Finset.biUnion s t"],"content":"← h"},{"tailPos":9046,"headPos":9045,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f' { val := x, property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f' { val := x, property := hx' } ∈ Finset.biUnion s t"],"content":"]"},{"tailPos":9046,"headPos":9036,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f'' { val := x', property := hx'' } ∈ Finset.biUnion s t"],"goalsAfter":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f' { val := x, property := hx' } ∈ Finset.biUnion s t"],"content":"rw [← h]"},{"tailPos":9073,"headPos":9051,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nx x' : ι\nhx' : x ∈ s\nhx'' : ¬x' ∈ s\nh : f' { val := x, property := hx' } = f'' { val := x', property := hx'' }\n⊢ f' { val := x, property := hx' } ∈ Finset.biUnion s t"],"goalsAfter":[],"content":"apply f'_mem_biUnion x"},{"tailPos":9073,"headPos":8972,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }"],"goalsAfter":[],"content":"intro x x' hx' hx'' h\n    apply f''_not_mem_biUnion x' hx''\n    rw [← h]\n    apply f'_mem_biUnion x"},{"tailPos":8967,"headPos":8965,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }"],"goalsAfter":[],"content":"by"},{"tailPos":9073,"headPos":8965,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }"],"goalsAfter":[],"content":"by\n    intro x x' hx' hx'' h\n    apply f''_not_mem_biUnion x' hx''\n    rw [← h]\n    apply f'_mem_biUnion x"},{"tailPos":9073,"headPos":8843,"goalsBefore":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have im_disj :\n      ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s), f' ⟨x', hx'⟩ ≠ f'' ⟨x'', hx''⟩ := by\n    intro x x' hx' hx'' h\n    apply f''_not_mem_biUnion x' hx''\n    rw [← h]\n    apply f'_mem_biUnion x"},{"tailPos":9158,"headPos":9076,"goalsBefore":["case intro.intro.intro.intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ Function.Injective fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }","case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"content":"refine' ⟨fun x => if h : x ∈ s then f' ⟨x, h⟩ else f'' ⟨x, h⟩, _, _⟩"},{"tailPos":9163,"headPos":9161,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ Function.Injective fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }","case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ Function.Injective fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }"],"content":"·"},{"tailPos":9219,"headPos":9164,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ Function.Injective fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }"],"goalsAfter":[],"content":"refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)"},{"tailPos":9219,"headPos":9161,"goalsBefore":["case intro.intro.intro.intro.refine'_1\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ Function.Injective fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }","case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"content":"· refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)"},{"tailPos":9224,"headPos":9222,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"content":"·"},{"tailPos":9232,"headPos":9225,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\n⊢ (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"content":"intro x"},{"tailPos":9259,"headPos":9237,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\n⊢ (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\n⊢ (if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) ∈ t x"],"content":"simp only [of_eq_true]"},{"tailPos":9280,"headPos":9264,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\n⊢ (if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x","case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"content":"split_ifs with h"},{"tailPos":9284,"headPos":9281,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x","case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x","case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"content":"<;>"},{"tailPos":9289,"headPos":9285,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x"],"content":"simp only"},{"tailPos":9289,"headPos":9285,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"content":"simp only"},{"tailPos":9289,"headPos":9264,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\n⊢ (if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x","case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"content":"split_ifs with h <;> simp"},{"tailPos":9296,"headPos":9294,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x","case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x"],"content":"·"},{"tailPos":9318,"headPos":9297,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x"],"goalsAfter":[],"content":"exact hsf' ⟨x, h⟩"},{"tailPos":9318,"headPos":9294,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inl\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : x ∈ s\n⊢ f' { val := x, property := h } ∈ t x","case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"content":"· exact hsf' ⟨x, h⟩"},{"tailPos":9325,"headPos":9323,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"content":"·"},{"tailPos":9367,"headPos":9326,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":[],"content":"exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)"},{"tailPos":9367,"headPos":9323,"goalsBefore":["case intro.intro.intro.intro.refine'_2.inr\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\nx : ι\nh : ¬x ∈ s\n⊢ f'' { val := x, property := h } ∈ t x"],"goalsAfter":[],"content":"· exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)"},{"tailPos":9367,"headPos":9225,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":[],"content":"intro x\n    simp only [of_eq_true]\n    split_ifs with h <;> simp\n    · exact hsf' ⟨x, h⟩\n    · exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)"},{"tailPos":9367,"headPos":9222,"goalsBefore":["case intro.intro.intro.intro.refine'_2\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = Nat.succ n\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\nthis : DecidableEq ι\ncard_ι'_le : Fintype.card { x // x ∈ s } ≤ n\nt' : { x // x ∈ s } → Finset α := fun x' => t ↑x'\nf' : { x // x ∈ s } → α\nhf' : Function.Injective f'\nhsf' : ∀ (x : { x // x ∈ s }), f' x ∈ t' x\nι'' : Set ι := ↑sᶜ\nt'' : ↑ι'' → Finset α := fun a'' => t ↑a'' \\ Finset.biUnion s t\ncard_ι''_le : Fintype.card ↑ι'' ≤ n\nf'' : ↑ι'' → α\nhf'' : Function.Injective f''\nhsf'' : ∀ (x : ↑ι''), f'' x ∈ t'' x\nf'_mem_biUnion : ∀ (x' : ι) (hx' : x' ∈ s), f' { val := x', property := hx' } ∈ Finset.biUnion s t\nf''_not_mem_biUnion : ∀ (x'' : ι) (hx'' : ¬x'' ∈ s), ¬f'' { val := x'', property := hx'' } ∈ Finset.biUnion s t\nim_disj :\n  ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s),\n    f' { val := x', property := hx' } ≠ f'' { val := x'', property := hx'' }\n⊢ ∀ (x : ι), (fun x => if h : x ∈ s then f' { val := x, property := h } else f'' { val := x, property := h }) x ∈ t x"],"goalsAfter":[],"content":"· intro x\n    simp only [of_eq_true]\n    split_ifs with h <;> simp\n    · exact hsf' ⟨x, h⟩\n    · exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)"},{"tailPos":9367,"headPos":7598,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"haveI := Classical.decEq ι\n  -- Restrict to `s`\n  rw [Nat.add_one] at hn\n  have card_ι'_le : Fintype.card s ≤ n := by\n    apply Nat.le_of_lt_succ\n    calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn\n  let t' : s → Finset α := fun x' => t x'\n  rcases ih t' card_ι'_le (hall_cond_of_restrict ht) with ⟨f', hf', hsf'⟩\n  -- Restrict to `sᶜ` in the domain and `(s.biUnion t)ᶜ` in the codomain.\n  set ι'' := (s : Set ι)ᶜ\n  let t'' : ι'' → Finset α := fun a'' => t a'' \\ s.biUnion t\n  have card_ι''_le : Fintype.card ι'' ≤ n := by\n    simp_rw [← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]\n  rcases ih t'' card_ι''_le (hall_cond_of_compl hus ht) with ⟨f'', hf'', hsf''⟩\n  -- Put them together\n  have f'_mem_biUnion : ∀ (x') (hx' : x' ∈ s), f' ⟨x', hx'⟩ ∈ s.biUnion t := by\n    intro x' hx'\n    rw [mem_biUnion]\n    exact ⟨x', hx', hsf' _⟩\n  have f''_not_mem_biUnion : ∀ (x'') (hx'' : ¬x'' ∈ s), ¬f'' ⟨x'', hx''⟩ ∈ s.biUnion t := by\n    intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2\n  have im_disj :\n      ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s), f' ⟨x', hx'⟩ ≠ f'' ⟨x'', hx''⟩ := by\n    intro x x' hx' hx'' h\n    apply f''_not_mem_biUnion x' hx''\n    rw [← h]\n    apply f'_mem_biUnion x\n  refine' ⟨fun x => if h : x ∈ s then f' ⟨x, h⟩ else f'' ⟨x, h⟩, _, _⟩\n  · refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)\n  · intro x\n    simp only [of_eq_true]\n    split_ifs with h <;> simp\n    · exact hsf' ⟨x, h⟩\n    · exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)"},{"tailPos":7595,"headPos":7593,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by"},{"tailPos":9367,"headPos":7593,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Fintype ι\nn : ℕ\nhn : Fintype.card ι = n + 1\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nih :\n  ∀ {ι' : Type u} [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nhs : Finset.Nonempty s\nhns : s ≠ univ\nhus : card s = card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by\n  haveI := Classical.decEq ι\n  -- Restrict to `s`\n  rw [Nat.add_one] at hn\n  have card_ι'_le : Fintype.card s ≤ n := by\n    apply Nat.le_of_lt_succ\n    calc\n      Fintype.card s = s.card := Fintype.card_coe _\n      _ < Fintype.card ι := (card_lt_iff_ne_univ _).mpr hns\n      _ = n.succ := hn\n  let t' : s → Finset α := fun x' => t x'\n  rcases ih t' card_ι'_le (hall_cond_of_restrict ht) with ⟨f', hf', hsf'⟩\n  -- Restrict to `sᶜ` in the domain and `(s.biUnion t)ᶜ` in the codomain.\n  set ι'' := (s : Set ι)ᶜ\n  let t'' : ι'' → Finset α := fun a'' => t a'' \\ s.biUnion t\n  have card_ι''_le : Fintype.card ι'' ≤ n := by\n    simp_rw [← Nat.lt_succ_iff, ← hn, ← Finset.coe_compl, coe_sort_coe]\n    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]\n  rcases ih t'' card_ι''_le (hall_cond_of_compl hus ht) with ⟨f'', hf'', hsf''⟩\n  -- Put them together\n  have f'_mem_biUnion : ∀ (x') (hx' : x' ∈ s), f' ⟨x', hx'⟩ ∈ s.biUnion t := by\n    intro x' hx'\n    rw [mem_biUnion]\n    exact ⟨x', hx', hsf' _⟩\n  have f''_not_mem_biUnion : ∀ (x'') (hx'' : ¬x'' ∈ s), ¬f'' ⟨x'', hx''⟩ ∈ s.biUnion t := by\n    intro x'' hx''\n    have h := hsf'' ⟨x'', hx''⟩\n    rw [mem_sdiff] at h\n    exact h.2\n  have im_disj :\n      ∀ (x' x'' : ι) (hx' : x' ∈ s) (hx'' : ¬x'' ∈ s), f' ⟨x', hx'⟩ ≠ f'' ⟨x'', hx''⟩ := by\n    intro x x' hx' hx'' h\n    apply f''_not_mem_biUnion x' hx''\n    rw [← h]\n    apply f'_mem_biUnion x\n  refine' ⟨fun x => if h : x ∈ s then f' ⟨x, h⟩ else f'' ⟨x, h⟩, _, _⟩\n  · refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)\n  · intro x\n    simp only [of_eq_true]\n    split_ifs with h <;> simp\n    · exact hsf' ⟨x, h⟩\n    · exact sdiff_subset _ _ (hsf'' ⟨x, h⟩)"},{"tailPos":9892,"headPos":9867,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"cases nonempty_fintype ι"},{"tailPos":9982,"headPos":9895,"goalsBefore":["case intro\nι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nn : ℕ\nih :\n  ∀ (m : ℕ),\n    m < n →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nhn : Fintype.card ι = n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"induction' hn : Fintype.card ι using Nat.strong_induction_on with n ih generalizing ι"},{"tailPos":10006,"headPos":9985,"goalsBefore":["case intro.h\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nn : ℕ\nih :\n  ∀ (m : ℕ),\n    m < n →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nhn : Fintype.card ι = n\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rcases n with (_ | _)"},{"tailPos":10011,"headPos":10009,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"·"},{"tailPos":10040,"headPos":10016,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : IsEmpty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"Fintype.card_eq_zero_iff"},{"tailPos":10041,"headPos":10040,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : IsEmpty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : IsEmpty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"]"},{"tailPos":10047,"headPos":10012,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : IsEmpty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rw [Fintype.card_eq_zero_iff] at hn"},{"tailPos":10101,"headPos":10052,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : IsEmpty ι\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩"},{"tailPos":10101,"headPos":10012,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"rw [Fintype.card_eq_zero_iff] at hn\n    exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩"},{"tailPos":10101,"headPos":10009,"goalsBefore":["case intro.h.zero\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nih :\n  ∀ (m : ℕ),\n    m < Nat.zero →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.zero\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"· rw [Fintype.card_eq_zero_iff] at hn\n    exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩"},{"tailPos":10106,"headPos":10104,"goalsBefore":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"·"},{"tailPos":10379,"headPos":10357,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ ?m.46478 ι' t' →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x"],"goalsAfter":["ι✝ : Type u\nα : Type v\ninst✝³ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝² : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝¹ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nι' : Type u\ninst✝ : Fintype ι'\nt'✝ : ι' → Finset α\nhι' : Fintype.card ι' ≤ ?m.46478 ι' t'✝\nht' : ∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t'✝)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t'✝ x"],"content":"intro ι' _ _ hι' ht'"},{"tailPos":10431,"headPos":10386,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝³ : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝² : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝¹ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nι' : Type u\ninst✝ : Fintype ι'\nt'✝ : ι' → Finset α\nhι' : Fintype.card ι' ≤ ?m.46478 ι' t'✝\nht' : ∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t'✝)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t'✝ x"],"goalsAfter":[],"content":"exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl"},{"tailPos":10431,"headPos":10357,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ ?m.46478 ι' t' →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x"],"goalsAfter":[],"content":"intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl"},{"tailPos":10350,"headPos":10348,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ ?m.46478 ι' t' →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x"],"goalsAfter":[],"content":"by"},{"tailPos":10431,"headPos":10348,"goalsBefore":["ι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ ?m.46478 ι' t' →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x"],"goalsAfter":[],"content":"by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl"},{"tailPos":10431,"headPos":10107,"goalsBefore":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"have ih' : ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ _ →\n        (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →\n        ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x := by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl"},{"tailPos":10525,"headPos":10436,"goalsBefore":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case pos\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"by_cases h : ∀ s : Finset ι, s.Nonempty → s ≠ univ → s.card < (s.biUnion t).card"},{"tailPos":10532,"headPos":10530,"goalsBefore":["case pos\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case pos\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"·"},{"tailPos":10597,"headPos":10533,"goalsBefore":["case pos\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"refine' hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h"},{"tailPos":10597,"headPos":10530,"goalsBefore":["case pos\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"· refine' hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h"},{"tailPos":10604,"headPos":10602,"goalsBefore":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"·"},{"tailPos":10619,"headPos":10605,"goalsBefore":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∃ s, Finset.Nonempty s ∧ s ≠ univ ∧ card (Finset.biUnion s t) ≤ card s\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"push_neg  at h"},{"tailPos":10662,"headPos":10626,"goalsBefore":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ∃ s, Finset.Nonempty s ∧ s ≠ univ ∧ card (Finset.biUnion s t) ≤ card s\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case neg.intro.intro.intro\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nsne : Finset.Nonempty s\nsnu : s ≠ univ\nsle : card (Finset.biUnion s t) ≤ card s\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"rcases h with ⟨s, sne, snu, sle⟩"},{"tailPos":10776,"headPos":10669,"goalsBefore":["case neg.intro.intro.intro\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\ns : Finset ι\nsne : Finset.Nonempty s\nsnu : s ≠ univ\nsle : card (Finset.biUnion s t) ≤ card s\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":10776,"headPos":10605,"goalsBefore":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":10776,"headPos":10602,"goalsBefore":["case neg\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\nih' :\n  ∀ (ι' : Type u) [inst : Fintype ι'] (t' : ι' → Finset α),\n    Fintype.card ι' ≤ n✝ →\n      (∀ (s' : Finset ι'), card s' ≤ card (Finset.biUnion s' t')) → ∃ f, Function.Injective f ∧ ∀ (x : ι'), f x ∈ t' x\nh : ¬∀ (s : Finset ι), Finset.Nonempty s → s ≠ univ → card s < card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"· push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":10776,"headPos":10107,"goalsBefore":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"have ih' : ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ _ →\n        (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →\n        ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x := by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl\n    by_cases h : ∀ s : Finset ι, s.Nonempty → s ≠ univ → s.card < (s.biUnion t).card\n    · refine' hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h\n    · push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":10776,"headPos":10104,"goalsBefore":["case intro.h.succ\nι✝ : Type u\nα : Type v\ninst✝² : DecidableEq α\nt✝ : ι✝ → Finset α\ninst✝¹ : Finite ι✝\nht✝ : ∀ (s : Finset ι✝), card s ≤ card (Finset.biUnion s t✝)\nval✝¹ : Fintype ι✝\nx✝ : ℕ\nhn✝ : Fintype.card ι✝ = x✝\nι : Type u\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\nval✝ : Fintype ι\nn✝ : ℕ\nih :\n  ∀ (m : ℕ),\n    m < Nat.succ n✝ →\n      ∀ {ι : Type u} {t : ι → Finset α} [inst : Finite ι],\n        (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) →\n          ∀ (val : Fintype ι), Fintype.card ι = m → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x\nhn : Fintype.card ι = Nat.succ n✝\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"· have ih' : ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ _ →\n        (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →\n        ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x := by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl\n    by_cases h : ∀ s : Finset ι, s.Nonempty → s ≠ univ → s.card < (s.biUnion t).card\n    · refine' hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h\n    · push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":10776,"headPos":9867,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"cases nonempty_fintype ι\n  induction' hn : Fintype.card ι using Nat.strong_induction_on with n ih generalizing ι\n  rcases n with (_ | _)\n  · rw [Fintype.card_eq_zero_iff] at hn\n    exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩\n  · have ih' : ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ _ →\n        (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →\n        ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x := by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl\n    by_cases h : ∀ s : Finset ι, s.Nonempty → s ≠ univ → s.card < (s.biUnion t).card\n    · refine' hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h\n    · push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":9864,"headPos":9862,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by"},{"tailPos":10776,"headPos":9862,"goalsBefore":["ι : Type u\nα : Type v\ninst✝¹ : DecidableEq α\nt : ι → Finset α\ninst✝ : Finite ι\nht : ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)\n⊢ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by\n  cases nonempty_fintype ι\n  induction' hn : Fintype.card ι using Nat.strong_induction_on with n ih generalizing ι\n  rcases n with (_ | _)\n  · rw [Fintype.card_eq_zero_iff] at hn\n    exact ⟨isEmptyElim, isEmptyElim, isEmptyElim⟩\n  · have ih' : ∀ (ι' : Type u) [Fintype ι'] (t' : ι' → Finset α), Fintype.card ι' ≤ _ →\n        (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →\n        ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x := by\n      intro ι' _ _ hι' ht'\n      exact ih _ (Nat.lt_succ_of_le hι') ht' _ rfl\n    by_cases h : ∀ s : Finset ι, s.Nonempty → s ≠ univ → s.card < (s.biUnion t).card\n    · refine' hall_hard_inductive_step_A hn ht (@fun ι' => ih' ι') h\n    · push_neg  at h\n      rcases h with ⟨s, sne, snu, sle⟩\n      exact hall_hard_inductive_step_B hn ht (@fun ι' => ih' ι')\n        s sne snu (Nat.le_antisymm (ht _) sle)"},{"tailPos":11568,"headPos":11557,"goalsBefore":["ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":["case mp\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"content":"constructor"},{"tailPos":11573,"headPos":11571,"goalsBefore":["case mp\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mp\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"content":"·"},{"tailPos":11619,"headPos":11574,"goalsBefore":["case mp\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"exact HallMarriageTheorem.hall_hard_inductive"},{"tailPos":11619,"headPos":11571,"goalsBefore":["case mp\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) → ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x","case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"content":"· exact HallMarriageTheorem.hall_hard_inductive"},{"tailPos":11624,"headPos":11622,"goalsBefore":["case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"content":"·"},{"tailPos":11655,"headPos":11625,"goalsBefore":["case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card s ≤ card (Finset.biUnion s t)"],"content":"rintro ⟨f, hf₁, hf₂⟩ s"},{"tailPos":11699,"headPos":11664,"goalsBefore":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"content":"← card_image_of_injective s hf₁"},{"tailPos":11700,"headPos":11699,"goalsBefore":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"content":"]"},{"tailPos":11700,"headPos":11660,"goalsBefore":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card s ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"content":"rw [← card_image_of_injective s hf₁]"},{"tailPos":11728,"headPos":11705,"goalsBefore":["case mpr.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ card (image f s) ≤ card (Finset.biUnion s t)"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ image f s ⊆ Finset.biUnion s t"],"content":"apply card_le_of_subset"},{"tailPos":11738,"headPos":11733,"goalsBefore":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\n⊢ image f s ⊆ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ a✝ ∈ image f s → a✝ ∈ Finset.biUnion s t"],"content":"intro"},{"tailPos":11757,"headPos":11747,"goalsBefore":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ a✝ ∈ image f s → a✝ ∈ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → a✝ ∈ Finset.biUnion s t"],"content":"mem_image,"},{"tailPos":11769,"headPos":11758,"goalsBefore":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → a✝ ∈ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"content":"mem_biUnion"},{"tailPos":11770,"headPos":11769,"goalsBefore":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"content":"]"},{"tailPos":11770,"headPos":11743,"goalsBefore":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ a✝ ∈ image f s → a✝ ∈ Finset.biUnion s t"],"goalsAfter":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"content":"rw [mem_image, mem_biUnion]"},{"tailPos":11798,"headPos":11775,"goalsBefore":["case mpr.intro.intro.a\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\na✝ : α\n⊢ (∃ a, a ∈ s ∧ f a = a✝) → ∃ a, a ∈ s ∧ a✝ ∈ t a"],"goalsAfter":["case mpr.intro.intro.a.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\nx : ι\nhx : x ∈ s\n⊢ ∃ a, a ∈ s ∧ f x ∈ t a"],"content":"rintro ⟨x, hx, rfl⟩"},{"tailPos":11829,"headPos":11803,"goalsBefore":["case mpr.intro.intro.a.intro.intro\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\nf : ι → α\nhf₁ : Function.Injective f\nhf₂ : ∀ (x : ι), f x ∈ t x\ns : Finset ι\nx : ι\nhx : x ∈ s\n⊢ ∃ a, a ∈ s ∧ f x ∈ t a"],"goalsAfter":[],"content":"exact ⟨x, hx, hf₂ x⟩"},{"tailPos":11829,"headPos":11625,"goalsBefore":["case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":[],"content":"rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← card_image_of_injective s hf₁]\n    apply card_le_of_subset\n    intro\n    rw [mem_image, mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":11829,"headPos":11622,"goalsBefore":["case mpr\nι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x) → ∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)"],"goalsAfter":[],"content":"· rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← card_image_of_injective s hf₁]\n    apply card_le_of_subset\n    intro\n    rw [mem_image, mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":11829,"headPos":11557,"goalsBefore":["ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"constructor\n  · exact HallMarriageTheorem.hall_hard_inductive\n  · rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← card_image_of_injective s hf₁]\n    apply card_le_of_subset\n    intro\n    rw [mem_image, mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"},{"tailPos":11554,"headPos":11552,"goalsBefore":["ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by"},{"tailPos":11829,"headPos":11552,"goalsBefore":["ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite ι\ninst✝ : DecidableEq α\nt : ι → Finset α\n⊢ (∀ (s : Finset ι), card s ≤ card (Finset.biUnion s t)) ↔ ∃ f, Function.Injective f ∧ ∀ (x : ι), f x ∈ t x"],"goalsAfter":[],"content":"by\n  constructor\n  · exact HallMarriageTheorem.hall_hard_inductive\n  · rintro ⟨f, hf₁, hf₂⟩ s\n    rw [← card_image_of_injective s hf₁]\n    apply card_le_of_subset\n    intro\n    rw [mem_image, mem_biUnion]\n    rintro ⟨x, hx, rfl⟩\n    exact ⟨x, hx, hf₂ x⟩"}]
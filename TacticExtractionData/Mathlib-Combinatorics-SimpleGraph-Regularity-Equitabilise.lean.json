[{"tailPos":2401,"headPos":2363,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = 0 ∨ card x = 0 + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ 0) ∧\n        card (filter (fun i => card i = 0 + 1) Q.parts) = b","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nm_pos : m > 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain rfl | m_pos := m.eq_zero_or_pos"},{"tailPos":2406,"headPos":2404,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = 0 ∨ card x = 0 + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ 0) ∧\n        card (filter (fun i => card i = 0 + 1) Q.parts) = b","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nm_pos : m > 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = 0 ∨ card x = 0 + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ 0) ∧\n        card (filter (fun i => card i = 0 + 1) Q.parts) = b"],"content":"·"},{"tailPos":2430,"headPos":2426,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ ⊥.parts → card x = 0 ∨ card x = 0 + 1"],"goalsAfter":[],"content":"simp only [parts_bot, mem_map, Function.Embedding.coeFn_mk, card_eq_zero, zero_add, forall_exists_index,\n  and_imp, forall_apply_eq_imp_iff₂, singleton_ne_empty, card_singleton, or_true, implies_true]"},{"tailPos":2425,"headPos":2423,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ ⊥.parts → card x = 0 ∨ card x = 0 + 1"],"goalsAfter":[],"content":"by"},{"tailPos":2430,"headPos":2423,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ ⊥.parts → card x = 0 ∨ card x = 0 + 1"],"goalsAfter":[],"content":"by simp"},{"tailPos":2457,"headPos":2438,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ card (filter (fun i => card i = 0 + 1) ⊥.parts) = b"],"goalsAfter":[],"content":"simpa only [zero_add, parts_bot, mem_map, Function.Embedding.coeFn_mk, forall_exists_index, and_imp,\n  forall_apply_eq_imp_iff₂, card_singleton, implies_true, filter_true_of_mem, card_map, mul_zero, mul_one] using hs.symm"},{"tailPos":2437,"headPos":2435,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ card (filter (fun i => card i = 0 + 1) ⊥.parts) = b"],"goalsAfter":[],"content":"by"},{"tailPos":2457,"headPos":2435,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ card (filter (fun i => card i = 0 + 1) ⊥.parts) = b"],"goalsAfter":[],"content":"by simpa using hs.symm"},{"tailPos":2460,"headPos":2407,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = 0 ∨ card x = 0 + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ 0) ∧\n        card (filter (fun i => card i = 0 + 1) Q.parts) = b"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) ⊥.parts) id) ≤ 0"],"content":"refine' ⟨⊥, by simp, _, by simpa using hs.symm⟩"},{"tailPos":2604,"headPos":2465,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) ⊥.parts) id) ≤ 0"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ P.parts → ∀ ⦃x_1 : α⦄, x_1 ∈ x → ∃ a, a ∈ ⊥.parts ∧ (∀ ⦃x_2 : α⦄, x_2 ∈ a → x_2 ∈ x) ∧ x_1 ∈ a"],"content":"simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,\n      sdiff_eq_empty_iff_subset, subset_iff]"},{"tailPos":2727,"headPos":2609,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∀ (x : Finset α), x ∈ P.parts → ∀ ⦃x_1 : α⦄, x_1 ∈ x → ∃ a, a ∈ ⊥.parts ∧ (∀ ⦃x_2 : α⦄, x_2 ∈ a → x_2 ∈ x) ∧ x_1 ∈ a"],"goalsAfter":[],"content":"exact fun x hx a ha =>\n      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩"},{"tailPos":2727,"headPos":2407,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = 0 ∨ card x = 0 + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ 0) ∧\n        card (filter (fun i => card i = 0 + 1) Q.parts) = b"],"goalsAfter":[],"content":"refine' ⟨⊥, by simp, _, by simpa using hs.symm⟩\n    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,\n      sdiff_eq_empty_iff_subset, subset_iff]\n    exact fun x hx a ha =>\n      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩"},{"tailPos":2727,"headPos":2404,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nn a b : ℕ\nP : Finpartition s\nhs : a * 0 + b * (0 + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = 0 ∨ card x = 0 + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ 0) ∧\n        card (filter (fun i => card i = 0 + 1) Q.parts) = b","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nm_pos : m > 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nm_pos : m > 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"· refine' ⟨⊥, by simp, _, by simpa using hs.symm⟩\n    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,\n      sdiff_eq_empty_iff_subset, subset_iff]\n    exact fun x hx a ha =>\n      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩"},{"tailPos":2853,"headPos":2785,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nm_pos : m > 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case inr.H\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"induction' s using Finset.strongInduction with s ih generalizing a b"},{"tailPos":2959,"headPos":2929,"goalsBefore":["case inr.H\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a = 0 ∧ b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b","case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"by_cases hab : a = 0 ∧ b = 0"},{"tailPos":2964,"headPos":2962,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a = 0 ∧ b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b","case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a = 0 ∧ b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"·"},{"tailPos":3059,"headPos":2965,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a = 0 ∧ b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhab : a = 0 ∧ b = 0\nhs : s = ∅\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs"},{"tailPos":3072,"headPos":3064,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhab : a = 0 ∧ b = 0\nhs : s = ∅\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"subst hs"},{"tailPos":3230,"headPos":3151,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P"},{"tailPos":3273,"headPos":3269,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∀ (x : Finset α), x ∈ (Finpartition.empty (Finset α)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":[],"content":"simp only [empty_parts, not_mem_empty, IsEmpty.forall_iff, forall_const]"},{"tailPos":3268,"headPos":3266,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∀ (x : Finset α), x ∈ (Finpartition.empty (Finset α)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":[],"content":"by"},{"tailPos":3273,"headPos":3266,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∀ (x : Finset α), x ∈ (Finpartition.empty (Finset α)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":[],"content":"by simp"},{"tailPos":3289,"headPos":3278,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) (Finpartition.empty (Finset α)).parts) id) ≤ m"],"goalsAfter":[],"content":"simp [this]"},{"tailPos":3277,"headPos":3275,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) (Finpartition.empty (Finset α)).parts) id) ≤ m"],"goalsAfter":[],"content":"by"},{"tailPos":3289,"headPos":3275,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) (Finpartition.empty (Finset α)).parts) id) ≤ m"],"goalsAfter":[],"content":"by simp [this]"},{"tailPos":3306,"headPos":3294,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ card (filter (fun i => card i = m + 1) (Finpartition.empty (Finset α)).parts) = b"],"goalsAfter":[],"content":"simp [hab.2]"},{"tailPos":3293,"headPos":3291,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ card (filter (fun i => card i = m + 1) (Finpartition.empty (Finset α)).parts) = b"],"goalsAfter":[],"content":"by"},{"tailPos":3306,"headPos":3291,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ card (filter (fun i => card i = m + 1) (Finpartition.empty (Finset α)).parts) = b"],"goalsAfter":[],"content":"by simp [hab.2]"},{"tailPos":3309,"headPos":3235,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s\nhs : a✝ * m + b✝ * (m + 1) = card s\nm_pos : m > 0\na b : ℕ\nhab : a = 0 ∧ b = 0\nih :\n  ∀ (t : Finset α),\n    t ⊂ ∅ →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\nP : Finpartition ∅\nthis : P = Finpartition.empty (Finset α)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":[],"content":"exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩"},{"tailPos":3309,"headPos":2965,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a = 0 ∧ b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":[],"content":"simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs\n    subst hs\n    -- Porting note: to synthesize `Finpartition ∅`, `have` is required\n    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P\n    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩"},{"tailPos":3309,"headPos":2962,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a = 0 ∧ b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b","case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs\n    subst hs\n    -- Porting note: to synthesize `Finpartition ∅`, `have` is required\n    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P\n    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩"},{"tailPos":3321,"headPos":3312,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"simp_rw ["},{"tailPos":3332,"headPos":3321,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬a = 0 ∨ ¬b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"not_and_or,"},{"tailPos":3344,"headPos":3333,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬a = 0 ∨ ¬b = 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a ≠ 0 ∨ b ≠ 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"← Ne.def,"},{"tailPos":3364,"headPos":3345,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : a ≠ 0 ∨ b ≠ 0\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"← pos_iff_ne_zero"},{"tailPos":3372,"headPos":3312,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : ¬(a = 0 ∧ b = 0)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"simp_rw [not_and_or, ← Ne.def, ← pos_iff_ne_zero] at hab"},{"tailPos":3465,"headPos":3422,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"set n := if 0 < a then m else m + 1 with hn"},{"tailPos":3692,"headPos":3689,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ 0 < n ∧\n    n ≤ m + 1 ∧\n      n ≤ a * m + b * (m + 1) ∧ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - if 0 < a then m else m + 1"],"content":"hn,"},{"tailPos":3699,"headPos":3693,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - if 0 < a then m else m + 1"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) =\n          a * m + b * (m + 1) - if 0 < a then m else m + 1"],"content":"← hs"},{"tailPos":3700,"headPos":3699,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) =\n          a * m + b * (m + 1) - if 0 < a then m else m + 1"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) =\n          a * m + b * (m + 1) - if 0 < a then m else m + 1"],"content":"]"},{"tailPos":3700,"headPos":3685,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ 0 < n ∧\n    n ≤ m + 1 ∧\n      n ≤ a * m + b * (m + 1) ∧ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) =\n          a * m + b * (m + 1) - if 0 < a then m else m + 1"],"content":"rw [hn, ← hs]"},{"tailPos":3721,"headPos":3705,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) =\n          a * m + b * (m + 1) - if 0 < a then m else m + 1"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ (a - 1) * m + b * (m + 1) = a * m + b * (m + 1) - m","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧ m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b - 1) * (m + 1) = a * m + b * (m + 1) - (m + 1)"],"content":"split_ifs with h"},{"tailPos":3725,"headPos":3722,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ (a - 1) * m + b * (m + 1) = a * m + b * (m + 1) - m","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧ m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b - 1) * (m + 1) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ (a - 1) * m + b * (m + 1) = a * m + b * (m + 1) - m","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧ m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b - 1) * (m + 1) = a * m + b * (m + 1) - (m + 1)"],"content":"<;>"},{"tailPos":3739,"headPos":3730,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ (a - 1) * m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - 1 * m + b * (m + 1) = a * m + b * (m + 1) - m"],"content":"tsub_mul,"},{"tailPos":3747,"headPos":3740,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - 1 * m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"content":"one_mul"},{"tailPos":3748,"headPos":3747,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"content":"]"},{"tailPos":3748,"headPos":3726,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ (a - 1) * m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"content":"rw [tsub_mul, one_mul]"},{"tailPos":3739,"headPos":3730,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧ m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b - 1) * (m + 1) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - 1 * (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"tsub_mul,"},{"tailPos":3747,"headPos":3740,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - 1 * (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"one_mul"},{"tailPos":3748,"headPos":3747,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"]"},{"tailPos":3748,"headPos":3726,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧ m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b - 1) * (m + 1) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"rw [tsub_mul, one_mul]"},{"tailPos":3748,"headPos":3705,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ (0 < if 0 < a then m else m + 1) ∧\n    (if 0 < a then m else m + 1) ≤ m + 1 ∧\n      (if 0 < a then m else m + 1) ≤ a * m + b * (m + 1) ∧\n        (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) =\n          a * m + b * (m + 1) - if 0 < a then m else m + 1"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"split_ifs with h <;> rw [tsub_mul, one_mul]"},{"tailPos":3755,"headPos":3753,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"content":"·"},{"tailPos":3836,"headPos":3756,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"content":"refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩"},{"tailPos":3890,"headPos":3847,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ a * m + b * (m + 1) - m = a * m + b * (m + 1) - m"],"content":"tsub_add_eq_add_tsub (le_mul_of_pos_left h)"},{"tailPos":3891,"headPos":3890,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ a * m + b * (m + 1) - m = a * m + b * (m + 1) - m"],"goalsAfter":[],"content":"]"},{"tailPos":3891,"headPos":3843,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":[],"content":"rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]"},{"tailPos":3891,"headPos":3756,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m"],"goalsAfter":[],"content":"refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]"},{"tailPos":3891,"headPos":3753,"goalsBefore":["case inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : 0 < a\n⊢ 0 < m ∧ m ≤ m + 1 ∧ m ≤ a * m + b * (m + 1) ∧ a * m - m + b * (m + 1) = a * m + b * (m + 1) - m","case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"· refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]"},{"tailPos":3898,"headPos":3896,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"·"},{"tailPos":4001,"headPos":3899,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"content":"refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩"},{"tailPos":4091,"headPos":4012,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ a * m + b * (m + 1) - (m + 1) = a * m + b * (m + 1) - (m + 1)"],"content":"← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)"},{"tailPos":4092,"headPos":4091,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ a * m + b * (m + 1) - (m + 1) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":[],"content":"]"},{"tailPos":4092,"headPos":4008,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":[],"content":"rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]"},{"tailPos":4092,"headPos":3899,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":[],"content":"refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]"},{"tailPos":4092,"headPos":3896,"goalsBefore":["case inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nh : ¬0 < a\n⊢ 0 < m + 1 ∧\n    m + 1 ≤ m + 1 ∧ m + 1 ≤ a * m + b * (m + 1) ∧ a * m + (b * (m + 1) - (m + 1)) = a * m + b * (m + 1) - (m + 1)"],"goalsAfter":[],"content":"· refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]"},{"tailPos":4092,"headPos":3685,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ 0 < n ∧\n    n ≤ m + 1 ∧\n      n ≤ a * m + b * (m + 1) ∧ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":[],"content":"rw [hn, ← hs]\n    split_ifs with h <;> rw [tsub_mul, one_mul]\n    · refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]\n    · refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]"},{"tailPos":3680,"headPos":3678,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ 0 < n ∧\n    n ≤ m + 1 ∧\n      n ≤ a * m + b * (m + 1) ∧ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":[],"content":"by"},{"tailPos":4092,"headPos":3678,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ 0 < n ∧\n    n ≤ m + 1 ∧\n      n ≤ a * m + b * (m + 1) ∧ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":[],"content":"by\n    rw [hn, ← hs]\n    split_ifs with h <;> rw [tsub_mul, one_mul]\n    · refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]\n    · refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]"},{"tailPos":4092,"headPos":3498,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧\n      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by\n    rw [hn, ← hs]\n    split_ifs with h <;> rw [tsub_mul, one_mul]\n    · refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]\n    · refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]"},{"tailPos":4662,"headPos":4616,"goalsBefore":["case neg.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b","case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ¬∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"by_cases h : ∀ u ∈ P.parts, card u < m + 1"},{"tailPos":4667,"headPos":4665,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b","case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ¬∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"·"},{"tailPos":4738,"headPos":4668,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain ⟨t, hts, htn⟩ := exists_smaller_set s n (hn₂.trans_eq hs)"},{"tailPos":4788,"headPos":4775,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ 0 < card t"],"content":"← card_pos,"},{"tailPos":4792,"headPos":4789,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ 0 < card t"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ 0 < n"],"content":"htn"},{"tailPos":4793,"headPos":4792,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ 0 < n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ 0 < n"],"content":"]"},{"tailPos":4793,"headPos":4770,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":[],"content":"rwa [← card_pos, htn]"},{"tailPos":4769,"headPos":4767,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":[],"content":"by"},{"tailPos":4793,"headPos":4767,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":[],"content":"by rwa [← card_pos, htn]"},{"tailPos":4793,"headPos":4743,"goalsBefore":["case pos.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"have ht : t.Nonempty := by rwa [← card_pos, htn]"},{"tailPos":4927,"headPos":4902,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - card t"],"content":"card_sdiff ‹t ⊆ s›,"},{"tailPos":4932,"headPos":4928,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - card t"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"content":"htn,"},{"tailPos":4938,"headPos":4933,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ card s - n = card s - n"],"content":"hn₃"},{"tailPos":4939,"headPos":4938,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ card s - n = card s - n"],"goalsAfter":[],"content":"]"},{"tailPos":4939,"headPos":4898,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":[],"content":"rw [card_sdiff ‹t ⊆ s›, htn, hn₃]"},{"tailPos":4891,"headPos":4889,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":[],"content":"by"},{"tailPos":4939,"headPos":4889,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":[],"content":"by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]"},{"tailPos":4939,"headPos":4798,"goalsBefore":["case pos.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]"},{"tailPos":5117,"headPos":4944,"goalsBefore":["case pos.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain ⟨R, hR₁, _, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)\n        (if 0 < a then b else b - 1) (P.avoid t) hcard"},{"tailPos":5203,"headPos":5122,"goalsBefore":["case pos.intro.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1","case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _⟩"},{"tailPos":5210,"headPos":5208,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1","case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1"],"content":"·"},{"tailPos":5294,"headPos":5211,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ (if 0 < a then m else m + 1) = m ∨ (if 0 < a then m else m + 1) = m + 1"],"content":"simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]"},{"tailPos":5325,"headPos":5301,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ (if 0 < a then m else m + 1) = m ∨ (if 0 < a then m else m + 1) = m + 1"],"goalsAfter":[],"content":"exact ite_eq_or_eq _ _ _"},{"tailPos":5325,"headPos":5211,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":[],"content":"simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _"},{"tailPos":5325,"headPos":5208,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1","case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _"},{"tailPos":5332,"headPos":5330,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"content":"·"},{"tailPos":5422,"headPos":5333,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"goalsAfter":[],"content":"exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)"},{"tailPos":5422,"headPos":5330,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"· exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)"},{"tailPos":5436,"headPos":5427,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"simp_rw ["},{"tailPos":5449,"headPos":5436,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (insert t R.parts)) = b"],"content":"extend_parts,"},{"tailPos":5464,"headPos":5450,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (insert t R.parts)) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if card t = m + 1 then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"content":"filter_insert,"},{"tailPos":5469,"headPos":5465,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if card t = m + 1 then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if (if 0 < a then m else m + 1) = m + 1 then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"content":"htn,"},{"tailPos":5506,"headPos":5470,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if (if 0 < a then m else m + 1) = m + 1 then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if ¬0 < a then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"content":"simp only [m.succ_ne_self.symm.ite_eq_right_iff]"},{"tailPos":5507,"headPos":5427,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if ¬0 < a then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"content":"simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]"},{"tailPos":5529,"headPos":5512,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if ¬0 < a then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"content":"split_ifs with ha"},{"tailPos":5536,"headPos":5534,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b"],"content":"·"},{"tailPos":5547,"headPos":5541,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ (if 0 < a then b else b - 1) = b"],"content":"hR₃,"},{"tailPos":5557,"headPos":5548,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ (if 0 < a then b else b - 1) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ b = b"],"content":"if_pos ha"},{"tailPos":5558,"headPos":5557,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ b = b"],"goalsAfter":[],"content":"]"},{"tailPos":5558,"headPos":5537,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b"],"goalsAfter":[],"content":"rw [hR₃, if_pos ha]"},{"tailPos":5558,"headPos":5534,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"content":"· rw [hR₃, if_pos ha]"},{"tailPos":5590,"headPos":5567,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) + 1 = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"card_insert_of_not_mem,"},{"tailPos":5597,"headPos":5591,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) + 1 = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ (if 0 < a then b else b - 1) + 1 = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"hR₃,"},{"tailPos":5608,"headPos":5598,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ (if 0 < a then b else b - 1) + 1 = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ b - 1 + 1 = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"if_neg ha,"},{"tailPos":5630,"headPos":5609,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ b - 1 + 1 = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ b = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"tsub_add_cancel_of_le"},{"tailPos":5631,"headPos":5630,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ b = b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"]"},{"tailPos":5631,"headPos":5563,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]"},{"tailPos":5638,"headPos":5636,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b"],"content":"·"},{"tailPos":5664,"headPos":5639,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b"],"goalsAfter":[],"content":"exact hab.resolve_left ha"},{"tailPos":5664,"headPos":5636,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ 1 ≤ b","case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"· exact hab.resolve_left ha"},{"tailPos":5671,"headPos":5669,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"·"},{"tailPos":5679,"headPos":5672,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"content":"intro H"},{"tailPos":5680,"headPos":5679,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"goalsAfter":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"content":";"},{"tailPos":5746,"headPos":5681,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"goalsAfter":[],"content":"exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":5746,"headPos":5672,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":[],"content":"intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":5746,"headPos":5669,"goalsBefore":["case pos.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\nt : Finset α\nhts : t ⊆ s\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nleft✝ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nha : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":[],"content":"· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":5746,"headPos":4668,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":[],"content":"obtain ⟨t, hts, htn⟩ := exists_smaller_set s n (hn₂.trans_eq hs)\n    have ht : t.Nonempty := by rwa [← card_pos, htn]\n    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]\n    obtain ⟨R, hR₁, _, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)\n        (if 0 < a then b else b - 1) (P.avoid t) hcard\n    refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _⟩\n    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _\n    · exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)\n    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]\n    split_ifs with ha\n    · rw [hR₃, if_pos ha]\n    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]\n    · exact hab.resolve_left ha\n    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":5746,"headPos":4665,"goalsBefore":["case pos\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b","case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ¬∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ¬∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"· obtain ⟨t, hts, htn⟩ := exists_smaller_set s n (hn₂.trans_eq hs)\n    have ht : t.Nonempty := by rwa [← card_pos, htn]\n    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]\n    obtain ⟨R, hR₁, _, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)\n        (if 0 < a then b else b - 1) (P.avoid t) hcard\n    refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _⟩\n    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _\n    · exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)\n    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]\n    split_ifs with ha\n    · rw [hR₃, if_pos ha]\n    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]\n    · exact hab.resolve_left ha\n    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":5763,"headPos":5749,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ¬∀ (u : Finset α), u ∈ P.parts → card u < m + 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∃ u, u ∈ P.parts ∧ m + 1 ≤ card u\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"push_neg  at h"},{"tailPos":5799,"headPos":5766,"goalsBefore":["case neg\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nh : ∃ u, u ∈ P.parts ∧ m + 1 ≤ card u\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain ⟨u, hu₁, hu₂⟩ := h"},{"tailPos":5872,"headPos":5802,"goalsBefore":["case neg.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain ⟨t, htu, htn⟩ := exists_smaller_set _ _ (hn₁.trans hu₂)"},{"tailPos":5920,"headPos":5907,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ 0 < card t"],"content":"← card_pos,"},{"tailPos":5924,"headPos":5921,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ 0 < card t"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ 0 < n"],"content":"htn"},{"tailPos":5925,"headPos":5924,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ 0 < n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ 0 < n"],"content":"]"},{"tailPos":5925,"headPos":5902,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":[],"content":"rwa [← card_pos, htn]"},{"tailPos":5901,"headPos":5899,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":[],"content":"by"},{"tailPos":5925,"headPos":5899,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ Finset.Nonempty t"],"goalsAfter":[],"content":"by rwa [← card_pos, htn]"},{"tailPos":5925,"headPos":5875,"goalsBefore":["case neg.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"have ht : t.Nonempty := by rwa [← card_pos, htn]"},{"tailPos":6067,"headPos":6030,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - card t"],"content":"card_sdiff (htu.trans <| P.le hu₁),"},{"tailPos":6072,"headPos":6068,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - card t"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"content":"htn,"},{"tailPos":6078,"headPos":6073,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ card s - n = card s - n"],"content":"hn₃"},{"tailPos":6079,"headPos":6078,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ card s - n = card s - n"],"goalsAfter":[],"content":"]"},{"tailPos":6079,"headPos":6026,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":[],"content":"rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]"},{"tailPos":6021,"headPos":6019,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":[],"content":"by"},{"tailPos":6079,"headPos":6019,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)"],"goalsAfter":[],"content":"by\n    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]"},{"tailPos":6079,"headPos":5928,"goalsBefore":["case neg.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]"},{"tailPos":6263,"headPos":6082,"goalsBefore":["case neg.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"content":"obtain ⟨R, hR₁, hR₂, hR₃⟩ :=\n    @ih (s \\ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)\n      (if 0 < a then b else b - 1) (P.avoid t) hcard"},{"tailPos":6370,"headPos":6266,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), _, _, _⟩"},{"tailPos":6375,"headPos":6373,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1"],"content":"·"},{"tailPos":6459,"headPos":6376,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ (if 0 < a then m else m + 1) = m ∨ (if 0 < a then m else m + 1) = m + 1"],"content":"simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]"},{"tailPos":6488,"headPos":6464,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ (if 0 < a then m else m + 1) = m ∨ (if 0 < a then m else m + 1) = m + 1"],"goalsAfter":[],"content":"exact ite_eq_or_eq _ _ _"},{"tailPos":6488,"headPos":6376,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1"],"goalsAfter":[],"content":"simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]\n    exact ite_eq_or_eq _ _ _"},{"tailPos":6488,"headPos":6373,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts → card x = m ∨ card x = m + 1","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]\n    exact ite_eq_or_eq _ _ _"},{"tailPos":6493,"headPos":6491,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"content":"·"},{"tailPos":6539,"headPos":6517,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\n| x ∈ P.parts"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\n| x ∈ insert u (erase P.parts u)"],"content":"← insert_erase hu₁"},{"tailPos":6540,"headPos":6513,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\n| x ∈ P.parts"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\n| x ∈ insert u (erase P.parts u)"],"content":"rw [← insert_erase hu₁]"},{"tailPos":6540,"headPos":6494,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ insert u (erase P.parts u) →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"content":"conv in _ ∈ _ => rw [← insert_erase hu₁]"},{"tailPos":6616,"headPos":6545,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ insert u (erase P.parts u) →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m ∧\n    ∀ (a : Finset α),\n      a ∈ erase P.parts u → card (a \\ Finset.biUnion (filter (fun y => y ⊆ a) (insert t R.parts)) id) ≤ m"],"content":"simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]"},{"tailPos":6690,"headPos":6621,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m ∧\n    ∀ (a : Finset α),\n      a ∈ erase P.parts u → card (a \\ Finset.biUnion (filter (fun y => y ⊆ a) (insert t R.parts)) id) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"content":"refine' ⟨_, fun x hx => (card_le_of_subset _).trans <| hR₂ x _⟩"},{"tailPos":6697,"headPos":6695,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m"],"content":"·"},{"tailPos":6770,"headPos":6698,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"content":"simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]"},{"tailPos":6809,"headPos":6777,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"content":"obtain rfl | hut := eq_or_ne u t"},{"tailPos":6818,"headPos":6816,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"content":"·"},{"tailPos":6874,"headPos":6823,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card ∅ ≤ m"],"content":"sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)"},{"tailPos":6875,"headPos":6874,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card ∅ ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card ∅ ≤ m"],"content":"]"},{"tailPos":6875,"headPos":6819,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card ∅ ≤ m"],"content":"rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]"},{"tailPos":6896,"headPos":6884,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card ∅ ≤ m"],"goalsAfter":[],"content":"exact bot_le"},{"tailPos":6896,"headPos":6819,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":[],"content":"rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le"},{"tailPos":6896,"headPos":6816,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nhtu : u ⊆ u\nhtn : card u = n\nht : Finset.Nonempty u\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ u)\nR : Finpartition (s \\ u)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P u).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ (u ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"content":"· rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le"},{"tailPos":7050,"headPos":6903,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\n⊢ card (u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id)) ≤ m"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\ni : α\n⊢ i ∈ u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id) →\n    i ∈ (u \\ t) \\ Finset.biUnion (filter (fun y => y ⊆ u \\ t) R.parts) id"],"content":"refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)"},{"tailPos":7260,"headPos":7149,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\ni : α\n⊢ i ∈ u \\ (t ∪ Finset.biUnion (filter (fun y => y ⊆ u) R.parts) id) →\n    i ∈ (u \\ t) \\ Finset.biUnion (filter (fun y => y ⊆ u \\ t) R.parts) id"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\ni : α\n⊢ i ∈ u →\n    ¬i ∈ t →\n      (∀ (x : Finset α), x ∈ R.parts → x ⊆ u → ¬i ∈ x) →\n        (i ∈ u ∧ ¬i ∈ t) ∧ ∀ (x : Finset α), x ∈ R.parts → x ⊆ u \\ t → ¬i ∈ x"],"content":"simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]"},{"tailPos":7391,"headPos":7267,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nhut : u ≠ t\ni : α\n⊢ i ∈ u →\n    ¬i ∈ t →\n      (∀ (x : Finset α), x ∈ R.parts → x ⊆ u → ¬i ∈ x) →\n        (i ∈ u ∧ ¬i ∈ t) ∧ ∀ (x : Finset α), x ∈ R.parts → x ⊆ u \\ t → ¬i ∈ x"],"goalsAfter":[],"content":"exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩"},{"tailPos":7391,"headPos":6698,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m"],"goalsAfter":[],"content":"simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      -- Porting note: `not_and` required because `∃ x ∈ s, p x` is defined differently\n      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩"},{"tailPos":7391,"headPos":6695,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_1\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (u \\ Finset.biUnion (filter (fun y => y ⊆ u) (insert t R.parts)) id) ≤ m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"content":"· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      -- Porting note: `not_and` required because `∃ x ∈ s, p x` is defined differently\n      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩"},{"tailPos":7398,"headPos":7396,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id"],"content":"·"},{"tailPos":7478,"headPos":7399,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ filter (fun y => y ⊆ x) R.parts ⊆ filter (fun y => y ⊆ x) (insert t R.parts)"],"content":"apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)"},{"tailPos":7533,"headPos":7485,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ filter (fun y => y ⊆ x) R.parts ⊆ filter (fun y => y ⊆ x) (insert t R.parts)"],"goalsAfter":[],"content":"exact filter_subset_filter _ (subset_insert _ _)"},{"tailPos":7533,"headPos":7399,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id"],"goalsAfter":[],"content":"apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)"},{"tailPos":7533,"headPos":7396,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x \\ Finset.biUnion (filter (fun y => y ⊆ x) (insert t R.parts)) id ⊆\n    x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"content":"· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)"},{"tailPos":7600,"headPos":7538,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ∈ (avoid P t).parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ≠ ∅ ∧ ∃ a, a ∈ P.parts ∧ a \\ t = x"],"content":"simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]"},{"tailPos":7834,"headPos":7605,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nx : Finset α\nhx : x ∈ erase P.parts u\n⊢ x ≠ ∅ ∧ ∃ a, a ∈ P.parts ∧ a \\ t = x"],"goalsAfter":[],"content":"exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <|\n            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩"},{"tailPos":7834,"headPos":6494,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m"],"goalsAfter":[],"content":"conv in _ ∈ _ => rw [← insert_erase hu₁]\n    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]\n    refine' ⟨_, fun x hx => (card_le_of_subset _).trans <| hR₂ x _⟩\n    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      -- Porting note: `not_and` required because `∃ x ∈ s, p x` is defined differently\n      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩\n    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)\n    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]\n    exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <|\n            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩"},{"tailPos":7834,"headPos":6491,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_2\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ ∀ (x : Finset α),\n    x ∈ P.parts →\n      card\n          (x \\\n            Finset.biUnion\n              (filter (fun y => y ⊆ x) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) id) ≤\n        m","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"content":"· conv in _ ∈ _ => rw [← insert_erase hu₁]\n    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]\n    refine' ⟨_, fun x hx => (card_le_of_subset _).trans <| hR₂ x _⟩\n    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      -- Porting note: `not_and` required because `∃ x ∈ s, p x` is defined differently\n      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩\n    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)\n    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]\n    exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <|\n            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩"},{"tailPos":7923,"headPos":7837,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card (filter (fun i => card i = m + 1) (extend R (_ : t ≠ ∅) (_ : Disjoint (s \\ t) t) (_ : s \\ t ⊔ t = s)).parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if ¬0 < a then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"content":"simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]"},{"tailPos":7942,"headPos":7926,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\n⊢ card\n      (if ¬0 < a then insert t (filter (fun i => card i = m + 1) R.parts)\n      else filter (fun i => card i = m + 1) R.parts) =\n    b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"content":"split_ifs with h"},{"tailPos":7947,"headPos":7945,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b"],"content":"·"},{"tailPos":7958,"headPos":7952,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ (if 0 < a then b else b - 1) = b"],"content":"hR₃,"},{"tailPos":7967,"headPos":7959,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ (if 0 < a then b else b - 1) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ b = b"],"content":"if_pos h"},{"tailPos":7968,"headPos":7967,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ b = b"],"goalsAfter":[],"content":"]"},{"tailPos":7968,"headPos":7948,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b"],"goalsAfter":[],"content":"rw [hR₃, if_pos h]"},{"tailPos":7968,"headPos":7945,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inl\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : 0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"content":"· rw [hR₃, if_pos h]"},{"tailPos":7973,"headPos":7971,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"content":"·"},{"tailPos":8001,"headPos":7978,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) + 1 = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"card_insert_of_not_mem,"},{"tailPos":8008,"headPos":8002,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (filter (fun i => card i = m + 1) R.parts) + 1 = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ (if 0 < a then b else b - 1) + 1 = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"hR₃,"},{"tailPos":8018,"headPos":8009,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ (if 0 < a then b else b - 1) + 1 = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ b - 1 + 1 = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"if_neg h,"},{"tailPos":8058,"headPos":8019,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ b - 1 + 1 = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ b = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"Nat.sub_add_cancel (hab.resolve_left h)"},{"tailPos":8059,"headPos":8058,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ b = b","case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"]"},{"tailPos":8059,"headPos":7974,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"content":"rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]"},{"tailPos":8071,"headPos":8064,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ ¬t ∈ filter (fun i => card i = m + 1) R.parts"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"content":"intro H"},{"tailPos":8072,"headPos":8071,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"goalsAfter":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"content":";"},{"tailPos":8138,"headPos":8073,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\nH : t ∈ filter (fun i => card i = m + 1) R.parts\n⊢ False"],"goalsAfter":[],"content":"exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":8138,"headPos":7974,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":[],"content":"rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]\n    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":8138,"headPos":7971,"goalsBefore":["case neg.intro.intro.intro.intro.intro.intro.intro.refine'_3.inr\nα : Type u_1\ninst✝ : DecidableEq α\ns✝ t✝ : Finset α\nm n✝ a✝ b✝ : ℕ\nP✝ : Finpartition s✝\nhs✝ : a✝ * m + b✝ * (m + 1) = card s✝\nm_pos : m > 0\ns : Finset α\nih :\n  ∀ (t : Finset α),\n    t ⊂ s →\n      ∀ {a b : ℕ} {P : Finpartition t},\n        a * m + b * (m + 1) = card t →\n          ∃ Q,\n            (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n              (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n                card (filter (fun i => card i = m + 1) Q.parts) = b\na b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\nhab : 0 < a ∨ 0 < b\nn : ℕ := if 0 < a then m else m + 1\nhn : n = if 0 < a then m else m + 1\nhn₀ : 0 < n\nhn₁ : n ≤ m + 1\nhn₂ : n ≤ a * m + b * (m + 1)\nhn₃ : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card s - n\nu : Finset α\nhu₁ : u ∈ P.parts\nhu₂ : m + 1 ≤ card u\nt : Finset α\nhtu : t ⊆ u\nhtn : card t = n\nht : Finset.Nonempty t\nhcard : (if 0 < a then a - 1 else a) * m + (if 0 < a then b else b - 1) * (m + 1) = card (s \\ t)\nR : Finpartition (s \\ t)\nhR₁ : ∀ (x : Finset α), x ∈ R.parts → card x = m ∨ card x = m + 1\nhR₂ : ∀ (x : Finset α), x ∈ (avoid P t).parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) R.parts) id) ≤ m\nhR₃ : card (filter (fun i => card i = m + 1) R.parts) = if 0 < a then b else b - 1\nh : ¬0 < a\n⊢ card (insert t (filter (fun i => card i = m + 1) R.parts)) = b"],"goalsAfter":[],"content":"· rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]\n    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":8138,"headPos":2363,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":[],"content":"obtain rfl | m_pos := m.eq_zero_or_pos\n  · refine' ⟨⊥, by simp, _, by simpa using hs.symm⟩\n    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,\n      sdiff_eq_empty_iff_subset, subset_iff]\n    exact fun x hx a ha =>\n      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩\n  -- Prove the case `m > 0` by strong induction on `s`\n  induction' s using Finset.strongInduction with s ih generalizing a b\n  -- If `a = b = 0`, then `s = ∅` and we can partition into zero parts\n  by_cases hab : a = 0 ∧ b = 0\n  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs\n    subst hs\n    -- Porting note: to synthesize `Finpartition ∅`, `have` is required\n    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P\n    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩\n  simp_rw [not_and_or, ← Ne.def, ← pos_iff_ne_zero] at hab\n  -- `n` will be the size of the smallest part\n  set n := if 0 < a then m else m + 1 with hn\n  -- Some easy facts about it\n  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧\n      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by\n    rw [hn, ← hs]\n    split_ifs with h <;> rw [tsub_mul, one_mul]\n    · refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]\n    · refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]\n  /- We will call the inductive hypothesis on a partition of `s \\ t` for a carefully chosen `t ⊆ s`.\n    To decide which, however, we must distinguish the case where all parts of `P` have size `m` (in\n    which case we take `t` to be an arbitrary subset of `s` of size `n`) from the case where at\n    least one part `u` of `P` has size `m + 1` (in which case we take `t` to be an arbitrary subset\n    of `u` of size `n`). The rest of each branch is just tedious calculations to satisfy the\n    induction hypothesis. -/\n  by_cases h : ∀ u ∈ P.parts, card u < m + 1\n  · obtain ⟨t, hts, htn⟩ := exists_smaller_set s n (hn₂.trans_eq hs)\n    have ht : t.Nonempty := by rwa [← card_pos, htn]\n    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]\n    obtain ⟨R, hR₁, _, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)\n        (if 0 < a then b else b - 1) (P.avoid t) hcard\n    refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _⟩\n    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _\n    · exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)\n    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]\n    split_ifs with ha\n    · rw [hR₃, if_pos ha]\n    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]\n    · exact hab.resolve_left ha\n    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)\n  push_neg  at h\n  obtain ⟨u, hu₁, hu₂⟩ := h\n  obtain ⟨t, htu, htn⟩ := exists_smaller_set _ _ (hn₁.trans hu₂)\n  have ht : t.Nonempty := by rwa [← card_pos, htn]\n  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]\n  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=\n    @ih (s \\ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)\n      (if 0 < a then b else b - 1) (P.avoid t) hcard\n  refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), _, _, _⟩\n  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]\n    exact ite_eq_or_eq _ _ _\n  · conv in _ ∈ _ => rw [← insert_erase hu₁]\n    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]\n    refine' ⟨_, fun x hx => (card_le_of_subset _).trans <| hR₂ x _⟩\n    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      -- Porting note: `not_and` required because `∃ x ∈ s, p x` is defined differently\n      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩\n    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)\n    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]\n    exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <|\n            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩\n  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]\n  split_ifs with h\n  · rw [hR₃, if_pos h]\n  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]\n    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":2322,"headPos":2320,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":[],"content":"by"},{"tailPos":8138,"headPos":2320,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nhs : a * m + b * (m + 1) = card s\n⊢ ∃ Q,\n    (∀ (x : Finset α), x ∈ Q.parts → card x = m ∨ card x = m + 1) ∧\n      (∀ (x : Finset α), x ∈ P.parts → card (x \\ Finset.biUnion (filter (fun y => y ⊆ x) Q.parts) id) ≤ m) ∧\n        card (filter (fun i => card i = m + 1) Q.parts) = b"],"goalsAfter":[],"content":"by\n  -- Get rid of the easy case `m = 0`\n  obtain rfl | m_pos := m.eq_zero_or_pos\n  · refine' ⟨⊥, by simp, _, by simpa using hs.symm⟩\n    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,\n      sdiff_eq_empty_iff_subset, subset_iff]\n    exact fun x hx a ha =>\n      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩\n  -- Prove the case `m > 0` by strong induction on `s`\n  induction' s using Finset.strongInduction with s ih generalizing a b\n  -- If `a = b = 0`, then `s = ∅` and we can partition into zero parts\n  by_cases hab : a = 0 ∧ b = 0\n  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs\n    subst hs\n    -- Porting note: to synthesize `Finpartition ∅`, `have` is required\n    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P\n    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩\n  simp_rw [not_and_or, ← Ne.def, ← pos_iff_ne_zero] at hab\n  -- `n` will be the size of the smallest part\n  set n := if 0 < a then m else m + 1 with hn\n  -- Some easy facts about it\n  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧\n      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by\n    rw [hn, ← hs]\n    split_ifs with h <;> rw [tsub_mul, one_mul]\n    · refine' ⟨m_pos, le_succ _, le_add_right (le_mul_of_pos_left ‹0 < a›), _⟩\n      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]\n    · refine' ⟨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›), _⟩\n      rw [← add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left ‹¬0 < a›)]\n  /- We will call the inductive hypothesis on a partition of `s \\ t` for a carefully chosen `t ⊆ s`.\n    To decide which, however, we must distinguish the case where all parts of `P` have size `m` (in\n    which case we take `t` to be an arbitrary subset of `s` of size `n`) from the case where at\n    least one part `u` of `P` has size `m + 1` (in which case we take `t` to be an arbitrary subset\n    of `u` of size `n`). The rest of each branch is just tedious calculations to satisfy the\n    induction hypothesis. -/\n  by_cases h : ∀ u ∈ P.parts, card u < m + 1\n  · obtain ⟨t, hts, htn⟩ := exists_smaller_set s n (hn₂.trans_eq hs)\n    have ht : t.Nonempty := by rwa [← card_pos, htn]\n    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]\n    obtain ⟨R, hR₁, _, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)\n        (if 0 < a then b else b - 1) (P.avoid t) hcard\n    refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _⟩\n    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _\n    · exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)\n    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]\n    split_ifs with ha\n    · rw [hR₃, if_pos ha]\n    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]\n    · exact hab.resolve_left ha\n    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)\n  push_neg  at h\n  obtain ⟨u, hu₁, hu₂⟩ := h\n  obtain ⟨t, htu, htn⟩ := exists_smaller_set _ _ (hn₁.trans hu₂)\n  have ht : t.Nonempty := by rwa [← card_pos, htn]\n  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \\ t).card := by\n    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]\n  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=\n    @ih (s \\ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)\n      (if 0 < a then b else b - 1) (P.avoid t) hcard\n  refine' ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), _, _, _⟩\n  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]\n    exact ite_eq_or_eq _ _ _\n  · conv in _ ∈ _ => rw [← insert_erase hu₁]\n    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]\n    refine' ⟨_, fun x hx => (card_le_of_subset _).trans <| hR₂ x _⟩\n    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]\n        exact bot_le\n      refine'\n        (card_le_of_subset fun i => _).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      -- Porting note: `not_and` required because `∃ x ∈ s, p x` is defined differently\n      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,\n        id.def, not_or]\n      exact fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans <| sdiff_subset _ _⟩\n    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)\n    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]\n    exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <|\n            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩\n  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]\n  split_ifs with h\n  · rw [hR₃, if_pos h]\n  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]\n    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"},{"tailPos":9862,"headPos":9777,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) = a"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) = a * m + b * (m + 1)"],"content":"refine' (mul_eq_mul_right_iff.1 <| (add_left_inj (b * (m + 1))).1 _).resolve_right hm"},{"tailPos":9871,"headPos":9869,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) = a * m + b * (m + 1)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) = card s"],"content":"h,"},{"tailPos":9909,"headPos":9872,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"content":"← (P.equitabilise h).sum_card_parts"},{"tailPos":9910,"headPos":9909,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"content":"]"},{"tailPos":9910,"headPos":9865,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) = a * m + b * (m + 1)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"content":"rw [h, ← (P.equitabilise h).sum_card_parts]"},{"tailPos":10114,"headPos":10100,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts = filter (fun a => card a = m ∨ card a = m + 1) (equitabilise h).parts"],"content":"← filter_or,"},{"tailPos":10133,"headPos":10115,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts = filter (fun a => card a = m ∨ card a = m + 1) (equitabilise h).parts"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts = (equitabilise h).parts","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ ∀ (x : Finset α), x ∈ (equitabilise h).parts → card x = m ∨ card x = m + 1"],"content":"filter_true_of_mem"},{"tailPos":10134,"headPos":10133,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts = (equitabilise h).parts","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ ∀ (x : Finset α), x ∈ (equitabilise h).parts → card x = m ∨ card x = m + 1"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ ∀ (x : Finset α), x ∈ (equitabilise h).parts → card x = m ∨ card x = m + 1"],"content":"]"},{"tailPos":10134,"headPos":10096,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ ∀ (x : Finset α), x ∈ (equitabilise h).parts → card x = m ∨ card x = m + 1"],"content":"rw [← filter_or, filter_true_of_mem]"},{"tailPos":10187,"headPos":10139,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ ∀ (x : Finset α), x ∈ (equitabilise h).parts → card x = m ∨ card x = m + 1"],"goalsAfter":[],"content":"exact fun x => card_eq_of_mem_parts_equitabilise"},{"tailPos":10187,"headPos":10096,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts"],"goalsAfter":[],"content":"rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise"},{"tailPos":10091,"headPos":10089,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts"],"goalsAfter":[],"content":"by"},{"tailPos":10187,"headPos":10089,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts"],"goalsAfter":[],"content":"by\n    rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise"},{"tailPos":10187,"headPos":9913,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"content":"have hunion :\n    (P.equitabilise h).parts =\n      ((P.equitabilise h).parts.filter fun u => u.card = m) ∪\n        (P.equitabilise h).parts.filter fun u => u.card = m + 1 := by\n    rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise"},{"tailPos":10206,"headPos":10200,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum\n      (filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts)\n      fun i => card i"],"content":"hunion"},{"tailPos":10207,"headPos":10206,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum\n      (filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts)\n      fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum\n      (filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts)\n      fun i => card i"],"content":"]"},{"tailPos":10207,"headPos":10190,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum (equitabilise h).parts fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum\n      (filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts)\n      fun i => card i"],"content":"nth_rw 2 [hunion]"},{"tailPos":10224,"headPos":10214,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum\n      (filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts)\n      fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    (Finset.sum (filter (fun u => card u = m) (equitabilise h).parts) fun x => card x) +\n      Finset.sum (filter (fun u => card u = m + 1) (equitabilise h).parts) fun x => card x","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"content":"sum_union,"},{"tailPos":10271,"headPos":10225,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    (Finset.sum (filter (fun u => card u = m) (equitabilise h).parts) fun x => card x) +\n      Finset.sum (filter (fun u => card u = m + 1) (equitabilise h).parts) fun x => card x","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    card (filter (fun x => card x = m) (equitabilise h).parts) * m +\n      Finset.sum (filter (fun u => card u = m + 1) (equitabilise h).parts) fun x => card x","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"content":"sum_const_nat fun x hx => (mem_filter.1 hx).2,"},{"tailPos":10322,"headPos":10276,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    card (filter (fun x => card x = m) (equitabilise h).parts) * m +\n      Finset.sum (filter (fun u => card u = m + 1) (equitabilise h).parts) fun x => card x","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    card (filter (fun x => card x = m) (equitabilise h).parts) * m +\n      card (filter (fun x => card x = m + 1) (equitabilise h).parts) * (m + 1)","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"content":"sum_const_nat fun x hx => (mem_filter.1 hx).2,"},{"tailPos":10353,"headPos":10323,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    card (filter (fun x => card x = m) (equitabilise h).parts) * m +\n      card (filter (fun x => card x = m + 1) (equitabilise h).parts) * (m + 1)","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    card (filter (fun x => card x = m) (equitabilise h).parts) * m + b * (m + 1)","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"content":"P.card_filter_equitabilise_big"},{"tailPos":10354,"headPos":10353,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    card (filter (fun x => card x = m) (equitabilise h).parts) * m + b * (m + 1)","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"content":"]"},{"tailPos":10354,"headPos":10210,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) * m + b * (m + 1) =\n    Finset.sum\n      (filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts)\n      fun i => card i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"content":"rw [sum_union, sum_const_nat fun x hx => (mem_filter.1 hx).2,\n    sum_const_nat fun x hx => (mem_filter.1 hx).2, P.card_filter_equitabilise_big]"},{"tailPos":10394,"headPos":10357,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (filter (fun u => card u = m) (equitabilise h).parts)\n    (filter (fun u => card u = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (fun u => card u = m) fun u => card u = m + 1"],"content":"refine' disjoint_filter_filter' _ _ _"},{"tailPos":10414,"headPos":10397,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h).parts =\n    filter (fun u => card u = m) (equitabilise h).parts ∪ filter (fun u => card u = m + 1) (equitabilise h).parts\n⊢ Disjoint (fun u => card u = m) fun u => card u = m + 1"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh✝ : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h✝).parts =\n    filter (fun u => card u = m) (equitabilise h✝).parts ∪ filter (fun u => card u = m + 1) (equitabilise h✝).parts\nx : Finset α → Prop\nha : x ≤ fun u => card u = m\nhb : x ≤ fun u => card u = m + 1\ni : Finset α\nh : x i\n⊢ ⊥ i"],"content":"intro x ha hb i h"},{"tailPos":10439,"headPos":10417,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh✝ : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h✝).parts =\n    filter (fun u => card u = m) (equitabilise h✝).parts ∪ filter (fun u => card u = m + 1) (equitabilise h✝).parts\nx : Finset α → Prop\nha : x ≤ fun u => card u = m\nhb : x ≤ fun u => card u = m + 1\ni : Finset α\nh : x i\n⊢ ⊥ i"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh✝ : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h✝).parts =\n    filter (fun u => card u = m) (equitabilise h✝).parts ∪ filter (fun u => card u = m + 1) (equitabilise h✝).parts\nx : Finset α → Prop\nha : x ≤ fun u => card u = m\nhb : x ≤ fun u => card u = m + 1\ni : Finset α\nh : x i\n⊢ succ m = m"],"content":"apply succ_ne_self m _"},{"tailPos":10476,"headPos":10442,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh✝ : a * m + b * (m + 1) = card s\nhm : m ≠ 0\nhunion :\n  (equitabilise h✝).parts =\n    filter (fun u => card u = m) (equitabilise h✝).parts ∪ filter (fun u => card u = m + 1) (equitabilise h✝).parts\nx : Finset α → Prop\nha : x ≤ fun u => card u = m\nhb : x ≤ fun u => card u = m + 1\ni : Finset α\nh : x i\n⊢ succ m = m"],"goalsAfter":[],"content":"exact (hb i h).symm.trans (ha i h)"},{"tailPos":10476,"headPos":9777,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) = a"],"goalsAfter":[],"content":"refine' (mul_eq_mul_right_iff.1 <| (add_left_inj (b * (m + 1))).1 _).resolve_right hm\n  rw [h, ← (P.equitabilise h).sum_card_parts]\n  have hunion :\n    (P.equitabilise h).parts =\n      ((P.equitabilise h).parts.filter fun u => u.card = m) ∪\n        (P.equitabilise h).parts.filter fun u => u.card = m + 1 := by\n    rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise\n  nth_rw 2 [hunion]\n  rw [sum_union, sum_const_nat fun x hx => (mem_filter.1 hx).2,\n    sum_const_nat fun x hx => (mem_filter.1 hx).2, P.card_filter_equitabilise_big]\n  refine' disjoint_filter_filter' _ _ _\n  intro x ha hb i h\n  apply succ_ne_self m _\n  exact (hb i h).symm.trans (ha i h)"},{"tailPos":9774,"headPos":9772,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) = a"],"goalsAfter":[],"content":"by"},{"tailPos":10476,"headPos":9772,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun u => card u = m) (equitabilise h).parts) = a"],"goalsAfter":[],"content":"by\n  refine' (mul_eq_mul_right_iff.1 <| (add_left_inj (b * (m + 1))).1 _).resolve_right hm\n  rw [h, ← (P.equitabilise h).sum_card_parts]\n  have hunion :\n    (P.equitabilise h).parts =\n      ((P.equitabilise h).parts.filter fun u => u.card = m) ∪\n        (P.equitabilise h).parts.filter fun u => u.card = m + 1 := by\n    rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise\n  nth_rw 2 [hunion]\n  rw [sum_union, sum_const_nat fun x hx => (mem_filter.1 hx).2,\n    sum_const_nat fun x hx => (mem_filter.1 hx).2, P.card_filter_equitabilise_big]\n  refine' disjoint_filter_filter' _ _ _\n  intro x ha hb i h\n  apply succ_ne_self m _\n  exact (hb i h).symm.trans (ha i h)"},{"tailPos":10738,"headPos":10672,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (equitabilise h).parts = a + b"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun x => card x = m ∨ card x = m + 1) (equitabilise h).parts) = a + b"],"content":"← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise,"},{"tailPos":10749,"headPos":10739,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun x => card x = m ∨ card x = m + 1) (equitabilise h).parts) = a + b"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun x => card x = m) (equitabilise h).parts ∪ filter (fun x => card x = m + 1) (equitabilise h).parts) =\n    a + b"],"content":"filter_or,"},{"tailPos":10764,"headPos":10750,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun x => card x = m) (equitabilise h).parts ∪ filter (fun x => card x = m + 1) (equitabilise h).parts) =\n    a + b"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun x => card x = m) (equitabilise h).parts) +\n      card (filter (fun x => card x = m + 1) (equitabilise h).parts) =\n    a + b","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"content":"card_union_eq,"},{"tailPos":10807,"headPos":10769,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (filter (fun x => card x = m) (equitabilise h).parts) +\n      card (filter (fun x => card x = m + 1) (equitabilise h).parts) =\n    a + b","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ a + card (filter (fun x => card x = m + 1) (equitabilise h).parts) = a + b","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"content":"P.card_filter_equitabilise_small _ hm,"},{"tailPos":10838,"headPos":10808,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ a + card (filter (fun x => card x = m + 1) (equitabilise h).parts) = a + b","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ a + b = a + b","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"content":"P.card_filter_equitabilise_big"},{"tailPos":10839,"headPos":10838,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ a + b = a + b","α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"content":"]"},{"tailPos":10839,"headPos":10668,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (equitabilise h).parts = a + b"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"content":"rw [← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise, filter_or, card_union_eq,\n    P.card_filter_equitabilise_small _ hm, P.card_filter_equitabilise_big]"},{"tailPos":10969,"headPos":10882,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ Disjoint (filter (fun x => card x = m) (equitabilise h).parts)\n    (filter (fun x => card x = m + 1) (equitabilise h).parts)"],"goalsAfter":[],"content":"exact disjoint_filter.2 fun x _ h₀ h₁ => Nat.succ_ne_self m <| h₁.symm.trans h₀"},{"tailPos":10969,"headPos":10668,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (equitabilise h).parts = a + b"],"goalsAfter":[],"content":"rw [← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise, filter_or, card_union_eq,\n    P.card_filter_equitabilise_small _ hm, P.card_filter_equitabilise_big]\n  -- Porting note: was `infer_instance`\n  exact disjoint_filter.2 fun x _ h₀ h₁ => Nat.succ_ne_self m <| h₁.symm.trans h₀"},{"tailPos":10665,"headPos":10663,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (equitabilise h).parts = a + b"],"goalsAfter":[],"content":"by"},{"tailPos":10969,"headPos":10663,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhm : m ≠ 0\n⊢ card (equitabilise h).parts = a + b"],"goalsAfter":[],"content":"by\n  rw [← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise, filter_or, card_union_eq,\n    P.card_filter_equitabilise_small _ hm, P.card_filter_equitabilise_big]\n  -- Porting note: was `infer_instance`\n  exact disjoint_filter.2 fun x _ h₀ h₁ => Nat.succ_ne_self m <| h₁.symm.trans h₀"},{"tailPos":11597,"headPos":11578,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : n ≠ 0\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"content":"← pos_iff_ne_zero"},{"tailPos":11598,"headPos":11597,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"content":"]"},{"tailPos":11604,"headPos":11574,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : n ≠ 0\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"content":"rw [← pos_iff_ne_zero] at hn"},{"tailPos":11710,"headPos":11701,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) - card s % n * (card s / n) + card s % n * (card s / n + 1) = card s"],"content":"tsub_mul,"},{"tailPos":11719,"headPos":11711,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) - card s % n * (card s / n) + card s % n * (card s / n + 1) = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) - card s % n * (card s / n) + (card s % n * (card s / n) + card s % n * 1) = card s"],"content":"mul_add,"},{"tailPos":11734,"headPos":11720,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) - card s % n * (card s / n) + (card s % n * (card s / n) + card s % n * 1) = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) - card s % n * (card s / n) + card s % n * (card s / n) + card s % n * 1 = card s"],"content":"← add_assoc,"},{"tailPos":11805,"headPos":11741,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) - card s % n * (card s / n) + card s % n * (card s / n) + card s % n * 1 = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) + card s % n * 1 = card s"],"content":"tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le),"},{"tailPos":11814,"headPos":11806,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) + card s % n * 1 = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) + card s % n = card s"],"content":"mul_one,"},{"tailPos":11824,"headPos":11815,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ n * (card s / n) + card s % n = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ card s % n + n * (card s / n) = card s"],"content":"add_comm,"},{"tailPos":11842,"headPos":11831,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ card s % n + n * (card s / n) = card s"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ card s = card s"],"content":"mod_add_div"},{"tailPos":11843,"headPos":11842,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ card s = card s"],"goalsAfter":[],"content":"]"},{"tailPos":11843,"headPos":11697,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s"],"goalsAfter":[],"content":"rw [tsub_mul, mul_add, ← add_assoc,\n      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,\n      mod_add_div]"},{"tailPos":11692,"headPos":11690,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s"],"goalsAfter":[],"content":"by"},{"tailPos":11843,"headPos":11690,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s"],"goalsAfter":[],"content":"by\n    rw [tsub_mul, mul_add, ← add_assoc,\n      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,\n      mod_add_div]"},{"tailPos":11843,"headPos":11607,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"content":"have : (n - s.card % n) * (s.card / n) + s.card % n * (s.card / n + 1) = s.card := by\n    rw [tsub_mul, mul_add, ← add_assoc,\n      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,\n      mod_add_div]"},{"tailPos":11973,"headPos":11846,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ card (equitabilise this).parts = n"],"content":"refine'\n    ⟨(indiscrete (card_pos.1 <| hn.trans_le hs).ne_empty).equitabilise this,\n      equitabilise_isEquipartition, _⟩"},{"tailPos":12032,"headPos":11980,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ card (equitabilise this).parts = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ n - card s % n + card s % n = n"],"content":"card_parts_equitabilise _ _ (Nat.div_pos hs hn).ne',"},{"tailPos":12071,"headPos":12033,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ n - card s % n + card s % n = n"],"goalsAfter":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ n = n"],"content":"tsub_add_cancel_of_le (mod_lt _ hn).le"},{"tailPos":12072,"headPos":12071,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ n = n"],"goalsAfter":[],"content":"]"},{"tailPos":12072,"headPos":11976,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : 0 < n\nhs : n ≤ card s\nthis : (n - card s % n) * (card s / n) + card s % n * (card s / n + 1) = card s\n⊢ card (equitabilise this).parts = n"],"goalsAfter":[],"content":"rw [card_parts_equitabilise _ _ (Nat.div_pos hs hn).ne', tsub_add_cancel_of_le (mod_lt _ hn).le]"},{"tailPos":12072,"headPos":11574,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : n ≠ 0\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":[],"content":"rw [← pos_iff_ne_zero] at hn\n  have : (n - s.card % n) * (s.card / n) + s.card % n * (s.card / n + 1) = s.card := by\n    rw [tsub_mul, mul_add, ← add_assoc,\n      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,\n      mod_add_div]\n  refine'\n    ⟨(indiscrete (card_pos.1 <| hn.trans_le hs).ne_empty).equitabilise this,\n      equitabilise_isEquipartition, _⟩\n  rw [card_parts_equitabilise _ _ (Nat.div_pos hs hn).ne', tsub_add_cancel_of_le (mod_lt _ hn).le]"},{"tailPos":11571,"headPos":11569,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : n ≠ 0\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":[],"content":"by"},{"tailPos":12072,"headPos":11569,"goalsBefore":["α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm n a b : ℕ\nP : Finpartition s\nh : a * m + b * (m + 1) = card s\nhn : n ≠ 0\nhs : n ≤ card s\n⊢ ∃ P, IsEquipartition P ∧ card P.parts = n"],"goalsAfter":[],"content":"by\n  rw [← pos_iff_ne_zero] at hn\n  have : (n - s.card % n) * (s.card / n) + s.card % n * (s.card / n + 1) = s.card := by\n    rw [tsub_mul, mul_add, ← add_assoc,\n      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,\n      mod_add_div]\n  refine'\n    ⟨(indiscrete (card_pos.1 <| hn.trans_le hs).ne_empty).equitabilise this,\n      equitabilise_isEquipartition, _⟩\n  rw [card_parts_equitabilise _ _ (Nat.div_pos hs hn).ne', tsub_add_cancel_of_le (mod_lt _ hn).le]"}]